<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger & Die - Game</title>
    <!-- Google Analytics (GA4) - Replace G-XXXXXXXXXX with your Measurement ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Setup Screen */
        #setup-screen {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            margin: 0 auto;
        }

        .setup-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
        }

        .player-count-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .player-count-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .player-count-btn:hover, .player-count-btn.selected {
            background: #48dbfb;
            transform: scale(1.1);
        }

        .player-setup {
            display: none;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-setup.visible {
            display: flex;
        }

        .player-input {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .player-input input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1rem;
        }

        .player-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .player-input.error input,
        .player-input.error-duplicate input {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.4);
        }

        .setup-error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 20px;
            color: #ff6b6b;
            font-size: 0.95rem;
        }

        .color-picker {
            display: flex;
            align-items: center;
        }

        .color-picker-wrap {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .color-picker-wrap:hover {
            transform: scale(1.12);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.8);
        }

        .color-swatch {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        .player-color-input {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }

        /* Custom circular color picker modal */
        .color-picker-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .color-picker-modal-overlay.open {
            display: flex;
        }

        .color-picker-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .color-picker-modal h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: rgba(255,255,255,0.9);
        }

        .color-wheel-container {
            position: relative;
            width: 260px;
            height: 260px;
            margin: 0 auto 20px;
            touch-action: none;
        }

        .color-wheel-hue {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #ff0000, #ff8800, #ffff00, #88ff00, #00ff00, #00ff88, #00ffff, #0088ff, #0000ff, #8800ff, #ff00ff, #ff0088, #ff0000);
            padding: 12px;
        }

        .color-wheel-inner {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: #1e2a3a;
        }

        .color-wheel-sat {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--picker-gray, #808080) 0%, var(--picker-hue-color, #f00) 100%);
            cursor: crosshair;
        }

        .color-wheel-hue-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .color-wheel-sat-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .color-picker-lightness {
            margin-bottom: 20px;
        }

        .color-picker-lightness label {
            display: block;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 8px;
        }

        .color-picker-lightness input[type="range"] {
            width: 100%;
            height: 28px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-top: -7px;
            cursor: pointer;
        }

        .color-picker-lightness input[type="range"]::-moz-range-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
        }

        .color-picker-done {
            display: block;
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(45deg, #48dbfb, #0abde3);
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-picker-done:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,171,227,0.4);
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(238, 90, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            color: #fff;
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        /* Game Screen */
        #game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-gear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-gear-btn:hover {
            background: rgba(72, 219, 251, 0.3);
            color: #48dbfb;
        }

        .settings-gear-btn svg {
            width: 22px;
            height: 22px;
        }

        .settings-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .settings-modal-overlay.open {
            display: flex;
        }

        .settings-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .settings-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
        }

        .settings-modal label {
            display: block;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.9);
            font-size: 0.95rem;
        }

        .settings-modal input[type="number"] {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .settings-modal input[type="number"]:focus {
            outline: none;
            border-color: #48dbfb;
        }

        .settings-modal .setting-hint {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 20px;
        }

        .settings-modal .setting-readonly-hint {
            color: #feca57;
            margin-bottom: 16px;
        }

        .settings-modal .option-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .settings-modal .option-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #48dbfb;
        }

        .settings-modal .option-row label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .settings-modal .custom-hp-row {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        .settings-modal input[type="number"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-modal .btn {
            width: 100%;
            margin-top: 8px;
        }

        /* Player stats modal */
        .player-stats-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .player-stats-modal-overlay.open {
            display: flex;
        }

        .player-stats-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .player-stats-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
            text-align: center;
        }

        .player-stats-modal h4 {
            font-size: 1rem;
            color: #48dbfb;
            margin-bottom: 10px;
        }

        .player-stats-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
        }

        .player-stats-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .player-stats-meta {
            flex: 1;
        }

        .player-stats-row {
            margin-bottom: 6px;
            color: rgba(255,255,255,0.95);
            font-size: 1rem;
        }

        .player-stats-section {
            margin-bottom: 24px;
        }

        .player-stats-section .setting-hint {
            margin-bottom: 12px;
        }

        .player-stats-modal .btn {
            width: 100%;
        }

        .turn-indicator {
            font-size: 1.5rem;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .current-player-name {
            font-weight: bold;
        }

        /* Players Panel */
        .players-panel {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
            justify-content: center;
        }

        .player-card {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.current {
            border-color: #feca57;
            box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
            transform: scale(1.05);
        }

        .player-card.eliminated {
            opacity: 0.4;
            filter: grayscale(1);
        }

        .player-card.targetable {
            cursor: pointer;
        }

        .player-card.targetable:hover {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
        }

        .player-card-stats-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
        }

        .player-card-stats-btn:hover {
            background: rgba(72, 219, 251, 0.4);
            color: #48dbfb;
        }

        .player-card-stats-btn svg {
            width: 16px;
            height: 16px;
        }

        .player-card-dropped {
            animation: dropped-flash 0.6s ease-out;
        }

        @keyframes dropped-flash {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.8); transform: scale(1.05); }
            30% { box-shadow: 0 0 25px 8px rgba(255, 107, 107, 0.5); border-color: #ff6b6b; }
            100% { box-shadow: none; border-color: transparent; transform: scale(1); }
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-hp {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #2ecc71);
            transition: width 0.5s;
        }

        .player-turn-order {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        /* Game Area */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        /* Dice Section */
        .dice-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .section-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .die {
            width: 65px;
            height: 65px;
            background: linear-gradient(145deg, #2d3436, #1e272e);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .die.rolling {
            animation: roll 0.1s infinite;
        }

        .die.odd {
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .die.even {
            color: #48dbfb;
            border-color: #48dbfb;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
        }

        .roll-btn {
            display: block;
            margin: 0 auto 20px;
            padding: 15px 50px;
        }

        .dice-results {
            text-align: center;
            margin-top: 15px;
        }

        .total-damage {
            font-size: 1.5rem;
            color: #feca57;
        }

        /* Target Section */
        .targets-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .targets-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .target-wrapper {
            position: relative;
            width: 180px;
        }

        .target-label {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.85rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .target-image-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 50%;
            overflow: hidden;
            /* Wood base color */
            background: radial-gradient(
                    circle at 45% 45%,
                    #d4a574 0%,
                    #c4956a 20%,
                    #b8895e 40%,
                    #a67c52 60%,
                    #8b6914 80%,
                    #6b4423 100%
                );
            border: 8px solid #3d2914;
            box-shadow:
                inset 0 0 20px rgba(0,0,0,0.3),
                inset 0 0 40px rgba(0,0,0,0.1),
                0 5px 15px rgba(0,0,0,0.5),
                0 2px 6px rgba(0,0,0,0.3);
        }

        .target-image {
            width: 90%;
            height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            object-fit: contain;
            object-position: center;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            z-index: 2;
        }

        .target-overlay {
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            pointer-events: none;
            z-index: 3;
        }

        .target-overlay.clickable {
            pointer-events: auto;
        }

        .target-overlay.clickable .highlight-zone {
            cursor: pointer;
        }

        .highlight-zone {
            fill: transparent;
            stroke: transparent;
            stroke-width: 3;
            transition: all 0.3s;
        }

        .highlight-zone.active {
            fill: rgba(255, 215, 0, 0.4);
            stroke: #ffd700;
            stroke-width: 4;
            animation: pulse 1s infinite;
        }

        .highlight-zone.claimed {
            fill: rgba(46, 204, 113, 0.5);
            stroke: #2ecc71;
            stroke-width: 4;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Actions Section */
        .actions-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .attack-prompt {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #feca57;
        }

        .editable-hits-box:hover {
            background: rgba(46, 204, 113, 0.35) !important;
            border-color: #27ae60 !important;
        }

        .hit-info {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .hit-badge {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .hit-badge.hit {
            background: #2ecc71;
        }

        .hit-badge.miss {
            background: #e74c3c;
        }

        /* Turn Order Screen */
        #turn-order-screen {
            display: none;
            text-align: center;
        }

        .turn-order-rolls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 30px auto;
        }

        .turn-order-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
        }

        .turn-order-player .roll-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #feca57;
        }

        /* Winner Screen */
        #winner-screen {
            display: none;
            text-align: center;
            padding: 60px 20px;
        }

        .winner-title {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #feca57; }
            50% { text-shadow: 0 0 40px #feca57, 0 0 60px #ff6b6b; }
        }

        .winner-name {
            font-size: 2rem;
            margin-bottom: 40px;
        }

        /* Game Log */
        .game-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #2ecc71;
        }

        .log-info {
            color: #48dbfb;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            .game-header {
                margin-bottom: 10px;
            }

            .turn-indicator {
                font-size: 1rem;
                padding: 8px 12px;
            }

            .players-panel {
                gap: 8px;
                margin-bottom: 15px;
            }

            .player-card {
                padding: 10px;
                min-width: 100px;
            }

            .player-avatar {
                width: 40px;
                height: 40px;
            }

            .player-hp {
                font-size: 1.1rem;
            }

            .player-turn-order {
                font-size: 0.7rem;
            }

            .game-area {
                gap: 15px;
            }

            .dice-section, .targets-section, .actions-section {
                padding: 15px;
                border-radius: 15px;
            }

            .section-title {
                font-size: 1rem;
                margin-bottom: 10px;
            }

            .die {
                width: 55px;
                height: 55px;
                font-size: 1.3rem;
            }

            .dice-container {
                gap: 10px;
                margin-bottom: 10px;
            }

            .roll-btn {
                padding: 10px 30px;
                font-size: 1rem;
            }

            .target-wrapper {
                width: 140px;
            }

            .target-label {
                font-size: 0.75rem;
                margin-bottom: 3px;
            }

            .target-image-container {
                border-width: 6px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .attack-prompt {
                font-size: 1rem;
            }

            .game-log {
                max-height: 100px;
                padding: 10px;
            }

            .log-entry {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 400px) {
            .target-wrapper {
                width: 120px;
            }

            .target-image-container {
                border-width: 5px;
            }

            .die {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }

            .player-card {
                min-width: 80px;
                padding: 8px;
            }

            .player-avatar {
                width: 30px;
                height: 30px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-hp {
                font-size: 0.95rem;
            }
        }

        /* Back to Home link */
        .back-link {
            display: inline-block;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #48dbfb;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Home</a>
        <h1>Dagger & Die</h1>

        <!-- Setup Screen -->
        <div id="setup-screen">
            <h2 class="setup-title">Select Number of Players</h2>
            <div class="player-count-selector">
                <button class="player-count-btn" data-count="2">2</button>
                <button class="player-count-btn" data-count="3">3</button>
                <button class="player-count-btn" data-count="4">4</button>
                <button class="player-count-btn" data-count="5">5</button>
                <button class="player-count-btn" data-count="6">6</button>
            </div>
            <div class="player-setup" id="player-setup"></div>
            <div class="setup-error hidden" id="setup-error" role="alert"></div>
            <button class="btn btn-primary btn-center" id="start-game-btn" style="display:none;">Start Game</button>
        </div>

        <!-- Turn Order Screen -->
        <div id="turn-order-screen">
            <h2 class="setup-title">Rolling for Turn Order</h2>
            <p>Each player rolls a D20 to determine turn order. Highest goes first!</p>
            <div class="turn-order-rolls" id="turn-order-rolls"></div>
            <button class="btn btn-primary" id="roll-turn-order-btn">Roll for Turn Order</button>
            <button class="btn btn-primary hidden" id="begin-game-btn">Begin Game!</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="game-header">
                <div class="turn-indicator">
                    Turn: <span class="current-player-name" id="current-player-name">-</span>
                </div>
                <div class="game-header-actions">
                    <button type="button" class="settings-gear-btn" id="settings-gear-btn" aria-label="Game settings">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary" id="new-game-btn">New Game</button>
                </div>
            </div>

            <div class="players-panel" id="players-panel"></div>

            <div class="game-area">
                <div class="dice-section">
                    <h3 class="section-title">Your Dice</h3>
                    <div class="dice-container">
                        <div class="die" id="die1">-</div>
                        <div class="die" id="die2">-</div>
                        <div class="die" id="die3">-</div>
                    </div>
                    <button class="btn btn-primary roll-btn" id="roll-dice-btn">Roll Dice</button>
                    <div class="dice-results" id="dice-results"></div>
                </div>

                <div class="targets-section">
                    <h3 class="section-title">Target Boards</h3>
                    <div class="targets-container">
                        <div class="target-wrapper">
                            <div class="target-label">Odd Numbers (1-19)</div>
                            <div class="target-image-container">
                                <img src="assets/ODD.svg" alt="Odd Target" class="target-image">
                                <svg class="target-overlay" id="odd-overlay" viewBox="49 -377 300 341" preserveAspectRatio="xMidYMid meet">
                                    <polygon class="highlight-zone" data-number="1" points="126,-215 166,-215 146,-165"/>
                                    <polygon class="highlight-zone" data-number="3" points="45,-265 85,-265 65,-225"/>
                                    <polygon class="highlight-zone" data-number="5" points="129,-105 169,-105 149,-56"/>
                                    <polygon class="highlight-zone" data-number="7" points="216,-268 256,-268 236,-228"/>
                                    <polygon class="highlight-zone" data-number="9" points="266,-180 306,-180 286,-140"/>
                                    <polygon class="highlight-zone" data-number="11" points="169,-383 209,-383 189,-343"/>
                                    <polygon class="highlight-zone" data-number="13" points="48,-141 88,-141 68,-101"/>
                                    <polygon class="highlight-zone" data-number="15" points="30,-185 70,-185 50,-145"/>
                                    <polygon class="highlight-zone" data-number="17" points="126,-382 166,-382 146,-342"/>
                                    <polygon class="highlight-zone" data-number="19" points="247,-139 287,-139 267,-99"/>
                                </svg>
                            </div>
                        </div>
                        <div class="target-wrapper">
                            <div class="target-label">Even Numbers (2-20)</div>
                            <div class="target-image-container">
                                <img src="assets/EVEN.svg" alt="Even Target" class="target-image">
                                <svg class="target-overlay" id="even-overlay" viewBox="49 -377 300 341" preserveAspectRatio="xMidYMid meet">
                                    <polygon class="highlight-zone" data-number="2" points="126,-215 166,-215 146,-165"/>
                                    <polygon class="highlight-zone" data-number="4" points="45,-265 85,-265 65,-225"/>
                                    <polygon class="highlight-zone" data-number="6" points="216,-268 256,-268 236,-228"/>
                                    <polygon class="highlight-zone" data-number="8" points="129,-105 169,-105 149,-56"/>
                                    <polygon class="highlight-zone" data-number="10" points="126,-382 166,-382 146,-342"/>
                                    <polygon class="highlight-zone" data-number="12" points="30,-185 70,-185 50,-145"/>
                                    <polygon class="highlight-zone" data-number="14" points="266,-180 306,-180 286,-140"/>
                                    <polygon class="highlight-zone" data-number="16" points="247,-139 287,-139 267,-99"/>
                                    <polygon class="highlight-zone" data-number="18" points="48,-141 88,-141 68,-101"/>
                                    <polygon class="highlight-zone" data-number="20" points="169,-383 209,-383 189,-343"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="actions-section" id="actions-section">
                <h3 class="section-title">Actions</h3>
                <div class="hit-info" id="hit-info"></div>
                <div class="attack-prompt hidden" id="attack-prompt">Select a player to attack!</div>
                <div class="action-buttons">
                    <button class="btn btn-danger hidden" id="dropped-knife-btn">Dropped Knife (-1 HP)</button>
                    <button class="btn btn-primary hidden" id="end-turn-btn">End Turn</button>
                </div>
            </div>

            <div class="game-log">
                <h4>Game Log</h4>
                <div id="game-log-entries"></div>
            </div>
        </div>

        <!-- Winner Screen -->
        <div id="winner-screen">
            <h2 class="winner-title">Victory!</h2>
            <div class="winner-name" id="winner-name"></div>
            <div style="display: flex; justify-content: center; margin-bottom: 32px;">
                <button class="btn btn-secondary" id="export-report-btn">Export Game Report</button>
            </div>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-primary" id="play-again-btn">Play Again</button>
                <button class="btn btn-primary" id="finished-btn">Finished</button>
            </div>
        </div>
    </div>

    <!-- Game settings modal -->
    <div class="settings-modal-overlay" id="settings-modal" role="dialog" aria-label="Game settings">
        <div class="settings-modal">
            <h3>Game Settings</h3>
            <p id="settings-readonly-hint" class="setting-hint setting-readonly-hint" style="display: none;">Settings are locked after the first damage is dealt. Start a new game to change them.</p>
            <div class="option-row">
                <input type="checkbox" id="use-custom-hp-cb" aria-describedby="custom-hp-hint">
                <label for="use-custom-hp-cb">Use custom HP</label>
            </div>
            <div class="custom-hp-row">
                <label for="custom-hp-input">Default HP per player (20–999)</label>
                <input type="number" id="custom-hp-input" min="20" max="999" placeholder="e.g. 50" disabled>
            </div>
            <p id="custom-hp-hint" class="setting-hint">When unchecked, automatic values are used (2 players: 50, 3–4: 40, 5–6: 60).</p>
            <button type="button" class="btn btn-primary" id="settings-modal-done">Done</button>
        </div>
    </div>

    <!-- Player stats modal -->
    <div class="player-stats-modal-overlay" id="player-stats-modal" role="dialog" aria-label="Player stats">
        <div class="player-stats-modal">
            <h3 id="player-stats-title">Player</h3>
            <div class="player-stats-header">
                <div id="player-stats-avatar" class="player-stats-avatar"></div>
                <div class="player-stats-meta">
                    <div id="player-stats-hp" class="player-stats-row"></div>
                    <div id="player-stats-turn-order" class="player-stats-row"></div>
                    <div id="player-stats-status" class="player-stats-row"></div>
                    <div id="player-stats-hit-drop" class="player-stats-row"></div>
                    <div id="player-stats-rolled-claimed" class="player-stats-row"></div>
                </div>
            </div>
            <div class="player-stats-section">
                <h4>Drops</h4>
                <p id="player-stats-drops-hint" class="setting-hint"></p>
                <button type="button" class="btn btn-secondary" id="player-stats-undo-drop-btn" style="display: none;">Undo last drop</button>
            </div>
            <button type="button" class="btn btn-primary" id="player-stats-close-btn">Close</button>
        </div>
    </div>

    <!-- Custom circular color picker modal (must be in DOM before script runs) -->
    <div class="color-picker-modal-overlay" id="color-picker-modal" role="dialog" aria-label="Pick color">
        <div class="color-picker-modal">
            <h3>Pick your color</h3>
            <div class="color-wheel-container" id="color-wheel-container">
                <div class="color-wheel-hue" id="color-wheel-hue"></div>
                <div class="color-wheel-inner"></div>
                <div class="color-wheel-sat" id="color-wheel-sat"></div>
                <div class="color-wheel-hue-handle" id="color-hue-handle"></div>
                <div class="color-wheel-sat-handle" id="color-sat-handle"></div>
            </div>
            <div class="color-picker-lightness">
                <label for="color-lightness-input">Brightness</label>
                <input type="range" id="color-lightness-input" min="0" max="100" value="50">
            </div>
            <button type="button" class="color-picker-done" id="color-picker-done">Done</button>
        </div>
    </div>

    <script>
        // Game State
        const state = {
            players: [],
            currentPlayerIndex: 0,
            phase: 'setup',
            currentRoll: [],
            hits: [],
            totalDamage: 0,
            hasRolled: false,
            hasAttacked: false,
            damageClaimedPhase: false,
            currentHitIndex: 0,
            attackLog: [],
            gameLog: [],
            autoDealDamage: false,
            hasScoreBeenEntered: false,
            lastDroppedKnifeLogIndex: undefined,
            dropsThisTurn: 0,
            dropsThisTurnLogIndices: [],
            damageDealtThisTurn: false
        };

        const COLORS = [
            { name: 'Red', hex: '#e74c3c' },
            { name: 'Blue', hex: '#3498db' },
            { name: 'Green', hex: '#2ecc71' },
            { name: 'Purple', hex: '#9b59b6' },
            { name: 'Orange', hex: '#e67e22' },
            { name: 'Pink', hex: '#fd79a8' },
            { name: 'Cyan', hex: '#00cec9' },
            { name: 'Yellow', hex: '#f1c40f' }
        ];

        function hexToHSL(hex) {
            const n = parseInt(hex.slice(1), 16);
            const r = (n >> 16) / 255, g = ((n >> 8) & 0xff) / 255, b = (n & 0xff) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                else if (max === g) h = ((b - r) / d + 2) / 6;
                else h = ((r - g) / d + 4) / 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            s /= 100; l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / 30) % 12;
                return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
            };
            const r = Math.round(f(0) * 255), g = Math.round(f(8) * 255), b = Math.round(f(4) * 255);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const turnOrderScreen = document.getElementById('turn-order-screen');
        const gameScreen = document.getElementById('game-screen');
        const winnerScreen = document.getElementById('winner-screen');
        const playerSetup = document.getElementById('player-setup');
        const startGameBtn = document.getElementById('start-game-btn');
        const playersPanel = document.getElementById('players-panel');
        const currentPlayerNameEl = document.getElementById('current-player-name');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const diceResults = document.getElementById('dice-results');
        const hitInfo = document.getElementById('hit-info');
        const attackPrompt = document.getElementById('attack-prompt');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const droppedKnifeBtn = document.getElementById('dropped-knife-btn');
        const gameLogEntries = document.getElementById('game-log-entries');

        // Custom circular color picker
        const colorPickerModal = document.getElementById('color-picker-modal');
        const colorWheelContainer = document.getElementById('color-wheel-container');
        const colorWheelSat = document.getElementById('color-wheel-sat');
        const colorHueHandle = document.getElementById('color-hue-handle');
        const colorSatHandle = document.getElementById('color-sat-handle');
        const colorLightnessInput = document.getElementById('color-lightness-input');
        const colorPickerDone = document.getElementById('color-picker-done');

        const settingsModal = document.getElementById('settings-modal');
        const settingsGearBtn = document.getElementById('settings-gear-btn');
        const useCustomHpCb = document.getElementById('use-custom-hp-cb');
        const customHpInput = document.getElementById('custom-hp-input');
        const settingsModalDone = document.getElementById('settings-modal-done');

        useCustomHpCb.addEventListener('change', () => {
            customHpInput.disabled = !useCustomHpCb.checked;
        });

        const settingsReadOnlyHint = document.getElementById('settings-readonly-hint');

        settingsGearBtn.addEventListener('click', () => {
            const readOnly = state.hasScoreBeenEntered;
            const useCustom = localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true';
            useCustomHpCb.checked = useCustom;
            if (useCustom) {
                const savedHp = localStorage.getItem(CUSTOM_HP_KEY);
                customHpInput.value = savedHp !== null && savedHp !== '' ? savedHp : '';
            } else {
                customHpInput.value = state.players.length > 0 ? String(getDefaultHp(state.players.length)) : '';
            }
            useCustomHpCb.disabled = readOnly;
            customHpInput.disabled = readOnly || !useCustomHpCb.checked;
            if (settingsReadOnlyHint) settingsReadOnlyHint.style.display = readOnly ? 'block' : 'none';
            settingsModalDone.textContent = readOnly ? 'Close' : 'Done';
            settingsModal.classList.add('open');
        });

        settingsModalDone.addEventListener('click', () => {
            if (state.hasScoreBeenEntered) {
                settingsModal.classList.remove('open');
                return;
            }
            if (useCustomHpCb.checked) {
                const val = customHpInput.value.trim();
                const n = val === '' ? NaN : parseInt(val, 10);
                if (isNaN(n) || n < 20 || n > 999) {
                    alert('Please enter a value between 20 and 999.');
                    return;
                }
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'true');
                localStorage.setItem(CUSTOM_HP_KEY, String(n));
                if (state.players.length > 0) {
                    state.players.forEach(p => {
                        p.hp = n;
                        p.maxHp = n;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            } else {
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'false');
                if (state.players.length > 0) {
                    const defaultHp = getDefaultHp(state.players.length);
                    state.players.forEach(p => {
                        p.hp = defaultHp;
                        p.maxHp = defaultHp;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            }
            settingsModal.classList.remove('open');
        });

        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) settingsModal.classList.remove('open');
        });

        let colorPickerState = { wrap: null, input: null, swatch: null, h: 0, s: 100, l: 50 };
        const WHEEL_SIZE = 260;
        const WHEEL_PADDING = 12;
        const WHEEL_INNER_R = (WHEEL_SIZE / 2) - WHEEL_PADDING;

        function openColorPicker(wrap) {
            const input = wrap.querySelector('.player-color-input');
            const swatch = wrap.querySelector('.color-swatch');
            const hex = input.value || '#e74c3c';
            const hsl = hexToHSL(hex);
            colorPickerState = { wrap, input, swatch, h: hsl.h, s: hsl.s, l: hsl.l };
            colorLightnessInput.value = Math.round(hsl.l);
            colorPickerModal.classList.add('open');
            updatePickerGradient();
            updatePickerHandles();
        }

        function updatePickerGradient() {
            const { h } = colorPickerState;
            const gray = hslToHex(h, 0, 50);
            const hueColor = hslToHex(h, 100, 50);
            colorWheelSat.style.setProperty('--picker-gray', gray);
            colorWheelSat.style.setProperty('--picker-hue-color', hueColor);
        }

        function updatePickerHandles() {
            const { h, s } = colorPickerState;
            const rad = (h - 90) * Math.PI / 180;
            const hueR = 48;
            colorHueHandle.style.left = (50 + hueR * Math.cos(rad)) + '%';
            colorHueHandle.style.top = (50 + hueR * Math.sin(rad)) + '%';
            const satR = (s / 100) * 42;
            colorSatHandle.style.left = (50 + satR) + '%';
            colorSatHandle.style.top = '50%';
        }

        function commitPickerColor() {
            const { input, swatch, h, s, l } = colorPickerState;
            const hex = hslToHex(h, s, l);
            if (input) input.value = hex;
            if (swatch) swatch.style.background = hex;
        }

        function getWheelXY(e) {
            const rect = colorWheelContainer.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const x = (e.clientX ?? e.touches?.[0]?.clientX) - cx;
            const y = (e.clientY ?? e.touches?.[0]?.clientY) - cy;
            const dist = Math.sqrt(x * x + y * y);
            const angle = Math.atan2(y, x);
            return { x, y, dist, angle };
        }

        function onWheelPointerDown(e) {
            e.preventDefault();
            const { dist, angle } = getWheelXY(e);
            const isHue = dist > WHEEL_INNER_R;
            let move = (e2) => {
                const xy = getWheelXY(e2);
                if (isHue) {
                    colorPickerState.h = ((xy.angle * 180 / Math.PI + 90) + 360) % 360;
                    updatePickerGradient();
                } else {
                    colorPickerState.s = Math.min(100, Math.max(0, (xy.dist / WHEEL_INNER_R) * 100));
                    updatePickerHandles();
                }
                updatePickerHandles();
                commitPickerColor();
            };
            const up = () => {
                document.removeEventListener('pointermove', move);
                document.removeEventListener('pointerup', up);
                document.removeEventListener('touchmove', move, { passive: false });
                document.removeEventListener('touchend', up);
            };
            if (isHue) {
                colorPickerState.h = ((angle * 180 / Math.PI + 90) + 360) % 360;
                updatePickerGradient();
            } else {
                colorPickerState.s = Math.min(100, Math.max(0, (dist / WHEEL_INNER_R) * 100));
            }
            updatePickerHandles();
            commitPickerColor();
            document.addEventListener('pointermove', move);
            document.addEventListener('pointerup', up);
            document.addEventListener('touchmove', move, { passive: false });
            document.addEventListener('touchend', up);
        }

        document.addEventListener('click', (e) => {
            const wrap = e.target.closest('.color-picker-wrap');
            if (wrap) {
                e.preventDefault();
                openColorPicker(wrap);
            }
        });

        colorWheelContainer.addEventListener('pointerdown', onWheelPointerDown);
        colorWheelContainer.addEventListener('touchstart', onWheelPointerDown, { passive: false });

        colorLightnessInput.addEventListener('input', () => {
            colorPickerState.l = parseInt(colorLightnessInput.value, 10);
            commitPickerColor();
        });

        colorPickerDone.addEventListener('click', () => {
            colorPickerModal.classList.remove('open');
        });

        colorPickerModal.addEventListener('click', (e) => {
            if (e.target === colorPickerModal) colorPickerModal.classList.remove('open');
        });

        // Setup: Player count selection
        document.querySelectorAll('.player-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const count = parseInt(btn.dataset.count);
                setupPlayerInputs(count);
            });
        });

        function setupPlayerInputs(count) {
            playerSetup.innerHTML = '';
            playerSetup.classList.add('visible');
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }

            const usedColors = new Set();

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                const defaultHex = COLORS[i % COLORS.length].hex;
                div.innerHTML = `
                    <span>P${i + 1}</span>
                    <input type="text" placeholder="Player ${i + 1} Name" data-player="${i}" maxlength="30">
                    <div class="color-picker" data-player="${i}">
                        <div class="color-picker-wrap" data-player="${i}" title="Pick your color">
                            <span class="color-swatch" style="background: ${defaultHex};"></span>
                            <input type="color" class="player-color-input" data-player="${i}" value="${defaultHex}" aria-hidden="true">
                        </div>
                    </div>
                `;
                playerSetup.appendChild(div);
            }

            playerSetup.querySelectorAll('input[type="text"]').forEach(input => {
                input.addEventListener('input', checkDuplicateNames);
            });

            startGameBtn.style.display = 'block';
        }

        function checkDuplicateNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error-duplicate'));

            const names = [];
            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const nameCount = {};
            names.forEach(n => {
                const key = n.toLowerCase();
                nameCount[key] = (nameCount[key] || 0) + 1;
            });

            const duplicates = new Set(Object.entries(nameCount).filter(([, c]) => c > 1).map(([k]) => k));

            if (duplicates.size > 0) {
                inputs.forEach((input, idx) => {
                    if (duplicates.has(names[idx].toLowerCase())) {
                        input.closest('.player-input').classList.add('error-duplicate');
                    }
                });
                errorEl.textContent = `Names must be unique: ${[...duplicates].join(', ')} appears more than once.`;
                errorEl.classList.remove('hidden');
            } else {
                errorEl.classList.add('hidden');
                errorEl.textContent = '';
            }
        }

        const CUSTOM_HP_KEY = 'daggerdie_customHp';
        const USE_CUSTOM_HP_KEY = 'daggerdie_useCustomHp';

        function getDefaultHp(playerCount) {
            if (localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true') {
                const custom = localStorage.getItem(CUSTOM_HP_KEY);
                if (custom !== null && custom !== '') {
                    const n = parseInt(custom, 10);
                    if (!isNaN(n) && n >= 20 && n <= 999) return n;
                }
            }
            if (playerCount <= 2) return 50;
            if (playerCount <= 4) return 40;
            return 60; // 5-6 players
        }

        const NAME_MIN_LEN = 2;
        const NAME_MAX_LEN = 30;

        function validatePlayerNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');
            const names = [];
            let firstInvalidInput = null;

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error', 'error-duplicate'));

            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const duplicateNames = new Set(
                names.filter((n, i) => names.findIndex(x => x.toLowerCase() === n.toLowerCase()) !== i)
                    .map(n => n.toLowerCase())
            );

            for (let idx = 0; idx < inputs.length; idx++) {
                const input = inputs[idx];
                const raw = input.value.trim();
                const name = raw || `Player ${idx + 1}`;
                const playerInputEl = input.closest('.player-input');

                if (raw) {
                    if (raw.length < NAME_MIN_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    } else if (raw.length > NAME_MAX_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    }
                }

                if (duplicateNames.has(name.toLowerCase())) {
                    if (!firstInvalidInput) firstInvalidInput = input;
                    playerInputEl.classList.add('error', 'error-duplicate');
                }
            }

            const errors = [];
            inputs.forEach((input, idx) => {
                const el = input.closest('.player-input');
                if (!el.classList.contains('error')) return;
                const raw = input.value.trim();
                if (raw && raw.length < NAME_MIN_LEN) {
                    errors.push(`"${raw || input.value}" is too short (min ${NAME_MIN_LEN} characters).`);
                } else if (raw && raw.length > NAME_MAX_LEN) {
                    errors.push(`"${input.value}" is too long (max ${NAME_MAX_LEN} characters).`);
                }
            });
            if (duplicateNames.size > 0) {
                errors.push(`Names must be unique: ${[...duplicateNames].join(', ')} appears more than once.`);
            }

            if (errors.length > 0) {
                errorEl.textContent = errors.join(' ');
                errorEl.classList.remove('hidden');
                if (firstInvalidInput) firstInvalidInput.focus();
                return false;
            }
            errorEl.classList.add('hidden');
            errorEl.textContent = '';
            return true;
        }

        startGameBtn.addEventListener('click', () => {
            if (!validatePlayerNames()) return;

            const nameInputs = playerSetup.querySelectorAll('input[type="text"]');
            state.players = [];
            const defaultHp = getDefaultHp(nameInputs.length);

            nameInputs.forEach((input, idx) => {
                const colorPicker = playerSetup.querySelector(`.color-picker[data-player="${idx}"]`);
                const colorInput = colorPicker.querySelector('input[type="color"]');
                const hex = colorInput ? colorInput.value : COLORS[idx % COLORS.length].hex;
                const name = input.value.trim() || `Player ${idx + 1}`;

                state.players.push({
                    id: idx,
                    name,
                    color: { name: 'Custom', hex },
                    hp: defaultHp,
                    maxHp: defaultHp,
                    turnOrderRoll: 0,
                    eliminated: false,
                    totalRolled: 0,
                    totalClaimed: 0
                });
            });

            state.autoDealDamage = localStorage.getItem('daggerdie_autoDealDamage') === 'true';

            showTurnOrderScreen();

            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                setTimeout(() => {
                    document.getElementById('roll-turn-order-btn')?.click();
                }, 400);
            }
        });

        function showTurnOrderScreen() {
            setupScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                rollBtn.classList.add('hidden');
            }

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');
        }

        document.getElementById('roll-turn-order-btn').addEventListener('click', async () => {
            const btn = document.getElementById('roll-turn-order-btn');
            btn.disabled = true;

            for (let player of state.players) {
                const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                const rollValue = playerDiv.querySelector('.roll-value');

                for (let i = 0; i < 10; i++) {
                    rollValue.textContent = rollD20();
                    await sleep(50);
                }

                player.turnOrderRoll = rollD20();
                rollValue.textContent = player.turnOrderRoll;
                await sleep(300);
            }

            state.players.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

            const rollsDiv = document.getElementById('turn-order-rolls');
            const tieMessage = document.createElement('p');
            tieMessage.id = 'tie-reroll-message';
            tieMessage.style.cssText = 'color: #feca57; margin: 15px 0; font-weight: bold;';
            tieMessage.style.display = 'none';
            if (!document.getElementById('tie-reroll-message')) {
                rollsDiv.parentNode.insertBefore(tieMessage, rollsDiv.nextSibling);
            }

            function updateTurnOrderDisplay() {
                rollsDiv.innerHTML = state.players.map((p, idx) => `
                    <div class="turn-order-player" data-player="${p.id}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                            <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                            <span>${p.name}</span>
                        </div>
                        <span class="roll-value">${p.turnOrderRoll}</span>
                    </div>
                `).join('');
            }

            // Find tie groups (consecutive players with same roll) - each resolves independently
            const tieGroupsWithIndex = [];
            for (let i = 0; i < state.players.length; i++) {
                const startIdx = i;
                const group = [state.players[i]];
                while (i + 1 < state.players.length && state.players[i + 1].turnOrderRoll === state.players[i].turnOrderRoll) {
                    group.push(state.players[++i]);
                }
                if (group.length > 1) {
                    tieGroupsWithIndex.push({ startIdx, players: group });
                }
            }

            // Resolve each tie group in isolation - only the tied players reroll for their slots
            for (const { startIdx, players: tiedPlayers } of tieGroupsWithIndex) {
                let hasTieInGroup;
                do {
                    hasTieInGroup = false;
                    tieMessage.textContent = `Tie between ${tiedPlayers.map(p => p.name).join(', ')}! Rerolling for slot...`;
                    tieMessage.style.display = 'block';
                    await sleep(500);

                    for (let player of tiedPlayers) {
                        const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (playerDiv) {
                            const rollValue = playerDiv.querySelector('.roll-value');
                            for (let i = 0; i < 8; i++) {
                                rollValue.textContent = rollD20();
                                await sleep(40);
                            }
                        }
                        player.turnOrderRoll = rollD20();
                        const div = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (div) div.querySelector('.roll-value').textContent = player.turnOrderRoll;
                        await sleep(200);
                    }

                    tiedPlayers.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

                    for (let j = 0; j < tiedPlayers.length - 1; j++) {
                        if (tiedPlayers[j].turnOrderRoll === tiedPlayers[j + 1].turnOrderRoll) {
                            hasTieInGroup = true;
                            break;
                        }
                    }

                    for (let j = 0; j < tiedPlayers.length; j++) {
                        state.players[startIdx + j] = tiedPlayers[j];
                    }
                    updateTurnOrderDisplay();
                    tieMessage.style.display = 'none';
                    await sleep(300);
                } while (hasTieInGroup);
            }

            tieMessage.style.display = 'none';
            await sleep(500);
            rollsDiv.innerHTML = state.players.map((p, idx) => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">${p.turnOrderRoll}</span>
                </div>
            `).join('');

            btn.classList.add('hidden');
            const beginBtn = document.getElementById('begin-game-btn');
            beginBtn.classList.remove('hidden');
            if (localStorage.getItem('daggerdie_autoBeginGame') === 'true') {
                beginBtn.classList.add('hidden');
                setTimeout(() => beginBtn.click(), 500);
            }
        });

        document.getElementById('begin-game-btn').addEventListener('click', () => {
            turnOrderScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            state.phase = 'playing';
            state.currentPlayerIndex = 0;
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;
            updateGameUI();
        });

        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCurrentPlayer() {
            return state.players[state.currentPlayerIndex];
        }

        function getAlivePlayers() {
            return state.players.filter(p => !p.eliminated);
        }

        function updateGameUI() {
            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            clearHighlights();
            resetDice();
            diceResults.innerHTML = '';
            hitInfo.innerHTML = '';
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.add('hidden');
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.hits = [];
            state.totalDamage = 0;
            state.currentHitIndex = 0;
            state.attackLog = [];
            rollDiceBtn.disabled = false;
            disableTargetSelection();
            droppedKnifeBtn.classList.add('hidden');

            if (localStorage.getItem('daggerdie_autoRollDice') === 'true') {
                rollDiceBtn.classList.add('hidden');
                setTimeout(() => rollDiceBtn.click(), 300);
            } else {
                rollDiceBtn.classList.remove('hidden');
            }
        }

        function updatePlayersPanel() {
            const currentPlayer = getCurrentPlayer();
            playersPanel.innerHTML = state.players.map(p => `
                <div class="player-card ${p.id === currentPlayer.id ? 'current' : ''} ${p.eliminated ? 'eliminated' : ''}"
                     data-player="${p.id}">
                    <button type="button" class="player-card-stats-btn" data-player="${p.id}" aria-label="Stats and drops">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    </button>
                    <div class="player-avatar" style="background: ${p.color.hex};"></div>
                    <div class="player-name">${p.name}</div>
                    <div class="player-hp">${p.hp} HP</div>
                    <div class="hp-bar">
                        <div class="hp-fill" style="width: ${(p.hp / p.maxHp) * 100}%; background: ${p.color.hex};"></div>
                    </div>
                    <div class="player-turn-order">Turn Order: #${state.players.indexOf(p) + 1}</div>
                </div>
            `).join('');
        }

        function updateCurrentPlayerDisplay() {
            const current = getCurrentPlayer();
            currentPlayerNameEl.textContent = current.name;
            currentPlayerNameEl.style.color = current.color.hex;
        }

        rollDiceBtn.addEventListener('click', async () => {
            if (state.hasRolled) return;

            rollDiceBtn.disabled = true;
            const dice = [
                document.getElementById('die1'),
                document.getElementById('die2'),
                document.getElementById('die3')
            ];

            dice.forEach(die => {
                die.classList.add('rolling');
                die.classList.remove('odd', 'even');
            });

            for (let i = 0; i < 15; i++) {
                dice.forEach(die => {
                    die.textContent = rollD20();
                });
                await sleep(50);
            }

            state.currentRoll = [rollD20(), rollD20(), rollD20()];
            state.hits = [];
            state.totalDamage = 0;
            state.damageClaimedPhase = false;

            dice.forEach((die, idx) => {
                die.classList.remove('rolling');
                const value = state.currentRoll[idx];
                die.textContent = value;
                die.classList.add(value % 2 === 0 ? 'even' : 'odd');
            });

            highlightTargets(state.currentRoll);
            displayRollResults();

            state.hasRolled = true;
            const current = getCurrentPlayer();
            current.totalRolled = (current.totalRolled || 0) + state.currentRoll.reduce((s, v) => s + v, 0);
            showHitRecorder();
            droppedKnifeBtn.classList.remove('hidden');
        });

        function highlightTargets(rolls) {
            clearHighlights();
            rolls.forEach(roll => {
                const zone = document.querySelector(`.highlight-zone[data-number="${roll}"]`);
                if (zone) {
                    zone.classList.add('active');
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                zone.classList.remove('active');
            });
        }

        document.addEventListener('click', (e) => {
            const zone = e.target.closest('.highlight-zone');
            if (!zone) return;
            const overlay = zone.closest('.target-overlay');
            if (!overlay || !overlay.classList.contains('clickable')) return;
            const number = parseInt(zone.getAttribute('data-number'));
            if (!state.currentRoll.includes(number)) return;

            const rollIndices = state.currentRoll.map((r, i) => r === number ? i : -1).filter(i => i >= 0);
            const hitIndicesForNumber = new Set(state.hits.filter(h => h.roll === number).map(h => h.idx));
            const firstUnclaimed = rollIndices.find(idx => !hitIndicesForNumber.has(idx));
            if (firstUnclaimed !== undefined) {
                const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                if (state.hits.length >= slotsLeft) return;
                state.hits.push({ roll: number, idx: firstUnclaimed });
            } else {
                const toRemove = state.hits.find(h => h.roll === number);
                if (toRemove) state.hits = state.hits.filter(h => h !== toRemove);
            }
            syncHitRecorderUI();
        });

        function displayRollResults() {
            diceResults.innerHTML = `
                <p>Rolled: <strong>${state.currentRoll.join(', ')}</strong></p>
                <p>Odd targets: <span style="color: #ff6b6b;">${state.currentRoll.filter(r => r % 2 === 1).join(', ') || 'None'}</span></p>
                <p>Even targets: <span style="color: #48dbfb;">${state.currentRoll.filter(r => r % 2 === 0).join(', ') || 'None'}</span></p>
            `;
        }

        const MAX_SCORES_PER_TURN = 3;

        function syncHitRecorderUI() {
            const hitIdxSet = new Set(state.hits.map(h => h.idx));
            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                const idx = parseInt(btn.dataset.idx);
                if (hitIdxSet.has(idx)) {
                    btn.classList.add('hit');
                    btn.style.background = '#2ecc71';
                } else {
                    btn.classList.remove('hit');
                    btn.style.background = '';
                }
            });
            const totalDamageEl = document.getElementById('total-damage-display');
            if (totalDamageEl) totalDamageEl.textContent = state.hits.reduce((sum, h) => sum + h.roll, 0);
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                const num = parseInt(zone.getAttribute('data-number'));
                const claimedForNumber = state.hits.some(h => h.roll === num);
                zone.classList.toggle('claimed', claimedForNumber);
            });
        }

        function showHitRecorder(initialHits) {
            const currentPlayer = getCurrentPlayer();
            droppedKnifeBtn.classList.remove('hidden');

            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice() : [];

            const maxDiceScores = Math.max(0, MAX_SCORES_PER_TURN - state.dropsThisTurn);
            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice(0, maxDiceScores) : [];

            attackPrompt.classList.remove('hidden');
            attackPrompt.innerHTML = `<strong>Step 1:</strong> Throw your knives! Tap the target numbers you HIT, or use the buttons below (max 3 scores per turn).`;

            const hitIdxSet = new Set(state.hits.map(h => h.idx));

            hitInfo.innerHTML = `
                <div style="width: 100%; text-align: center; margin-bottom: 15px;">
                    <p style="font-size: 1.1rem;">Tap the <strong>highlighted targets</strong> or buttons below to claim hits (max 3 per turn):</p>
                </div>
                <div class="hit-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    ${state.currentRoll.map((roll, idx) => `
                        <button class="btn hit-toggle ${hitIdxSet.has(idx) ? 'hit' : ''}" data-roll="${roll}" data-idx="${idx}" style="min-width: 70px; font-size: 1.3rem; ${hitIdxSet.has(idx) ? 'background: #2ecc71;' : ''}">
                            ${roll}
                        </button>
                    `).join('')}
                </div>
                <div class="scores-counter" style="margin-top: 12px; font-size: 0.9rem; opacity: 0.9;">Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}</div>
                <div style="margin-top: 20px;">
                    <p style="font-size: 1.3rem;">Damage Claimed: <strong id="total-damage-display" style="color: #feca57; font-size: 1.5rem;">${state.hits.reduce((sum, h) => sum + h.roll, 0)}</strong></p>
                    <button class="btn btn-primary" id="confirm-hits-btn" style="margin-top: 15px;">Confirm</button>
                </div>
            `;

            document.getElementById('odd-overlay').classList.add('clickable');
            document.getElementById('even-overlay').classList.add('clickable');
            syncHitRecorderUI();

            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    const roll = parseInt(btn.dataset.roll);
                    const idx = parseInt(btn.dataset.idx);

                    if (btn.classList.contains('hit')) {
                        state.hits = state.hits.filter(h => h.idx !== idx);
                    } else {
                        const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                        if (state.hits.length >= slotsLeft) return;
                        state.hits.push({ roll, idx });
                    }
                    syncHitRecorderUI();
                });
            });

            document.getElementById('confirm-hits-btn').addEventListener('click', () => {
                document.getElementById('odd-overlay').classList.remove('clickable');
                document.getElementById('even-overlay').classList.remove('clickable');
                state.totalDamage = state.hits.reduce((sum, h) => sum + h.roll, 0);

                if (state.totalDamage > 0) {
                    addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => h.roll).join(', ')})`, 'info');
                    showTargetSelection();
                } else {
                    if (confirm('No hits recorded. Did you miss all targets?')) {
                        addLogEntry(`${currentPlayer.name} missed all targets!`, 'info');
                        finishTurnNoAttack();
                    }
                }
            });
        }

        function showTargetSelection() {
            droppedKnifeBtn.classList.add('hidden');
            state.damageDealtThisTurn = true;
            state.damageClaimedPhase = true;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.attackAssignments = [];

            if (state.autoDealDamage) {
                autoDealDamageAndFinish();
                return;
            }
            showNextHitToAssign();
        }

        function autoDealDamageAndFinish() {
            const currentPlayer = getCurrentPlayer();
            for (let i = 0; i < state.hits.length; i++) {
                const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
                if (aliveOpponents.length === 0) break;
                const currentHit = state.hits[i];
                const targetPlayer = aliveOpponents[Math.floor(Math.random() * aliveOpponents.length)];
                state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHit.roll });
                targetPlayer.hp = Math.max(0, targetPlayer.hp - currentHit.roll);
                state.hasScoreBeenEntered = true;
                currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHit.roll;
                addLogEntry(`${currentPlayer.name} dealt ${currentHit.roll} damage to ${targetPlayer.name}!`, 'damage');
                state.attackLog.push(`${currentHit.roll} → ${targetPlayer.name}`);
                if (targetPlayer.hp <= 0) {
                    targetPlayer.eliminated = true;
                    addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
                }
                updatePlayersPanel();
                checkWinCondition();
            }
            finishAttackPhase();
        }

        function showNextHitToAssign() {
            const currentPlayer = getCurrentPlayer();

            if (state.currentHitIndex >= state.hits.length) {
                finishAttackPhase();
                return;
            }

            const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
            if (aliveOpponents.length === 0) {
                finishAttackPhase();
                return;
            }

            const currentHit = state.hits[state.currentHitIndex];
            const remainingHits = state.hits.slice(state.currentHitIndex);

            attackPrompt.innerHTML = `<strong>Step 2:</strong> Assign hit <span style="color: #feca57; font-size: 1.3rem;">${currentHit.roll}</span> damage - Click an opponent to attack!`;

            hitInfo.innerHTML = `
                <div class="editable-hits-box" id="editable-hits-box" style="background: rgba(46, 204, 113, 0.2); padding: 10px; border-radius: 10px; border: 2px solid #2ecc71; margin-bottom: 10px; cursor: pointer; transition: background 0.2s, border-color 0.2s;" title="Tap to edit hits">
                    <p style="margin-bottom: 5px; font-size: 0.9rem;">Hits to assign <span style="font-size: 0.8rem; opacity: 0.8;">(tap to edit)</span>:</p>
                    <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        ${remainingHits.map((h, idx) => `
                            <span style="
                                padding: 8px 15px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 1.2rem;
                                background: ${idx === 0 ? '#feca57' : 'rgba(255,255,255,0.2)'};
                                color: ${idx === 0 ? '#1a1a2e' : '#fff'};
                                ${idx === 0 ? 'box-shadow: 0 0 10px rgba(254,202,87,0.5);' : ''}
                            ">${h.roll}</span>
                        `).join('')}
                    </div>
                </div>
                ${state.attackLog.length > 0 ? `
                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 5px;">
                        ${state.attackLog.join('<br>')}
                    </div>
                ` : ''}
            `;

            document.getElementById('editable-hits-box').addEventListener('click', () => {
                if (!confirm('Edit hits? You\'ll change which rolls counted as hits and confirm again. Any damage already assigned will be undone.')) return;
                state.attackAssignments.forEach(({ playerId, roll }) => {
                    const p = state.players.find(pl => pl.id === playerId);
                    if (p) {
                        p.hp += roll;
                        if (p.hp > 0) p.eliminated = false;
                    }
                });
                state.damageClaimedPhase = false;
                state.currentHitIndex = 0;
                state.attackLog = [];
                state.attackAssignments = [];
                updatePlayersPanel();
                checkWinCondition();
                showHitRecorder(state.hits);
            });

            enableTargetSelection();
        }

        function enableTargetSelection() {
            const current = getCurrentPlayer();
            const cards = document.querySelectorAll('.player-card');

            cards.forEach(card => {
                const playerId = parseInt(card.dataset.player);
                const player = state.players.find(p => p.id === playerId);

                if (!player.eliminated && player.id !== current.id) {
                    card.classList.add('targetable');
                    card.addEventListener('click', handleAttack);
                }
            });
        }

        function disableTargetSelection() {
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('targetable');
                card.removeEventListener('click', handleAttack);
            });
        }

        function handleAttack(e) {
            const card = e.currentTarget;
            const playerId = parseInt(card.dataset.player);
            const targetPlayer = state.players.find(p => p.id === playerId);
            const currentPlayer = getCurrentPlayer();
            const currentHit = state.hits[state.currentHitIndex];

            disableTargetSelection();

            state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHit.roll });
            targetPlayer.hp = Math.max(0, targetPlayer.hp - currentHit.roll);
            state.hasScoreBeenEntered = true;
            currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHit.roll;
            addLogEntry(`${currentPlayer.name} dealt ${currentHit.roll} damage to ${targetPlayer.name}!`, 'damage');
            state.attackLog.push(`${currentHit.roll} → ${targetPlayer.name}`);

            if (targetPlayer.hp <= 0) {
                targetPlayer.eliminated = true;
                addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
            }

            updatePlayersPanel();
            checkWinCondition();

            state.currentHitIndex++;

            if (state.phase === 'playing') {
                showNextHitToAssign();
            }
        }

        function finishAttackPhase() {
            const totalDealt = state.hits.reduce((sum, h) => sum + h.roll, 0);

            hitInfo.innerHTML = `
                <div style="background: rgba(255, 107, 107, 0.2); padding: 15px; border-radius: 10px; border: 2px solid #ff6b6b;">
                    <p style="font-size: 1.1rem; margin-bottom: 8px;">Attacks Complete!</p>
                    <div style="font-size: 0.9rem;">
                        ${state.attackLog.map(log => `<div>${log}</div>`).join('')}
                    </div>
                    <p style="margin-top: 8px;">Total Damage: <strong style="color: #ff6b6b;">${totalDealt}</strong></p>
                </div>
            `;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        function finishTurnNoAttack() {
            droppedKnifeBtn.classList.add('hidden');
            state.damageDealtThisTurn = true;
            hitInfo.innerHTML = `<span class="hit-badge miss">No damage this turn</span>`;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        droppedKnifeBtn.addEventListener('click', () => {
            const MAX_SCORES_PER_TURN = 3;
            if (state.hits.length + state.dropsThisTurn >= MAX_SCORES_PER_TURN) {
                return;
            }
            const current = getCurrentPlayer();
            current.hp = Math.max(0, current.hp - 1);
            state.hasScoreBeenEntered = true;
            state.dropsThisTurn++;
            addLogEntry(`${current.name} dropped a knife! (-1 HP)`, 'damage');
            state.lastDroppedKnifeLogIndex = state.gameLog.length - 1;
            if (!state.damageDealtThisTurn) state.dropsThisTurnLogIndices.push(state.gameLog.length - 1);
            updatePlayersPanel();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;

            requestAnimationFrame(() => {
                const card = document.querySelector(`.player-card[data-player="${current.id}"]`);
                if (card) {
                    card.classList.add('player-card-dropped');
                    setTimeout(() => card.classList.remove('player-card-dropped'), 600);
                }
            });

            if (current.hp <= 0) {
                current.eliminated = true;
                addLogEntry(`${current.name} has been eliminated!`, 'info');
                checkWinCondition();
                if (state.phase === 'playing') {
                    nextTurn();
                }
            }
        });

        const playerStatsModal = document.getElementById('player-stats-modal');
        const playerStatsTitle = document.getElementById('player-stats-title');
        const playerStatsAvatar = document.getElementById('player-stats-avatar');
        const playerStatsHp = document.getElementById('player-stats-hp');
        const playerStatsTurnOrder = document.getElementById('player-stats-turn-order');
        const playerStatsStatus = document.getElementById('player-stats-status');
        const playerStatsHitDrop = document.getElementById('player-stats-hit-drop');
        const playerStatsRolledClaimed = document.getElementById('player-stats-rolled-claimed');
        const playerStatsDropsHint = document.getElementById('player-stats-drops-hint');
        const playerStatsUndoDropBtn = document.getElementById('player-stats-undo-drop-btn');
        const playerStatsCloseBtn = document.getElementById('player-stats-close-btn');

        let playerStatsModalPlayerId = null;

        function openPlayerStatsModal(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (!player) return;
            playerStatsModalPlayerId = playerId;
            playerStatsTitle.textContent = player.name;
            playerStatsAvatar.style.background = player.color.hex;
            playerStatsHp.textContent = `${player.hp} / ${player.maxHp} HP`;
            playerStatsTurnOrder.textContent = `Turn order: #${state.players.indexOf(player) + 1}`;
            if (player.eliminated) {
                playerStatsStatus.textContent = 'Status: Eliminated';
                playerStatsStatus.style.color = '#e74c3c';
            } else if (state.players[state.currentPlayerIndex].id === player.id) {
                playerStatsStatus.textContent = 'Status: Current turn';
                playerStatsStatus.style.color = '#feca57';
            } else {
                playerStatsStatus.textContent = 'Status: In game';
                playerStatsStatus.style.color = '#48dbfb';
            }

            const hitCount = state.gameLog.filter(e => e.message.includes(player.name) && e.message.includes('dealt') && e.message.includes('damage to')).length;
            const dropCountForStat = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(player.name)).length;
            const totalScoring = hitCount + dropCountForStat;
            if (totalScoring > 0) {
                const hitPct = (hitCount / totalScoring * 100).toFixed(1);
                playerStatsHitDrop.textContent = `Efficiency: ${hitPct}%`;
            } else {
                playerStatsHitDrop.textContent = 'Efficiency: —';
            }

            const rolled = player.totalRolled || 0;
            const claimed = player.totalClaimed || 0;
            if (rolled > 0) {
                const pct = (claimed / rolled * 100).toFixed(1);
                playerStatsRolledClaimed.textContent = `Points: ${claimed}/${rolled} (${pct}%)`;
            } else {
                playerStatsRolledClaimed.textContent = 'Points: —';
            }

            const current = getCurrentPlayer();
            const undoableCount = !state.damageDealtThisTurn && current.id === player.id ? state.dropsThisTurnLogIndices.length : 0;
            const canUndoDrop = undoableCount > 0;

            const dropCount = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(player.name)).length;
            playerStatsDropsHint.textContent = dropCount === 0 ? 'No drops this game.' : `${dropCount} drop(s) this game.`;
            playerStatsUndoDropBtn.style.display = canUndoDrop ? 'block' : 'none';
            playerStatsUndoDropBtn.textContent = undoableCount === 1 ? 'Undo last drop' : `Undo last drop (${undoableCount} undoable)`;
            playerStatsModal.classList.add('open');
        }

        function closePlayerStatsModal() {
            playerStatsModal.classList.remove('open');
            playerStatsModalPlayerId = null;
        }

        playerStatsCloseBtn.addEventListener('click', closePlayerStatsModal);
        playerStatsModal.addEventListener('click', (e) => { if (e.target === playerStatsModal) closePlayerStatsModal(); });

        playerStatsUndoDropBtn.addEventListener('click', () => {
            if (playerStatsModalPlayerId === null) return;
            const current = getCurrentPlayer();
            if (current.id !== playerStatsModalPlayerId) return;
            if (state.damageDealtThisTurn || state.dropsThisTurnLogIndices.length === 0) return;
            const logIndex = state.dropsThisTurnLogIndices.pop();
            const logEntry = state.gameLog[logIndex];
            if (!logEntry || logEntry.type !== 'damage' || !logEntry.message.includes('dropped a knife') || !logEntry.message.includes(current.name)) {
                state.dropsThisTurnLogIndices.push(logIndex);
                return;
            }
            const domIndex = state.gameLog.length - 1 - logIndex;
            if (gameLogEntries.children[domIndex]) gameLogEntries.children[domIndex].remove();
            state.gameLog.splice(logIndex, 1);
            for (let i = 0; i < state.dropsThisTurnLogIndices.length; i++) {
                if (state.dropsThisTurnLogIndices[i] > logIndex) state.dropsThisTurnLogIndices[i]--;
            }
            current.hp = Math.min(current.maxHp, current.hp + 1);
            if (current.hp > 0) current.eliminated = false;
            state.dropsThisTurn = Math.max(0, state.dropsThisTurn - 1);
            state.lastDroppedKnifeLogIndex = state.dropsThisTurnLogIndices.length > 0 ? state.dropsThisTurnLogIndices[state.dropsThisTurnLogIndices.length - 1] : undefined;
            updatePlayersPanel();
            checkWinCondition();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / 3`;
            openPlayerStatsModal(playerStatsModalPlayerId);
        });

        playersPanel.addEventListener('click', (e) => {
            const btn = e.target.closest('.player-card-stats-btn');
            if (!btn) return;
            e.stopPropagation();
            const playerId = parseInt(btn.dataset.player, 10);
            openPlayerStatsModal(playerId);
        });

        endTurnBtn.addEventListener('click', () => {
            nextTurn();
        });

        function nextTurn() {
            disableTargetSelection();
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            let nextIdx = state.currentPlayerIndex;
            const alivePlayers = getAlivePlayers();

            if (alivePlayers.length <= 1) {
                checkWinCondition();
                return;
            }

            do {
                nextIdx = (nextIdx + 1) % state.players.length;
            } while (state.players[nextIdx].eliminated);

            state.currentPlayerIndex = nextIdx;
            addLogEntry(`${getCurrentPlayer().name}'s turn begins.`, 'info');
            updateGameUI();
        }

        function checkWinCondition() {
            const alivePlayers = getAlivePlayers();
            if (alivePlayers.length === 1) {
                state.phase = 'finished';
                showWinner(alivePlayers[0]);
            } else if (alivePlayers.length === 0) {
                state.phase = 'finished';
                showWinner(null);
            }
        }

        function showWinner(winner) {
            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'block';

            if (winner) {
                document.getElementById('winner-name').innerHTML = `
                    <div style="width: 80px; height: 80px; border-radius: 50%; background: ${winner.color.hex}; margin: 0 auto 20px;"></div>
                    <span style="color: ${winner.color.hex};">${winner.name}</span> Wins!
                `;
            } else {
                document.getElementById('winner-name').textContent = "It's a Draw!";
            }
        }

        function generateGameReportHTML(winner) {
            const now = new Date();
            const dateStr = now.toLocaleDateString(undefined, { dateStyle: 'long' });
            const timeStr = now.toLocaleTimeString(undefined, { timeStyle: 'short' });
            const winnerText = winner ? winner.name : "Draw (no winner)";
            const turnOrderList = state.players.map((p, i) => `${i + 1}. ${p.name}`).join(', ');

            const playerRows = state.players.map(p => {
                let status = p.eliminated ? 'Eliminated' : (winner && p.id === winner.id ? 'Winner' : 'Survived');
                return `
                <tr>
                    <td><span class="report-color-dot" style="background:${p.color.hex}"></span> ${escapeHtml(p.name)}</td>
                    <td>${p.hp} / ${p.maxHp}</td>
                    <td><span class="report-status report-status-${status.toLowerCase().replace(/\s/g,'')}">${status}</span></td>
                </tr>`;
            }).join('');

            const logEntries = state.gameLog.map((e, i) => {
                const cls = e.type === 'damage' ? 'report-log-damage' : e.type === 'heal' ? 'report-log-heal' : 'report-log-info';
                return `<li class="report-log-entry ${cls}"><span class="report-log-num">${i + 1}.</span> ${escapeHtml(e.message)}</li>`;
            }).join('');
            const totalActions = state.gameLog.length;

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger &amp; Die - Game Report</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 40px 20px;
            line-height: 1.5;
        }
        .report-container { max-width: 720px; margin: 0 auto; }
        .report-header {
            text-align: center;
            margin-bottom: 36px;
            padding-bottom: 24px;
            border-bottom: 2px solid rgba(255,255,255,0.15);
        }
        .report-title {
            font-size: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }
        .report-meta { color: rgba(255,255,255,0.6); font-size: 0.95rem; }
        .report-winner-box {
            background: rgba(254, 202, 87, 0.15);
            border: 2px solid rgba(254, 202, 87, 0.5);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 28px;
            text-align: center;
        }
        .report-winner-label { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.7); margin-bottom: 4px; }
        .report-winner-name { font-size: 1.5rem; font-weight: bold; color: #feca57; }
        .report-section {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 24px;
        }
        .report-section h2 {
            font-size: 1.1rem;
            color: #48dbfb;
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .report-table { width: 100%; border-collapse: collapse; }
        .report-table th, .report-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .report-table th { color: rgba(255,255,255,0.7); font-weight: 600; font-size: 0.85rem; }
        .report-color-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; margin-right: 6px; }
        .report-status { font-size: 0.85rem; padding: 2px 8px; border-radius: 6px; }
        .report-status-winner { background: rgba(46, 204, 113, 0.3); color: #2ecc71; }
        .report-status-eliminated { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }
        .report-status-survived { background: rgba(72, 219, 251, 0.2); color: #48dbfb; }
        .report-turn-order { color: rgba(255,255,255,0.85); font-size: 0.95rem; }
        .report-log { list-style: none; }
        .report-log-entry { padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 0.9rem; display: flex; gap: 8px; }
        .report-log-entry:last-child { border-bottom: none; }
        .report-log-num { color: rgba(255,255,255,0.4); min-width: 28px; }
        .report-log-damage { color: #ff6b6b; }
        .report-log-heal { color: #2ecc71; }
        .report-log-info { color: #48dbfb; }
    </style>
</head>
<body>
    <div class="report-container">
        <header class="report-header">
            <h1 class="report-title">Dagger &amp; Die</h1>
            <p class="report-meta">Game Report &middot; ${escapeHtml(dateStr)} at ${escapeHtml(timeStr)}</p>
        </header>
        <div class="report-winner-box">
            <div class="report-winner-label">Winner</div>
            <div class="report-winner-name">${escapeHtml(winnerText)}</div>
        </div>
        <section class="report-section">
            <h2>Players (final)</h2>
            <table class="report-table">
                <thead><tr><th>Player</th><th>HP</th><th>Status</th></tr></thead>
                <tbody>${playerRows}</tbody>
            </table>
        </section>
        <section class="report-section">
            <h2>Turn order</h2>
            <p class="report-turn-order">${escapeHtml(turnOrderList)}</p>
        </section>
        <section class="report-section">
            <h2>Game actions (${totalActions})</h2>
            <ul class="report-log">${logEntries || '<li class="report-log-info">No actions recorded.</li>'}</ul>
        </section>
    </div>
</body>
</html>`;
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function exportGameReport() {
            const winner = getAlivePlayers().length === 1 ? getAlivePlayers()[0] : null;
            const html = generateGameReportHTML(winner);
            const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank', 'noopener');
            const a = document.createElement('a');
            a.href = url;
            a.download = `dagger-die-report-${new Date().toISOString().slice(0,10)}.html`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }

        document.getElementById('export-report-btn').addEventListener('click', exportGameReport);

        function resetDice() {
            ['die1', 'die2', 'die3'].forEach(id => {
                const die = document.getElementById(id);
                die.textContent = '-';
                die.classList.remove('odd', 'even', 'rolling');
            });
        }

        function addLogEntry(message, type = 'info') {
            state.gameLog.push({ message, type });
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            gameLogEntries.insertBefore(entry, gameLogEntries.firstChild);
        }

        document.getElementById('new-game-btn').addEventListener('click', resetGame);
                function playAgain() {
            const defaultHp = getDefaultHp(state.players.length);
            state.players.forEach(p => {
                p.hp = defaultHp;
                p.maxHp = defaultHp;
                p.eliminated = false;
                p.turnOrderRoll = 0;
                p.totalRolled = 0;
                p.totalClaimed = 0;
            });
            state.currentPlayerIndex = 0;
            state.phase = 'turnOrder';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            winnerScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            rollBtn.classList.remove('hidden');
            rollBtn.disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');

            const tieMsg = document.getElementById('tie-reroll-message');
            if (tieMsg) tieMsg.style.display = 'none';

            gameLogEntries.innerHTML = '';
        }

        document.getElementById('play-again-btn').addEventListener('click', playAgain);
        document.getElementById('finished-btn').addEventListener('click', () => { window.location.href = 'index.html'; });

        function resetGame() {
            state.players = [];
            state.currentPlayerIndex = 0;
            state.phase = 'setup';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'none';
            turnOrderScreen.style.display = 'none';
            setupScreen.style.display = 'block';

            document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
            playerSetup.innerHTML = '';
            playerSetup.classList.remove('visible');
            startGameBtn.style.display = 'none';
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }
            gameLogEntries.innerHTML = '';

            document.getElementById('roll-turn-order-btn').classList.remove('hidden');
            document.getElementById('roll-turn-order-btn').disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');
        }
    </script>
</body>
</html>
