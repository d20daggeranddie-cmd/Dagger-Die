<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger & Die - Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&display=swap" rel="stylesheet">
    <!-- Google Analytics (GA4) - Replace G-XXXXXXXXXX with your Measurement ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0c18;
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* ── RPG background layers (from playersbkgnd.html) ── */
        .game-bg-base {
            position: fixed; inset: 0; z-index: 0;
            background:
                radial-gradient(ellipse 120% 80% at 50% 110%, #1a1040 0%, transparent 60%),
                radial-gradient(ellipse 80% 60% at 20% 80%, #0d1a3a 0%, transparent 50%),
                radial-gradient(ellipse 80% 60% at 80% 80%, #1a0d2e 0%, transparent 50%),
                radial-gradient(ellipse 100% 50% at 50% 0%, #0f1628 0%, transparent 60%),
                linear-gradient(180deg, #080b16 0%, #0e1225 40%, #141833 70%, #1a1040 100%);
        }
        .game-bg-texture {
            position: fixed; inset: 0; z-index: 1;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='60' height='60' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
            background-size: 200px 200px;
        }
        .game-bg-vignette {
            position: fixed; inset: 0; z-index: 2;
            background: radial-gradient(ellipse 70% 60% at 50% 50%, transparent 30%, rgba(5,5,15,0.7) 100%);
            pointer-events: none;
        }
        .game-bg-grid {
            position: fixed; inset: 0; z-index: 2;
            pointer-events: none;
            opacity: 0.02;
            background-image:
                linear-gradient(rgba(150,160,200,0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150,160,200,0.3) 1px, transparent 1px);
            background-size: 60px 60px;
        }
        .game-bg-fog {
            position: fixed; inset: 0; z-index: 3; pointer-events: none;
            overflow: hidden;
        }
        .game-bg-fog-layer {
            position: absolute; width: 200%; height: 100%;
            top: 0; left: -50%;
            background:
                radial-gradient(ellipse 300px 80px at 20% 70%, rgba(100,120,180,0.06) 0%, transparent 70%),
                radial-gradient(ellipse 400px 100px at 60% 80%, rgba(80,60,140,0.05) 0%, transparent 70%),
                radial-gradient(ellipse 250px 60px at 80% 60%, rgba(60,80,160,0.04) 0%, transparent 70%);
            animation: gameFogDrift 40s ease-in-out infinite alternate;
        }
        .game-bg-fog-layer:nth-child(2) {
            background:
                radial-gradient(ellipse 350px 90px at 30% 85%, rgba(70,50,120,0.05) 0%, transparent 70%),
                radial-gradient(ellipse 280px 70px at 70% 75%, rgba(90,100,170,0.04) 0%, transparent 70%);
            animation: gameFogDrift2 55s ease-in-out infinite alternate;
            opacity: 0.8;
        }
        @keyframes gameFogDrift {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(5%) translateY(-2%); }
        }
        @keyframes gameFogDrift2 {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(-4%) translateY(1%); }
        }
        .game-bg-particles { position: fixed; inset: 0; z-index: 4; pointer-events: none; overflow: hidden; }
        .game-bg-particle {
            position: absolute; border-radius: 50%; opacity: 0;
            animation: gameFloatUp linear infinite;
        }
        @keyframes gameFloatUp {
            0% { opacity: 0; transform: translateY(0) translateX(0) scale(1); }
            10% { opacity: 1; }
            90% { opacity: 0.6; }
            100% { opacity: 0; transform: translateY(-100vh) translateX(40px) scale(0.3); }
        }
        .game-bg-runes { position: fixed; inset: 0; z-index: 5; pointer-events: none; overflow: hidden; }
        .game-bg-rune {
            position: absolute; font-family: serif; opacity: 0;
            animation: gameRuneFloat 12s ease-in-out infinite;
            filter: blur(0.5px);
            text-shadow: 0 0 8px currentColor, 0 0 20px currentColor;
        }
        @keyframes gameRuneFloat {
            0% { opacity: 0; transform: translateY(20px) rotate(0deg) scale(0.8); }
            15% { opacity: 0.15; }
            50% { opacity: 0.25; transform: translateY(-10px) rotate(5deg) scale(1); }
            85% { opacity: 0.12; }
            100% { opacity: 0; transform: translateY(-30px) rotate(-3deg) scale(0.9); }
        }
        .game-bg-corner { position: fixed; z-index: 6; width: 120px; height: 120px; pointer-events: none; opacity: 0.12; }
        .game-bg-corner svg { width: 100%; height: 100%; }
        .game-bg-corner-tl { top: 12px; left: 12px; }
        .game-bg-corner-tr { top: 12px; right: 12px; transform: scaleX(-1); }
        .game-bg-corner-bl { bottom: 12px; left: 12px; transform: scaleY(-1); }
        .game-bg-corner-br { bottom: 12px; right: 12px; transform: scale(-1, -1); }
        .game-bg-ambient {
            position: fixed; z-index: 3; pointer-events: none;
            width: 500px; height: 500px; border-radius: 50%;
            background: radial-gradient(circle, rgba(180,140,60,0.03) 0%, transparent 70%);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            animation: gameAmbientPulse 8s ease-in-out infinite;
        }
        @keyframes gameAmbientPulse {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
        }
        .game-bg-torch {
            position: fixed; z-index: 3; pointer-events: none;
            width: 300px; height: 400px; border-radius: 50%;
            animation: gameTorchFlicker 3s ease-in-out infinite alternate;
        }
        .game-bg-torch-left { left: -100px; top: 30%; background: radial-gradient(ellipse, rgba(200,120,40,0.04) 0%, transparent 70%); animation-duration: 2.8s; }
        .game-bg-torch-right { right: -100px; top: 25%; background: radial-gradient(ellipse, rgba(200,120,40,0.035) 0%, transparent 70%); animation-duration: 3.2s; animation-delay: 0.5s; }
        @keyframes gameTorchFlicker {
            0% { opacity: 0.6; transform: scale(1); }
            25% { opacity: 1; transform: scale(1.05); }
            50% { opacity: 0.7; transform: scale(0.98); }
            75% { opacity: 0.9; transform: scale(1.02); }
            100% { opacity: 0.65; transform: scale(1); }
        }
        #gameParticleCanvas { position: fixed; inset: 0; z-index: 4; pointer-events: none; }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            text-align: center;
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 30px;
            color: #d4a84b;
            text-shadow: 3px 3px 0 #5c3d1e, 5px 5px 0 rgba(0,0,0,0.4), 0 0 30px rgba(212, 168, 75, 0.4), 0 0 60px rgba(212, 168, 75, 0.2);
            letter-spacing: 6px;
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(238, 90, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            color: #fff;
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        /* Game Screen */
        #game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-gear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-gear-btn:hover {
            background: rgba(72, 219, 251, 0.3);
            color: #48dbfb;
        }

        .settings-gear-btn svg {
            width: 22px;
            height: 22px;
        }

        .settings-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .settings-modal-overlay.open {
            display: flex;
        }

        .settings-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .settings-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
        }

        .settings-modal label {
            display: block;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.9);
            font-size: 0.95rem;
        }

        .settings-modal input[type="number"] {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .settings-modal input[type="number"]:focus {
            outline: none;
            border-color: #48dbfb;
        }

        .settings-modal .setting-hint {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 20px;
        }

        .settings-modal .setting-readonly-hint {
            color: #feca57;
            margin-bottom: 16px;
        }

        .settings-modal .option-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .settings-modal .option-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #48dbfb;
        }

        .settings-modal .option-row label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .settings-modal .custom-hp-row {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        .settings-modal input[type="number"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-modal .btn {
            width: 100%;
            margin-top: 8px;
        }

        /* Player stats modal */
        .player-stats-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .player-stats-modal-overlay.open {
            display: flex;
        }

        .player-stats-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .player-stats-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
            text-align: center;
        }

        .player-stats-modal h4 {
            font-size: 1rem;
            color: #48dbfb;
            margin-bottom: 10px;
        }

        .player-stats-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
        }

        .player-stats-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            flex-shrink: 0;
            overflow: hidden;
        }

        .player-stats-meta {
            flex: 1;
        }

        .player-stats-row {
            margin-bottom: 6px;
            color: rgba(255,255,255,0.95);
            font-size: 1rem;
        }

        .player-stats-section {
            margin-bottom: 24px;
        }

        .player-stats-section .setting-hint {
            margin-bottom: 12px;
        }

        .player-stats-modal .btn {
            width: 100%;
        }
        #damage-confirm-modal-content,
        #critical-item-modal-content {
            max-width: 430px;
            border: 1px solid rgba(254, 202, 87, 0.28);
            box-shadow: 0 24px 70px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.06);
        }
        .modal-eyebrow {
            margin: 0 auto 8px auto;
            width: fit-content;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(254, 202, 87, 0.4);
            background: rgba(254, 202, 87, 0.1);
            color: #feca57;
            font-size: 0.72rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 700;
        }
        .confirm-rolls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 6px 0 10px 0;
        }
        .confirm-roll-pill {
            min-width: 44px;
            padding: 7px 10px;
            border-radius: 10px;
            font-weight: 800;
            font-size: 1.05rem;
            text-align: center;
            background: rgba(72, 219, 251, 0.16);
            border: 1px solid rgba(72, 219, 251, 0.35);
            color: #8feaff;
        }
        #damage-confirm-detail {
            text-align: center;
            margin: 0 0 16px 0;
            color: rgba(255,255,255,0.9);
            font-size: 0.95rem;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
        }
        .modal-actions .btn {
            margin-top: 0;
            width: 100%;
        }
        #critical-item-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 14px 0 18px 0;
            padding: 14px 16px;
            border-radius: 14px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.12);
        }
        .critical-item-roll {
            font-size: 0.78rem;
            color: rgba(255,255,255,0.75);
            letter-spacing: 0.04em;
        }
        .critical-item-name {
            font-size: 1.2rem;
            font-weight: 800;
        }
        .critical-item-effect {
            color: #8feaff;
            text-align: center;
            font-size: 0.95rem;
        }
        .critical-item-type {
            font-size: 0.72rem;
            opacity: 0.75;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        /* Critical hit onscreen reaction */
        .critical-reaction {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .critical-reaction.show {
            opacity: 1;
            animation: critical-pulse 0.3s ease-out;
        }
        .critical-reaction.hide {
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }
        @keyframes critical-pulse {
            0% { transform: scale(0.85); }
            50% { transform: scale(1.06); }
            100% { transform: scale(1); }
        }
        .critical-reaction-inner {
            background: linear-gradient(135deg, rgba(254, 202, 87, 0.95) 0%, rgba(255, 107, 107, 0.9) 100%);
            color: #1a1a2e;
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            letter-spacing: 0.15em;
            padding: 24px 48px;
            border-radius: 16px;
            box-shadow: 0 0 60px rgba(254, 202, 87, 0.6), 0 0 120px rgba(255, 107, 107, 0.3);
            text-transform: uppercase;
        }

        .turn-indicator {
            font-size: 1.5rem;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .current-player-name {
            font-weight: bold;
        }

        /* Players Panel */
        .players-panel {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
            justify-content: center;
        }

        .player-card {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.current {
            border-color: #feca57;
            box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
            transform: scale(1.05);
        }

        .player-card.eliminated {
            opacity: 0.4;
            filter: grayscale(1);
        }

        .player-card.targetable {
            cursor: pointer;
        }

        .player-card.targetable:hover {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
        }

        .player-card-stats-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
        }

        .player-card-stats-btn:hover {
            background: rgba(72, 219, 251, 0.4);
            color: #48dbfb;
        }

        .player-card-stats-btn svg {
            width: 16px;
            height: 16px;
        }

        .player-card-dropped {
            animation: dropped-flash 0.6s ease-out;
        }

        .player-card.buffed {
            border-color: #2ecc71;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }

        .player-card.buffed.current {
            border-color: #2ecc71;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.5), 0 0 15px rgba(254, 202, 87, 0.3);
        }

        .player-card.nerfed {
            border-color: #e74c3c;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
        }

        .player-card.nerfed.current {
            border-color: #e74c3c;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5), 0 0 15px rgba(254, 202, 87, 0.3);
        }
        .player-card.shielded { box-shadow: 0 0 14px rgba(129, 140, 248, 0.35); }
        .player-card.focused { box-shadow: 0 0 14px rgba(250, 204, 21, 0.35); }
        .player-card.enraged { box-shadow: 0 0 14px rgba(251, 113, 133, 0.35); }
        .player-card.regening { box-shadow: 0 0 14px rgba(74, 222, 128, 0.35); }
        .player-card.poisoned { box-shadow: 0 0 14px rgba(196, 132, 252, 0.35); }
        .player-card.free-drops { box-shadow: 0 0 14px rgba(56, 189, 248, 0.35); }
        .player-card.aiming { box-shadow: 0 0 14px rgba(167, 139, 250, 0.35); }
        .player-card.hp-change-up {
            animation: hp-heal-flash 0.55s ease;
        }
        .player-card.hp-change-down {
            animation: hp-damage-flash 0.55s ease;
        }
        .hp-delta-float {
            position: absolute;
            right: 8px;
            top: -10px;
            pointer-events: none;
            font-weight: 900;
            font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.65);
            animation: hp-delta-rise 0.85s ease forwards;
            z-index: 3;
        }
        .hp-delta-float.up { color: #86efac; }
        .hp-delta-float.down { color: #ff8f8f; }
        @keyframes hp-heal-flash {
            0% { box-shadow: 0 0 0 rgba(46,204,113,0); transform: scale(1); }
            35% { box-shadow: 0 0 24px rgba(46,204,113,0.6); transform: scale(1.02); }
            100% { box-shadow: 0 0 0 rgba(46,204,113,0); transform: scale(1); }
        }
        @keyframes hp-damage-flash {
            0% { box-shadow: 0 0 0 rgba(231,76,60,0); transform: scale(1); }
            35% { box-shadow: 0 0 24px rgba(231,76,60,0.55); transform: scale(1.02); }
            100% { box-shadow: 0 0 0 rgba(231,76,60,0); transform: scale(1); }
        }
        @keyframes hp-delta-rise {
            0% { opacity: 0; transform: translateY(6px); }
            20% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-16px); }
        }

        .player-card-status {
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 6px;
            padding: 3px 8px;
            border-radius: 6px;
        }

        .player-card-inventory {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 8px;
        }
        .player-card-inventory-slot {
            width: 28px;
            height: 28px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: pointer;
        }
        .player-card-inventory-slot.has-item {
            border-color: rgba(254,202,87,0.6);
            cursor: pointer;
        }
        .player-card-inventory-slot.has-item:hover {
            border-color: #feca57;
            box-shadow: 0 0 8px rgba(254,202,87,0.5);
        }
        .player-card-inventory-slot.locked-item,
        .player-stats-inventory-slots .inv-slot.locked-item {
            opacity: 0.6;
            filter: grayscale(0.35);
        }
        .player-card-inventory-slot.locked-item:hover,
        .player-stats-inventory-slots .inv-slot.locked-item:hover {
            border-color: rgba(255,255,255,0.35);
            box-shadow: none;
        }
        .player-card-inventory-slot svg {
            width: 20px;
            height: 20px;
            image-rendering: pixelated;
        }

        .player-stats-inventory-slots {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .player-stats-inventory-slots .inv-slot {
            width: 48px;
            height: 48px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: pointer;
        }
        .player-stats-inventory-slots .inv-slot.has-item {
            border-color: rgba(254,202,87,0.6);
        }
        .player-stats-inventory-slots .inv-slot.has-item:hover {
            border-color: #feca57;
            box-shadow: 0 0 12px rgba(254,202,87,0.5);
        }
        .player-stats-inventory-slots .inv-slot svg {
            width: 36px;
            height: 36px;
            image-rendering: pixelated;
        }
        .item-use-icon-wrap {
            width: 64px;
            height: 64px;
        }
        .item-use-icon-wrap svg {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        .item-target-card-btn {
            width: 100%;
            text-align: left;
            padding: 10px 12px;
            border: 2px solid rgba(255,255,255,0.18);
            border-radius: 12px;
            background: rgba(255,255,255,0.08);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .item-target-card-btn:hover {
            border-color: rgba(72, 219, 251, 0.6);
            background: rgba(72, 219, 251, 0.12);
            transform: translateY(-1px);
        }
        .item-target-card-btn.self-target {
            border-color: rgba(254, 202, 87, 0.7);
            box-shadow: 0 0 10px rgba(254, 202, 87, 0.25);
        }
        .item-target-card-inner {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .item-target-card-meta {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            flex: 1;
        }
        .item-target-card-name {
            font-weight: 700;
            line-height: 1.1;
        }
        .item-target-card-hp {
            font-size: 0.85rem;
            opacity: 0.95;
        }
        .item-target-hp-bar {
            width: 100%;
            height: 8px;
            background: rgba(0,0,0,0.35);
            border-radius: 999px;
            overflow: hidden;
        }
        .item-target-hp-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .item-target-status-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .item-target-status-chip {
            font-size: 0.68rem;
            line-height: 1;
            padding: 3px 6px;
            border-radius: 999px;
            background: rgba(255,255,255,0.18);
            border: 1px solid rgba(255,255,255,0.25);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            white-space: nowrap;
        }
        .item-target-status-chip.buff { background: rgba(46, 204, 113, 0.3); border-color: rgba(46, 204, 113, 0.55); color: #2ecc71; }
        .item-target-status-chip.nerf,
        .item-target-status-chip.poison { background: rgba(231, 76, 60, 0.3); border-color: rgba(231, 76, 60, 0.55); color: #ff8f8f; }
        .item-target-status-chip.shield { background: rgba(128, 144, 176, 0.35); border-color: rgba(128, 144, 176, 0.6); color: #d1d9f4; }
        .item-target-status-chip.focus,
        .item-target-status-chip.rage { background: rgba(240, 192, 64, 0.3); border-color: rgba(240, 192, 64, 0.6); color: #ffd98a; }
        .item-target-status-chip.regen { background: rgba(80, 208, 112, 0.28); border-color: rgba(80, 208, 112, 0.55); color: #86efac; }
        .item-target-status-chip.free { background: rgba(72, 219, 251, 0.28); border-color: rgba(72, 219, 251, 0.55); color: #8feaff; }
        .item-target-status-chip.eliminated { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.28); color: rgba(255,255,255,0.8); }

        .player-card-status.buff {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .player-card-status.nerf {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }
        .player-card-status.shield { background: rgba(129, 140, 248, 0.25); color: #c7d2fe; }
        .player-card-status.focus { background: rgba(250, 204, 21, 0.24); color: #fde68a; }
        .player-card-status.rage { background: rgba(251, 113, 133, 0.24); color: #fecdd3; }
        .player-card-status.regen { background: rgba(74, 222, 128, 0.24); color: #bbf7d0; }
        .player-card-status.poison { background: rgba(196, 132, 252, 0.24); color: #e9d5ff; }
        .player-card-status.free { background: rgba(56, 189, 248, 0.24); color: #bae6fd; }
        .player-card-status.eliminated { background: rgba(255,255,255,0.15); color: #d1d5db; }

        /* Death ghost animation */
        .death-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 60px;
            height: 70px;
            animation: ghost-float 1.8s ease-out forwards;
        }
        .death-ghost svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.5));
        }
        @keyframes ghost-float {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            30% { opacity: 1; transform: translateY(-20px) scale(1.05) translateX(0); }
            60% { opacity: 0.9; transform: translateY(-60px) scale(1) translateX(8px); }
            100% { opacity: 0; transform: translateY(-120px) scale(0.8) translateX(-5px); }
        }

        /* Miss confirmation modal */
        .miss-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1100;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .miss-modal-overlay.open {
            display: flex;
        }

        .miss-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 360px;
            width: 100%;
            border: 2px solid rgba(231, 76, 60, 0.4);
        }

        .miss-modal-player {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            font-size: 1.5rem;
            color: #d4a84b;
            text-align: center;
            margin-bottom: 8px;
        }

        .miss-modal-question {
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
            text-align: center;
            margin-bottom: 24px;
        }

        .miss-modal-buttons {
            display: flex;
            gap: 12px;
        }

        .miss-modal-buttons .btn {
            flex: 1;
        }

        /* Miss onscreen reaction */
        .miss-reaction {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .miss-reaction.show {
            opacity: 1;
            animation: miss-pulse 0.3s ease-out;
        }
        .miss-reaction.hide {
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }
        @keyframes miss-pulse {
            0% { transform: scale(0.85); }
            50% { transform: scale(1.06); }
            100% { transform: scale(1); }
        }
        .miss-reaction-inner {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.95) 0%, rgba(139, 69, 69, 0.9) 100%);
            color: #fff;
            font-size: clamp(1.8rem, 6vw, 3rem);
            font-weight: 900;
            letter-spacing: 0.15em;
            padding: 20px 40px;
            border-radius: 16px;
            box-shadow: 0 0 60px rgba(231, 76, 60, 0.5);
            text-transform: uppercase;
        }

        @keyframes dropped-flash {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.8); transform: scale(1.05); }
            30% { box-shadow: 0 0 25px 8px rgba(255, 107, 107, 0.5); border-color: #ff6b6b; }
            100% { box-shadow: none; border-color: transparent; transform: scale(1); }
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }
        .player-avatar.player-avatar-char {
            overflow: hidden;
        }
        .player-avatar.player-avatar-char svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-hp {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #2ecc71);
            transition: width 0.5s;
        }

        .player-turn-order {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        .player-card-bot-skill {
            font-size: 0.75rem;
            margin-top: 4px;
            color: #48dbfb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        /* Game Area */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        /* Dice Section */
        .dice-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .section-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .die {
            width: 65px;
            height: 65px;
            background: linear-gradient(145deg, #2d3436, #1e272e);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .die.rolling {
            animation: roll 0.1s infinite;
        }

        .die.odd {
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .die.even {
            color: #48dbfb;
            border-color: #48dbfb;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
        }

        .roll-btn {
            display: block;
            margin: 0 auto 20px;
            padding: 15px 50px;
        }

        .dice-results {
            text-align: center;
            margin-top: 15px;
        }

        .total-damage {
            font-size: 1.5rem;
            color: #feca57;
        }

        /* Target Section */
        .targets-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .targets-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .target-wrapper {
            position: relative;
            width: 180px;
        }

        .target-label {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.85rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .target-image-container {
            position: relative;
            width: 100%;
            aspect-ratio: 400 / 460;
            border-radius: 20px;
            overflow: hidden;
            /* Card style matching setup screen / player cards */
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .target-image {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            object-fit: contain;
            object-position: center;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            z-index: 2;
        }

        .target-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .target-board-inline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .target-overlay.clickable {
            pointer-events: auto;
        }

        .target-overlay.clickable .highlight-zone.active {
            cursor: pointer;
        }

        .target-overlay.clickable .highlight-zone:not(.active) {
            cursor: default;
        }

        .highlight-zone {
            cursor: pointer;
            pointer-events: all;
            transition: all 0.3s;
        }

        .highlight-zone .face-shape {
            fill: #2a1f3d;
            stroke: #8a7fa8;
            stroke-width: 1.5;
            stroke-linejoin: round;
        }
        .highlight-zone .face-shape.d20-face-center {
            fill: #3d2a5c;
        }
        .highlight-zone .face-shape.d20-face-outer {
            fill: #1e1630;
        }

        .highlight-zone.active .face-shape {
            fill: rgba(251, 191, 36, 0.35);
            stroke: #fbbf24;
            stroke-width: 2.5;
            filter: url(#glow-odd);
            animation: pulse 1.5s infinite;
        }

        #even-overlay .highlight-zone.active .face-shape {
            filter: url(#glow-even);
        }

        .highlight-zone.claimed .face-shape {
            fill: rgba(34, 197, 94, 0.35);
            stroke: #22c55e;
            stroke-width: 2.5;
            filter: url(#glow-hit-odd);
            animation: none;
        }
        .highlight-zone.aimed .face-shape {
            fill: rgba(34, 211, 238, 0.26);
            stroke: #22d3ee;
            stroke-width: 2.8;
            filter: url(#glow-even);
            stroke-dasharray: 7 4;
        }
        .highlight-zone.aimed.claimed .face-shape {
            fill: rgba(232, 121, 249, 0.3);
            stroke: #e879f9;
            filter: url(#glow-even);
            stroke-dasharray: 7 4;
        }

        #even-overlay .highlight-zone.claimed .face-shape {
            filter: url(#glow-hit-even);
        }

        .highlight-zone text {
            font-family: serif;
            fill: #b0a8c8;
            pointer-events: none;
            transition: fill 0.3s ease;
        }
        .highlight-zone text.d20-num-center {
            fill: #c8bfe0;
            font-weight: bold;
        }

        .highlight-zone.active text {
            fill: #fbbf24;
        }

        .highlight-zone.claimed text {
            fill: #22c55e;
        }
        .highlight-zone.aimed text {
            fill: #67e8f9;
            font-weight: 700;
        }
        .highlight-zone.aimed.claimed text {
            fill: #f5d0fe;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Actions Section */
        .actions-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .attack-prompt {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #feca57;
        }

        .editable-hits-box:hover {
            background: rgba(46, 204, 113, 0.35) !important;
            border-color: #27ae60 !important;
        }

        .hit-info {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .hit-badge {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .hit-badge.hit {
            background: #2ecc71;
        }

        .hit-badge.miss {
            background: #e74c3c;
        }

        /* Turn Order Screen */
        #turn-order-screen {
            display: none;
            text-align: center;
        }

        .turn-order-rolls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 30px auto;
        }

        .turn-order-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
        }

        .turn-order-player .roll-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #feca57;
        }

        /* Winner Screen */
        #winner-screen {
            display: none;
            text-align: center;
            padding: 60px 20px;
        }

        .winner-title {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #feca57; }
            50% { text-shadow: 0 0 40px #feca57, 0 0 60px #ff6b6b; }
        }

        .winner-name {
            font-size: 2rem;
            margin-bottom: 40px;
        }

        /* Game Log */
        .game-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #2ecc71;
        }

        .log-info {
            color: #48dbfb;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            .game-header {
                margin-bottom: 10px;
            }

            .turn-indicator {
                font-size: 1rem;
                padding: 8px 12px;
            }

            .players-panel {
                gap: 8px;
                margin-bottom: 15px;
            }

            .player-card {
                padding: 10px;
                min-width: 100px;
            }

            .player-avatar {
                width: 40px;
                height: 40px;
            }

            .player-hp {
                font-size: 1.1rem;
            }

            .player-turn-order {
                font-size: 0.7rem;
            }

            .game-area {
                gap: 15px;
            }

            .dice-section, .targets-section, .actions-section {
                padding: 15px;
                border-radius: 15px;
            }

            .section-title {
                font-size: 1rem;
                margin-bottom: 10px;
            }

            .die {
                width: 55px;
                height: 55px;
                font-size: 1.3rem;
            }

            .dice-container {
                gap: 10px;
                margin-bottom: 10px;
            }

            .roll-btn {
                padding: 10px 30px;
                font-size: 1rem;
            }

            .target-wrapper {
                width: 140px;
            }

            .target-label {
                font-size: 0.75rem;
                margin-bottom: 3px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .attack-prompt {
                font-size: 1rem;
            }

            .game-log {
                max-height: 100px;
                padding: 10px;
            }

            .log-entry {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 400px) {
            .target-wrapper {
                width: 120px;
            }

            .die {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }

            .player-card {
                min-width: 80px;
                padding: 8px;
            }

            .player-avatar {
                width: 30px;
                height: 30px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-hp {
                font-size: 0.95rem;
            }
        }

        /* Back to Home link */
        .back-link {
            display: inline-block;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #48dbfb;
        }

        .m3-logo {
            position: fixed; bottom: 10px; right: 10px; z-index: 50;
            width: 36px; height: auto; pointer-events: none;
        }
        @media (max-width: 480px) { .m3-logo { width: 28px; bottom: 8px; right: 8px; } }
    </style>
</head>
<body>
    <img src="assets/m3.png" alt="M3" class="m3-logo">
    <!-- RPG background layers -->
    <div class="game-bg-base"></div>
    <div class="game-bg-texture"></div>
    <div class="game-bg-grid"></div>
    <div class="game-bg-vignette"></div>
    <div class="game-bg-fog">
        <div class="game-bg-fog-layer"></div>
        <div class="game-bg-fog-layer"></div>
    </div>
    <div class="game-bg-torch game-bg-torch-left"></div>
    <div class="game-bg-torch game-bg-torch-right"></div>
    <div class="game-bg-ambient"></div>
    <div class="game-bg-particles" id="gameCssParticles"></div>
    <div class="game-bg-runes" id="gameRuneContainer"></div>
    <canvas id="gameParticleCanvas"></canvas>
    <div class="game-bg-corner game-bg-corner-tl">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-tr">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-bl">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-br">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>

    <div class="container">
        <a href="startgame.html" class="back-link">Home</a>
        <h1>Dagger & Die</h1>

        <!-- Turn Order Screen -->
        <div id="turn-order-screen">
            <h2 class="setup-title">Rolling for Turn Order</h2>
            <p>Each player rolls a D20 to determine turn order. Highest goes first!</p>
            <div class="turn-order-rolls" id="turn-order-rolls"></div>
            <button class="btn btn-primary" id="roll-turn-order-btn">Roll for Turn Order</button>
            <button class="btn btn-primary hidden" id="begin-game-btn">Begin Game!</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="game-header">
                <div class="turn-indicator">
                    Turn: <span class="current-player-name" id="current-player-name">-</span>
                </div>
                <div class="game-header-actions">
                    <button type="button" class="settings-gear-btn" id="settings-gear-btn" aria-label="Game settings">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary" id="new-game-btn">New Game</button>
                </div>
            </div>

            <div class="players-panel" id="players-panel"></div>

            <div class="game-area">
                <div class="dice-section">
                    <h3 class="section-title">Your Dice</h3>
                    <div class="dice-container">
                        <div class="die" id="die1">-</div>
                        <div class="die" id="die2">-</div>
                        <div class="die" id="die3">-</div>
                    </div>
                    <button class="btn btn-primary roll-btn" id="roll-dice-btn">Roll Dice</button>
                    <div class="dice-results" id="dice-results"></div>
                </div>

                <div class="targets-section">
                    <h3 class="section-title">Target Boards</h3>
                    <div class="targets-container">
                        <div class="target-wrapper">
                            <div class="target-label">Odd Numbers (1-19)</div>
                            <div class="target-image-container">
                                <svg class="target-board-inline target-overlay" id="odd-overlay" viewBox="0 0 400 460" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <filter id="glow-odd" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="4" result="blur"/>
                                            <feFlood flood-color="#fbbf24" flood-opacity="0.8" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <filter id="glow-hit-odd" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="5" result="blur"/>
                                            <feFlood flood-color="#22c55e" flood-opacity="0.9" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <style>.d20-face{fill:#2a1f3d;stroke:#8a7fa8;stroke-width:1.5;stroke-linejoin:round}.d20-face-center{fill:#3d2a5c}.d20-face-outer{fill:#1e1630}.d20-num{fill:#b0a8c8;font-family:serif;text-anchor:middle;dominant-baseline:central}.d20-num-center{fill:#c8bfe0;font-weight:bold}</style>
                                    </defs>
                                    <rect width="400" height="460" fill="#2d3748" rx="12"/>
                                    <g class="highlight-zone" data-number="15"><polygon class="face-shape d20-face d20-face-outer" points="7,119 2,346 66,316"/><text class="d20-num" x="25" y="260" font-size="28">15</text></g>
                                    <g class="highlight-zone" data-number="9"><polygon class="face-shape d20-face d20-face-outer" points="393,119 334,316 398,346"/><text class="d20-num" x="375" y="260" font-size="28">9</text></g>
                                    <g class="highlight-zone" data-number="13"><polygon class="face-shape d20-face d20-face-outer" points="66,316 2,346 200,458"/><text class="d20-num" x="89" y="373" font-size="28">13</text></g>
                                    <g class="highlight-zone" data-number="19"><polygon class="face-shape d20-face d20-face-outer" points="334,316 200,458 398,346"/><text class="d20-num" x="311" y="373" font-size="28">19</text></g>
                                    <g class="highlight-zone" data-number="17"><polygon class="face-shape d20-face" points="200,2 7,119 200,59"/><text class="d20-num" x="136" y="60" font-size="32">17</text></g>
                                    <g class="highlight-zone" data-number="11"><polygon class="face-shape d20-face" points="200,2 200,59 393,119"/><text class="d20-num" x="264" y="60" font-size="32">11</text></g>
                                    <g class="highlight-zone" data-number="3"><polygon class="face-shape d20-face" points="7,119 66,316 200,59"/><text class="d20-num" x="91" y="165" font-size="32">3</text></g>
                                    <g class="highlight-zone" data-number="7"><polygon class="face-shape d20-face" points="200,59 334,316 393,119"/><text class="d20-num" x="309" y="165" font-size="32">7</text></g>
                                    <g class="highlight-zone" data-number="5"><polygon class="face-shape d20-face" points="66,316 200,458 334,316"/><text class="d20-num" x="200" y="363" font-size="32">5</text></g>
                                    <g class="highlight-zone" data-number="1"><polygon class="face-shape d20-face d20-face-center" points="200,59 66,316 334,316"/><text class="d20-num d20-num-center" x="200" y="230" font-size="48">1</text></g>
                                </svg>
                            </div>
                        </div>
                        <div class="target-wrapper">
                            <div class="target-label">Even Numbers (2-20)</div>
                            <div class="target-image-container">
                                <svg class="target-board-inline target-overlay" id="even-overlay" viewBox="0 0 400 460" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <filter id="glow-even" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="4" result="blur"/>
                                            <feFlood flood-color="#fbbf24" flood-opacity="0.8" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <filter id="glow-hit-even" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="5" result="blur"/>
                                            <feFlood flood-color="#22c55e" flood-opacity="0.9" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <style>.d20-face{fill:#2a1f3d;stroke:#8a7fa8;stroke-width:1.5;stroke-linejoin:round}.d20-face-center{fill:#3d2a5c}.d20-face-outer{fill:#1e1630}.d20-num{fill:#b0a8c8;font-family:serif;text-anchor:middle;dominant-baseline:central}.d20-num-center{fill:#c8bfe0;font-weight:bold}</style>
                                    </defs>
                                    <rect width="400" height="460" fill="#2d3748" rx="12"/>
                                    <g class="highlight-zone" data-number="12"><polygon class="face-shape d20-face d20-face-outer" points="7,119 2,346 66,316"/><text class="d20-num" x="25" y="260" font-size="28">12</text></g>
                                    <g class="highlight-zone" data-number="14"><polygon class="face-shape d20-face d20-face-outer" points="393,119 334,316 398,346"/><text class="d20-num" x="375" y="260" font-size="28">14</text></g>
                                    <g class="highlight-zone" data-number="18"><polygon class="face-shape d20-face d20-face-outer" points="66,316 2,346 200,458"/><text class="d20-num" x="89" y="373" font-size="28">18</text></g>
                                    <g class="highlight-zone" data-number="16"><polygon class="face-shape d20-face d20-face-outer" points="334,316 200,458 398,346"/><text class="d20-num" x="311" y="373" font-size="28">16</text></g>
                                    <g class="highlight-zone" data-number="10"><polygon class="face-shape d20-face" points="200,2 7,119 200,59"/><text class="d20-num" x="136" y="60" font-size="32">10</text></g>
                                    <g class="highlight-zone" data-number="20"><polygon class="face-shape d20-face" points="200,2 200,59 393,119"/><text class="d20-num" x="264" y="60" font-size="32">20</text></g>
                                    <g class="highlight-zone" data-number="4"><polygon class="face-shape d20-face" points="7,119 66,316 200,59"/><text class="d20-num" x="91" y="165" font-size="32">4</text></g>
                                    <g class="highlight-zone" data-number="6"><polygon class="face-shape d20-face" points="200,59 334,316 393,119"/><text class="d20-num" x="309" y="165" font-size="32">6</text></g>
                                    <g class="highlight-zone" data-number="8"><polygon class="face-shape d20-face" points="66,316 200,458 334,316"/><text class="d20-num" x="200" y="363" font-size="32">8</text></g>
                                    <g class="highlight-zone" data-number="2"><polygon class="face-shape d20-face d20-face-center" points="200,59 66,316 334,316"/><text class="d20-num d20-num-center" x="200" y="230" font-size="48">2</text></g>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="actions-section" id="actions-section">
                <h3 class="section-title">Actions</h3>
                <div class="hit-info" id="hit-info"></div>
                <div class="attack-prompt hidden" id="attack-prompt">Select a player to attack!</div>
                <div class="action-buttons">
                    <button class="btn btn-danger hidden" id="dropped-knife-btn">Dropped Knife (-1 HP)</button>
                    <button class="btn btn-primary hidden" id="end-turn-btn">End Turn</button>
                </div>
            </div>

            <div class="game-log">
                <h4>Game Log</h4>
                <div id="game-log-entries"></div>
            </div>
        </div>

        <!-- Winner Screen -->
        <div id="winner-screen">
            <h2 class="winner-title">Victory!</h2>
            <div class="winner-name" id="winner-name"></div>
            <div style="display: flex; justify-content: center; margin-bottom: 32px;">
                <button class="btn btn-secondary" id="export-report-btn">Export Game Report</button>
            </div>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-primary" id="play-again-btn">Play Again</button>
                <button class="btn btn-primary" id="finished-btn">Finished</button>
            </div>
        </div>
    </div>

    <!-- Game settings modal (same options as main menu Options; editable here until first damage) -->
    <div class="settings-modal-overlay" id="settings-modal" role="dialog" aria-label="Game settings">
        <div class="settings-modal">
            <h3>Game Settings</h3>
            <p id="settings-readonly-hint" class="setting-hint setting-readonly-hint" style="display: none;">Settings are locked after the first damage is dealt. Start a new game to change them.</p>
            <p class="setting-hint" style="margin-bottom: 12px;">You can also set these on the main menu under <strong>Options</strong>.</p>
            <div class="option-row">
                <input type="checkbox" id="use-custom-hp-cb" aria-describedby="custom-hp-hint">
                <label for="use-custom-hp-cb">Use custom HP</label>
            </div>
            <div class="custom-hp-row">
                <label for="custom-hp-input">Default HP per player (20–999)</label>
                <input type="number" id="custom-hp-input" min="20" max="999" placeholder="e.g. 50" disabled>
            </div>
            <p id="custom-hp-hint" class="setting-hint">When unchecked, automatic values are used (2 players: 50, 3–4: 40, 5–6: 60).</p>
            <div class="option-row" style="margin-top: 20px;">
                <input type="checkbox" id="persistent-settings-cb" aria-describedby="persistent-settings-hint">
                <label for="persistent-settings-cb">Persistent settings</label>
            </div>
            <p id="persistent-settings-hint" class="setting-hint">When unchecked (default), settings reset to defaults each new game. When checked, your selections are kept until you uncheck this.</p>
            <h4 class="settings-section-title" style="margin-top: 20px; margin-bottom: 10px; font-size: 1rem; color: #48dbfb;">Mods</h4>
            <div class="option-row">
                <input type="checkbox" id="mod-buff-on-critical-cb" aria-describedby="mod-buff-hint">
                <label for="mod-buff-on-critical-cb">Buff on Critical</label>
            </div>
            <p id="mod-buff-hint" class="setting-hint">Take 1/2 damage for 1 turn after scoring a critical.</p>
            <div class="option-row">
                <input type="checkbox" id="mod-nerf-on-miss-cb" aria-describedby="mod-nerf-hint">
                <label for="mod-nerf-on-miss-cb">Nerf on Miss</label>
            </div>
            <p id="mod-nerf-hint" class="setting-hint">Take 125% damage for 1 turn after missing all throws.</p>
            <div class="option-row">
                <input type="checkbox" id="items-enabled-cb" aria-describedby="items-enabled-hint">
                <label for="items-enabled-cb">Items</label>
            </div>
            <p id="items-enabled-hint" class="setting-hint">3 inventory slots, earn items on critical (all 3 hits). Use items before dealing damage.</p>
            <div class="settings-modal-projector-row" style="margin-top: 20px;">
                <button type="button" class="btn btn-secondary" id="open-projector-btn">Dynamic Target</button>
            </div>
            <button type="button" class="btn btn-primary" id="settings-modal-done">Done</button>
        </div>
    </div>

    <!-- Player stats modal -->
    <div class="player-stats-modal-overlay" id="player-stats-modal" role="dialog" aria-label="Player stats">
        <div class="player-stats-modal">
            <h3 id="player-stats-title">Player</h3>
            <div class="player-stats-header">
                <div id="player-stats-avatar" class="player-stats-avatar"></div>
                <div class="player-stats-meta">
                    <div id="player-stats-hp" class="player-stats-row"></div>
                    <div id="player-stats-turn-order" class="player-stats-row"></div>
                    <div id="player-stats-status" class="player-stats-row"></div>
                    <div id="player-stats-hit-drop" class="player-stats-row"></div>
                    <div id="player-stats-rolled-claimed" class="player-stats-row"></div>
                    <div id="player-stats-critical" class="player-stats-row"></div>
                </div>
            </div>
            <div class="player-stats-section" id="player-stats-inventory-section" style="display: none;">
                <h4>Inventory</h4>
                <div id="player-stats-inventory" class="player-stats-inventory-slots"></div>
                <p id="player-stats-inventory-hint" class="setting-hint" style="margin-top: 8px; font-size: 0.85rem;"></p>
            </div>
            <div class="player-stats-section">
                <h4>Drops</h4>
                <p id="player-stats-drops-hint" class="setting-hint"></p>
                <button type="button" class="btn btn-secondary" id="player-stats-undo-drop-btn" style="display: none;">Undo last drop</button>
            </div>
            <button type="button" class="btn btn-primary" id="player-stats-close-btn">Close</button>
        </div>
    </div>

    <!-- Item use modal -->
    <div class="player-stats-modal-overlay" id="item-use-modal" role="dialog" aria-label="Use item">
        <div class="player-stats-modal" id="item-use-modal-content">
            <h3 id="item-use-title">Use Item</h3>
            <div id="item-use-detail" style="display: flex; flex-direction: column; align-items: center; gap: 12px; margin-bottom: 20px;"></div>
            <div id="item-use-targets" style="display: flex; flex-direction: column; gap: 8px;"></div>
            <button type="button" class="btn btn-secondary" id="item-use-cancel-btn" style="margin-top: 12px;">Cancel</button>
        </div>
    </div>

    <!-- Miss confirmation modal -->
    <div class="miss-modal-overlay" id="miss-modal" role="dialog" aria-labelledby="miss-modal-title" aria-modal="true">
        <div class="miss-modal">
            <div class="miss-modal-player" id="miss-modal-player-name"></div>
            <div class="miss-modal-question" id="miss-modal-title">Missed?</div>
            <div class="miss-modal-buttons">
                <button type="button" class="btn btn-secondary" id="miss-modal-no">No</button>
                <button type="button" class="btn btn-primary" id="miss-modal-yes">Yes</button>
            </div>
        </div>
    </div>

    <!-- Damage confirmation modal -->
    <div class="player-stats-modal-overlay" id="damage-confirm-modal" role="dialog" aria-label="Confirm hits">
        <div class="player-stats-modal" id="damage-confirm-modal-content">
            <div class="modal-eyebrow">Score Confirm</div>
            <h3 style="color: #feca57;">Lock these hits?</h3>
            <div id="damage-confirm-rolls" class="confirm-rolls"></div>
            <p id="damage-confirm-detail" class="setting-hint"></p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" id="damage-confirm-edit-btn">Edit</button>
                <button type="button" class="btn btn-primary" id="damage-confirm-yes-btn">Yes</button>
            </div>
        </div>
    </div>

    <!-- Critical item acquired modal -->
    <div class="player-stats-modal-overlay" id="critical-item-modal" role="dialog" aria-label="Item acquired">
        <div class="player-stats-modal" id="critical-item-modal-content">
            <div class="modal-eyebrow">Critical Reward</div>
            <h3 style="color: #feca57;">Item Acquired</h3>
            <div id="critical-item-display"></div>
            <button type="button" class="btn btn-primary" id="critical-item-dismiss-btn">Got it!</button>
        </div>
    </div>

    <!-- Critical hit onscreen reaction -->
    <div class="critical-reaction" id="critical-reaction" aria-live="polite">
        <div class="critical-reaction-inner">Critical!</div>
    </div>

    <!-- Miss onscreen reaction -->
    <div class="miss-reaction" id="miss-reaction" aria-live="polite">
        <div class="miss-reaction-inner">Miss!</div>
    </div>

    <script>
    // ── RPG background: CSS ember particles & runes ──
    (function() {
        const container = document.getElementById('gameCssParticles');
        const colors = ['rgba(200, 140, 50, 0.6)', 'rgba(180, 120, 60, 0.4)', 'rgba(160, 130, 80, 0.3)', 'rgba(140, 160, 200, 0.2)', 'rgba(200, 180, 100, 0.5)'];
        if (container) {
            for (let i = 0; i < 30; i++) {
                const p = document.createElement('div');
                p.className = 'game-bg-particle';
                const size = Math.random() * 3 + 1;
                const color = colors[Math.floor(Math.random() * colors.length)];
                p.style.cssText = `width: ${size}px; height: ${size}px; background: ${color}; box-shadow: 0 0 ${size * 2}px ${color}; left: ${Math.random() * 100}%; bottom: ${Math.random() * 20 - 10}%; animation-duration: ${Math.random() * 15 + 10}s; animation-delay: ${Math.random() * 15}s;`;
                container.appendChild(p);
            }
        }
        const runeContainer = document.getElementById('gameRuneContainer');
        const glyphs = ['\u16A0','\u16A2','\u16A6','\u16A8','\u16B1','\u16B7','\u16B9','\u16BE','\u16C1','\u16C3','\u16C7','\u16C8','\u16CA','\u16CF','\u16D2','\u16D6','\u16DA','\u16DE','\u16DF','\u16E0'];
        const runeColors = ['#b48c3c', '#8a7a5a', '#6a7aa0', '#9a8a6a', '#7a6a9a'];
        if (runeContainer) {
            for (let i = 0; i < 12; i++) {
                const r = document.createElement('div');
                r.className = 'game-bg-rune';
                r.textContent = glyphs[Math.floor(Math.random() * glyphs.length)];
                r.style.cssText = `left: ${Math.random() * 90 + 5}%; top: ${Math.random() * 80 + 10}%; font-size: ${Math.random() * 18 + 14}px; color: ${runeColors[Math.floor(Math.random() * runeColors.length)]}; animation-duration: ${Math.random() * 8 + 8}s; animation-delay: ${Math.random() * 10}s;`;
                runeContainer.appendChild(r);
            }
        }
    })();
    </script>
    <script src="rpg-bg-canvas.js"></script>
    <script src="characters.js"></script>
    <script src="items.js"></script>
    <script>
        // Game State
        const state = {
            players: [],
            currentPlayerIndex: 0,
            phase: 'setup',
            currentRoll: [],
            hits: [],
            totalDamage: 0,
            hasRolled: false,
            hasAttacked: false,
            damageClaimedPhase: false,
            currentHitIndex: 0,
            remainingHitIndices: [],
            selectedHitIdx: null,
            attackLog: [],
            gameLog: [],
            autoDealDamage: false,
            hasScoreBeenEntered: false,
            itemUsesThisTurn: 0,
            lastDroppedKnifeLogIndex: undefined,
            dropsThisTurn: 0,
            dropsThisTurnLogIndices: [],
            damageDealtThisTurn: false,
            modBuffOnCritical: false,
            modNerfOnMiss: false,
            itemsEnabled: false,
            itemUsePhase: false
        };
        let previousHpByPlayerId = {};

        const projectorChannel = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('daggerdie-projector') : null;

        const PLAYERS_SETUP_KEY = 'daggerdie_playersSetup';

        const BOT_SKILLS = {
            newb:    { min: 1,  max: 15, pct: 0.08 },
            novice:  { min: 15, max: 30, pct: 0.225 },
            skilled: { min: 30, max: 45, pct: 0.375 },
            expert:  { min: 45, max: 75, pct: 0.6 },
            master:  { min: 75, max: 99, pct: 0.87 }
        };
        const BOT_ITEM_AI = {
            newb:    { useChance: 0.22, smartChoiceChance: 0.45 },
            novice:  { useChance: 0.45, smartChoiceChance: 0.65 },
            skilled: { useChance: 0.72, smartChoiceChance: 0.82 },
            expert:  { useChance: 0.88, smartChoiceChance: 0.92 },
            master:  { useChance: 0.96, smartChoiceChance: 0.98 }
        };

        // DOM Elements
        const turnOrderScreen = document.getElementById('turn-order-screen');
        const gameScreen = document.getElementById('game-screen');
        const winnerScreen = document.getElementById('winner-screen');
        const playersPanel = document.getElementById('players-panel');
        const currentPlayerNameEl = document.getElementById('current-player-name');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const diceResults = document.getElementById('dice-results');
        const hitInfo = document.getElementById('hit-info');
        const attackPrompt = document.getElementById('attack-prompt');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const droppedKnifeBtn = document.getElementById('dropped-knife-btn');
        const gameLogEntries = document.getElementById('game-log-entries');

        let botEndTurnTimerId = null;

        const settingsModal = document.getElementById('settings-modal');
        const settingsGearBtn = document.getElementById('settings-gear-btn');
        const useCustomHpCb = document.getElementById('use-custom-hp-cb');
        const customHpInput = document.getElementById('custom-hp-input');
        const modBuffOnCriticalCb = document.getElementById('mod-buff-on-critical-cb');
        const modNerfOnMissCb = document.getElementById('mod-nerf-on-miss-cb');
        const itemsEnabledCb = document.getElementById('items-enabled-cb');
        const persistentSettingsCb = document.getElementById('persistent-settings-cb');
        const settingsModalDone = document.getElementById('settings-modal-done');
        const settingsReadOnlyHint = document.getElementById('settings-readonly-hint');

        useCustomHpCb.addEventListener('change', () => {
            customHpInput.disabled = !useCustomHpCb.checked;
        });

        settingsGearBtn.addEventListener('click', () => {
            const readOnly = state.hasScoreBeenEntered;
            persistentSettingsCb.checked = isPersistentSettings();
            const usePersistent = persistentSettingsCb.checked;
            const useCustom = usePersistent && localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true';
            useCustomHpCb.checked = useCustom;
            if (useCustom) {
                const savedHp = localStorage.getItem(CUSTOM_HP_KEY);
                customHpInput.value = savedHp !== null && savedHp !== '' ? savedHp : '';
            } else {
                customHpInput.value = state.players.length > 0 ? String(getDefaultHp(state.players.length)) : '';
            }
            useCustomHpCb.disabled = readOnly;
            customHpInput.disabled = readOnly || !useCustomHpCb.checked;
            modBuffOnCriticalCb.checked = usePersistent ? (localStorage.getItem(MOD_BUFF_ON_CRITICAL_KEY) === 'true') : false;
            modNerfOnMissCb.checked = usePersistent ? (localStorage.getItem(MOD_NERF_ON_MISS_KEY) === 'true') : false;
            if (itemsEnabledCb) itemsEnabledCb.checked = localStorage.getItem(ITEMS_ENABLED_KEY) === 'true';
            modBuffOnCriticalCb.disabled = readOnly;
            modNerfOnMissCb.disabled = readOnly;
            if (itemsEnabledCb) itemsEnabledCb.disabled = readOnly;
            if (settingsReadOnlyHint) settingsReadOnlyHint.style.display = readOnly ? 'block' : 'none';
            settingsModalDone.textContent = readOnly ? 'Close' : 'Done';
            settingsModal.classList.add('open');
        });

        settingsModalDone.addEventListener('click', () => {
            localStorage.setItem(PERSISTENT_SETTINGS_KEY, String(persistentSettingsCb.checked));
            if (persistentSettingsCb.checked) {
                localStorage.setItem(MOD_BUFF_ON_CRITICAL_KEY, String(modBuffOnCriticalCb.checked));
                localStorage.setItem(MOD_NERF_ON_MISS_KEY, String(modNerfOnMissCb.checked));
                if (itemsEnabledCb) localStorage.setItem(ITEMS_ENABLED_KEY, String(itemsEnabledCb.checked));
                localStorage.setItem(USE_CUSTOM_HP_KEY, String(useCustomHpCb.checked));
                if (useCustomHpCb.checked) {
                    const val = customHpInput.value.trim();
                    const n = val === '' ? NaN : parseInt(val, 10);
                    if (!isNaN(n) && n >= 20 && n <= 999) {
                        localStorage.setItem(CUSTOM_HP_KEY, String(n));
                    }
                } else {
                    localStorage.removeItem(CUSTOM_HP_KEY);
                }
            } else {
                localStorage.removeItem(MOD_BUFF_ON_CRITICAL_KEY);
                localStorage.removeItem(MOD_NERF_ON_MISS_KEY);
                localStorage.removeItem(ITEMS_ENABLED_KEY);
                localStorage.removeItem(USE_CUSTOM_HP_KEY);
                localStorage.removeItem(CUSTOM_HP_KEY);
            }
            state.itemsEnabled = itemsEnabledCb ? itemsEnabledCb.checked : false;
            if (state.hasScoreBeenEntered) {
                settingsModal.classList.remove('open');
                return;
            }
            if (useCustomHpCb.checked) {
                const val = customHpInput.value.trim();
                const n = val === '' ? NaN : parseInt(val, 10);
                if (isNaN(n) || n < 20 || n > 999) {
                    alert('Please enter a value between 20 and 999.');
                    return;
                }
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'true');
                localStorage.setItem(CUSTOM_HP_KEY, String(n));
                if (state.players.length > 0) {
                    state.players.forEach(p => {
                        p.hp = n;
                        p.maxHp = n;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            } else {
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'false');
                if (state.players.length > 0) {
                    const defaultHp = getDefaultHp(state.players.length);
                    state.players.forEach(p => {
                        p.hp = defaultHp;
                        p.maxHp = defaultHp;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            }
            state.modBuffOnCritical = modBuffOnCriticalCb.checked;
            state.modNerfOnMiss = modNerfOnMissCb.checked;
            state.itemsEnabled = itemsEnabledCb ? itemsEnabledCb.checked : false;
            if (itemsEnabledCb && persistentSettingsCb.checked) localStorage.setItem(ITEMS_ENABLED_KEY, String(state.itemsEnabled));
            localStorage.setItem(PERSISTENT_SETTINGS_KEY, String(persistentSettingsCb.checked));
            if (persistentSettingsCb.checked) {
                localStorage.setItem(MOD_BUFF_ON_CRITICAL_KEY, String(state.modBuffOnCritical));
                localStorage.setItem(MOD_NERF_ON_MISS_KEY, String(state.modNerfOnMiss));
                if (useCustomHpCb.checked) {
                    localStorage.setItem(USE_CUSTOM_HP_KEY, 'true');
                    localStorage.setItem(CUSTOM_HP_KEY, String(customHpInput.value.trim()));
                } else {
                    localStorage.setItem(USE_CUSTOM_HP_KEY, 'false');
                }
            } else {
                localStorage.removeItem(MOD_BUFF_ON_CRITICAL_KEY);
                localStorage.removeItem(MOD_NERF_ON_MISS_KEY);
                localStorage.removeItem(USE_CUSTOM_HP_KEY);
                localStorage.removeItem(CUSTOM_HP_KEY);
            }
            settingsModal.classList.remove('open');
        });

        const openProjectorBtn = document.getElementById('open-projector-btn');
        if (openProjectorBtn) {
            openProjectorBtn.addEventListener('click', () => {
                const rolls = (state.currentRoll || []).join(',');
                const claimed = (state.hits || []).map(h => h.roll).join(',');
                const url = 'projector.html?rolls=' + encodeURIComponent(rolls) + '&claimed=' + encodeURIComponent(claimed);
                const features = 'width=534,height=534,menubar=no,toolbar=no,location=no,status=no';
                window.open(url, 'DaggerDieProjector', features);
            });
        }

        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) settingsModal.classList.remove('open');
        });

        const CUSTOM_HP_KEY = 'daggerdie_customHp';
        const USE_CUSTOM_HP_KEY = 'daggerdie_useCustomHp';
        const MOD_BUFF_ON_CRITICAL_KEY = 'daggerdie_modBuffOnCritical';
        const MOD_NERF_ON_MISS_KEY = 'daggerdie_modNerfOnMiss';
        const ITEMS_ENABLED_KEY = 'daggerdie_itemsEnabled';
        const PERSISTENT_SETTINGS_KEY = 'daggerdie_persistentSettings';

        function isPersistentSettings() {
            return localStorage.getItem(PERSISTENT_SETTINGS_KEY) === 'true';
        }

        function applySettingsForNewGame() {
            if (isPersistentSettings()) {
                state.modBuffOnCritical = localStorage.getItem(MOD_BUFF_ON_CRITICAL_KEY) === 'true';
                state.modNerfOnMiss = localStorage.getItem(MOD_NERF_ON_MISS_KEY) === 'true';
                state.itemsEnabled = localStorage.getItem(ITEMS_ENABLED_KEY) === 'true';
            } else {
                state.modBuffOnCritical = false;
                state.modNerfOnMiss = false;
                state.itemsEnabled = localStorage.getItem(ITEMS_ENABLED_KEY) === 'true';
            }
        }

        function getDefaultHp(playerCount) {
            if (isPersistentSettings() && localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true') {
                const custom = localStorage.getItem(CUSTOM_HP_KEY);
                if (custom !== null && custom !== '') {
                    const n = parseInt(custom, 10);
                    if (!isNaN(n) && n >= 20 && n <= 999) return n;
                }
            }
            if (playerCount <= 2) return 50;
            if (playerCount <= 4) return 40;
            return 60; // 5-6 players
        }

        function showTurnOrderScreen() {
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                rollBtn.classList.add('hidden');
            }

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${getPlayerAvatarHtml(p, { size: 30, className: '' })}
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');
        }

        document.getElementById('roll-turn-order-btn').addEventListener('click', async () => {
            const btn = document.getElementById('roll-turn-order-btn');
            btn.disabled = true;

            for (let player of state.players) {
                const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                const rollValue = playerDiv.querySelector('.roll-value');

                for (let i = 0; i < 10; i++) {
                    rollValue.textContent = rollD20();
                    await sleep(50);
                }

                player.turnOrderRoll = rollD20();
                rollValue.textContent = player.turnOrderRoll;
                await sleep(300);
            }

            state.players.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

            const rollsDiv = document.getElementById('turn-order-rolls');
            const tieMessage = document.createElement('p');
            tieMessage.id = 'tie-reroll-message';
            tieMessage.style.cssText = 'color: #feca57; margin: 15px 0; font-weight: bold;';
            tieMessage.style.display = 'none';
            if (!document.getElementById('tie-reroll-message')) {
                rollsDiv.parentNode.insertBefore(tieMessage, rollsDiv.nextSibling);
            }

            function updateTurnOrderDisplay() {
                rollsDiv.innerHTML = state.players.map((p, idx) => `
                    <div class="turn-order-player" data-player="${p.id}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                            ${getPlayerAvatarHtml(p, { size: 30, className: '' })}
                            <span>${p.name}</span>
                        </div>
                        <span class="roll-value">${p.turnOrderRoll}</span>
                    </div>
                `).join('');
            }

            // Find tie groups (consecutive players with same roll) - each resolves independently
            const tieGroupsWithIndex = [];
            for (let i = 0; i < state.players.length; i++) {
                const startIdx = i;
                const group = [state.players[i]];
                while (i + 1 < state.players.length && state.players[i + 1].turnOrderRoll === state.players[i].turnOrderRoll) {
                    group.push(state.players[++i]);
                }
                if (group.length > 1) {
                    tieGroupsWithIndex.push({ startIdx, players: group });
                }
            }

            // Resolve each tie group in isolation - only the tied players reroll for their slots
            for (const { startIdx, players: tiedPlayers } of tieGroupsWithIndex) {
                let hasTieInGroup;
                do {
                    hasTieInGroup = false;
                    tieMessage.textContent = `Tie between ${tiedPlayers.map(p => p.name).join(', ')}! Rerolling for slot...`;
                    tieMessage.style.display = 'block';
                    await sleep(500);

                    for (let player of tiedPlayers) {
                        const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (playerDiv) {
                            const rollValue = playerDiv.querySelector('.roll-value');
                            for (let i = 0; i < 8; i++) {
                                rollValue.textContent = rollD20();
                                await sleep(40);
                            }
                        }
                        player.turnOrderRoll = rollD20();
                        const div = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (div) div.querySelector('.roll-value').textContent = player.turnOrderRoll;
                        await sleep(200);
                    }

                    tiedPlayers.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

                    for (let j = 0; j < tiedPlayers.length - 1; j++) {
                        if (tiedPlayers[j].turnOrderRoll === tiedPlayers[j + 1].turnOrderRoll) {
                            hasTieInGroup = true;
                            break;
                        }
                    }

                    for (let j = 0; j < tiedPlayers.length; j++) {
                        state.players[startIdx + j] = tiedPlayers[j];
                    }
                    updateTurnOrderDisplay();
                    tieMessage.style.display = 'none';
                    await sleep(300);
                } while (hasTieInGroup);
            }

            tieMessage.style.display = 'none';
            await sleep(500);
            rollsDiv.innerHTML = state.players.map((p, idx) => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">${p.turnOrderRoll}</span>
                </div>
            `).join('');

            btn.classList.add('hidden');
            const beginBtn = document.getElementById('begin-game-btn');
            beginBtn.classList.remove('hidden');
            if (localStorage.getItem('daggerdie_autoBeginGame') === 'true') {
                beginBtn.classList.add('hidden');
                setTimeout(() => beginBtn.click(), 500);
            }
        });

        document.getElementById('begin-game-btn').addEventListener('click', () => {
            turnOrderScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            state.phase = 'playing';
            state.currentPlayerIndex = 0;
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.itemUsesThisTurn = 0;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;
            state.itemUsesThisTurn = 0;
            updateGameUI();
        });

        (function initFromCharSelect() {
            const saved = sessionStorage.getItem(PLAYERS_SETUP_KEY);
            if (!saved) {
                window.location.href = 'charselect.html';
                return;
            }
            let payload;
            try {
                payload = JSON.parse(saved);
                sessionStorage.removeItem(PLAYERS_SETUP_KEY);
            } catch (e) {
                window.location.href = 'charselect.html';
                return;
            }
            applySettingsForNewGame();
            const defaultHp = getDefaultHp(payload.length);
            const CHAR_BY_ID = window.DAGGERDIE_CHARACTER_BY_ID || {};
            state.players = payload.map((p, idx) => {
                const hex = p.color || (p.characterId && CHAR_BY_ID[p.characterId] ? CHAR_BY_ID[p.characterId].color : '#8b7355');
                return {
                    id: idx,
                    name: p.name,
                    color: { name: p.characterId && CHAR_BY_ID[p.characterId] ? CHAR_BY_ID[p.characterId].name : 'Custom', hex },
                    characterId: p.characterId || null,
                    hp: defaultHp,
                    maxHp: defaultHp,
                    turnOrderRoll: 0,
                    eliminated: false,
                    totalRolled: 0,
                    totalClaimed: 0,
                    totalThrows: 0,
                    criticals: 0,
                    buffActive: false,
                    nerfActive: false,
                    aimActive: false,
                    aimCalledZone: null,
                    aimBonus: 0,
                    isBot: !!p.isBot,
                    botSkill: p.botSkill && BOT_SKILLS[p.botSkill] ? p.botSkill : 'novice',
                    inventory: [null, null, null],
                    inventoryLocked: [false, false, false],
                    itemStats: { acquired: 0, used: 0, acquiredById: {}, usedById: {} }
                };
            });
            clearHpFeedbackSnapshot();
            state.autoDealDamage = localStorage.getItem('daggerdie_autoDealDamage') === 'true';
            showTurnOrderScreen();
            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                setTimeout(() => document.getElementById('roll-turn-order-btn')?.click(), 400);
            }
        })();

        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCurrentPlayer() {
            return state.players[state.currentPlayerIndex];
        }

        function getAlivePlayers() {
            return state.players.filter(p => !p.eliminated);
        }

        function getPlayerAvatarHtml(p, opts) {
            if (!p) return '';
            const size = (opts && opts.size) || 60;
            const baseClass = (opts && opts.className) || 'player-avatar';
            const CHAR_BY_ID = window.DAGGERDIE_CHARACTER_BY_ID || {};
            const prefixSvgIds = window.DAGGERDIE_PREFIX_SVG_IDS || (s => s);
            const char = p.characterId && CHAR_BY_ID[p.characterId];
            if (char) {
                const svg = prefixSvgIds(char.svg, 'game-p' + p.id);
                return `<div class="${baseClass} player-avatar-char" style="width:${size}px;height:${size}px;flex-shrink:0;overflow:hidden;border-radius:50%;">${svg}</div>`;
            }
            return `<div class="${baseClass}" style="width:${size}px;height:${size}px;background:${p.color.hex};flex-shrink:0;border-radius:50%;"></div>`;
        }

        function ensurePlayerItemStats(player) {
            if (!player) return;
            if (!player.itemStats) player.itemStats = { acquired: 0, used: 0, acquiredById: {}, usedById: {} };
            if (!player.itemStats.acquiredById) player.itemStats.acquiredById = {};
            if (!player.itemStats.usedById) player.itemStats.usedById = {};
        }

        function trackItemAcquired(player, itemId) {
            ensurePlayerItemStats(player);
            player.itemStats.acquired = (player.itemStats.acquired || 0) + 1;
            player.itemStats.acquiredById[itemId] = (player.itemStats.acquiredById[itemId] || 0) + 1;
        }

        function trackItemUsed(player, itemId) {
            ensurePlayerItemStats(player);
            player.itemStats.used = (player.itemStats.used || 0) + 1;
            player.itemStats.usedById[itemId] = (player.itemStats.usedById[itemId] || 0) + 1;
        }

        function isItemLocked(player, slotIdx) {
            if (!player || slotIdx < 0) return false;
            const lock = player.inventoryLocked || [false, false, false];
            return !!lock[slotIdx];
        }

        function getHitEffectiveRoll(hit) {
            if (!hit) return 0;
            return (hit.roll || 0) + (hit.itemBonus || 0);
        }

        function getHitsTotalDamage(hits) {
            return (hits || []).reduce((sum, h) => sum + getHitEffectiveRoll(h), 0);
        }

        function consumeAimForCurrentPlayer(player) {
            if (!player || !player.aimActive || player.aimCalledZone === null) return { hadAim: false, applied: false, bonus: 0, zone: null };
            const zone = player.aimCalledZone;
            const bonus = player.aimBonus || 3;
            const matchingHit = (state.hits || []).find(h => h.roll === zone);
            const applied = !!matchingHit;
            if (matchingHit) matchingHit.itemBonus = (matchingHit.itemBonus || 0) + bonus;
            player.aimActive = false;
            player.aimCalledZone = null;
            player.aimBonus = 0;
            return { hadAim: true, applied, bonus, zone };
        }

        function updateGameUI() {
            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            clearHighlights();
            resetDice();
            diceResults.innerHTML = '';
            hitInfo.innerHTML = '';
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.add('hidden');
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.hits = [];
            state.totalDamage = 0;
            state.currentHitIndex = 0;
            state.remainingHitIndices = [];
            state.selectedHitIdx = null;
            state.attackLog = [];
            state.itemUsesThisTurn = 0;
            rollDiceBtn.disabled = false;
            disableTargetSelection();
            droppedKnifeBtn.classList.add('hidden');

            if (getCurrentPlayer().isBot) {
                rollDiceBtn.classList.add('hidden');
                setTimeout(() => runBotTurn(), 500);
            } else if (localStorage.getItem('daggerdie_autoRollDice') === 'true') {
                rollDiceBtn.classList.add('hidden');
                setTimeout(() => rollDiceBtn.click(), 300);
            } else {
                rollDiceBtn.classList.remove('hidden');
            }
        }

        function runBotTurn() {
            const MAX_SCORES = 3;
            rollDiceBtn.click();
            setTimeout(() => {
                const current = getCurrentPlayer();
                if (!current.isBot || !state.hasRolled) return;
                const skill = BOT_SKILLS[current.botSkill];
                const hitChance = skill ? skill.pct : 0.225;
                state.hits = [];
                for (let idx = 0; idx < state.currentRoll.length; idx++) {
                    if (state.hits.length >= MAX_SCORES) break;
                    if (Math.random() < hitChance) state.hits.push({ roll: state.currentRoll[idx], idx });
                }
                state.totalDamage = getHitsTotalDamage(state.hits);
                if (state.totalDamage > 0) {
                    if (state.hits.length === MAX_SCORES) {
                        current.criticals = (current.criticals || 0) + 1;
                        if (state.modBuffOnCritical) current.buffActive = true;
                        if (state.itemsEnabled && typeof DAGGERDIE_GET_ITEM_BY_D12 === 'function') {
                            const slotIdx = (current.inventory || [null, null, null]).findIndex(s => s === null);
                            if (slotIdx >= 0) {
                                const d12Roll = Math.floor(Math.random() * 12) + 1;
                                const item = DAGGERDIE_GET_ITEM_BY_D12(d12Roll);
                                if (item) {
                                    if (!current.inventory) current.inventory = [null, null, null];
                                    if (!current.inventoryLocked) current.inventoryLocked = [false, false, false];
                                    current.inventory[slotIdx] = item.id;
                                    current.inventoryLocked[slotIdx] = true;
                                    trackItemAcquired(current, item.id);
                                    addLogEntry(`${current.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical! Found ${item.name}!`, 'info');
                                } else {
                                    addLogEntry(`${current.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical!`, 'info');
                                }
                            } else {
                                addLogEntry(`${current.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical! (inventory full)`, 'info');
                            }
                        } else {
                            addLogEntry(`${current.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical!`, 'info');
                        }
                        showCriticalReaction(current.name);
                    } else {
                        addLogEntry(`${current.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')})`, 'info');
                    }
                    if (state.itemsEnabled) {
                        botTryUseOneItem(current);
                    }
                    if (state.phase !== 'playing') return;
                    showTargetSelection();
                } else {
                    addLogEntry(`${current.name} missed all throws.`, 'info');
                    if (state.modNerfOnMiss) current.nerfActive = true;
                    if (state.itemsEnabled) {
                        botTryUseOneItem(current);
                    }
                    if (state.phase !== 'playing') return;
                    showMissReaction();
                    finishTurnNoAttack();
                    if (botEndTurnTimerId) clearTimeout(botEndTurnTimerId);
                    botEndTurnTimerId = setTimeout(() => {
                        botEndTurnTimerId = null;
                        if (getCurrentPlayer().isBot) endTurnBtn.click();
                    }, 1800);
                }
            }, 1100);
        }

        function spawnDeathGhost(cardRect) {
            if (!cardRect || cardRect.width === 0) return;
            const ghost = document.createElement('div');
            ghost.className = 'death-ghost';
            const cx = cardRect.left + cardRect.width / 2;
            const cy = cardRect.top + cardRect.height / 2;
            ghost.style.left = (cx - 30) + 'px';
            ghost.style.top = (cy - 35) + 'px';
            ghost.innerHTML = '<svg viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><path fill="rgba(255,255,255,0.9)" d="M30 5c-12 0-22 10-22 22 0 8 4 15 10 19v12l4-4 4 4v-8l4-4 4 4v8l4-4 4 4v-12c6-4 10-11 10-19 0-12-10-22-22-22z"/><circle cx="22" cy="25" r="4" fill="#1a1a2e"/><circle cx="38" cy="25" r="4" fill="#1a1a2e"/><path fill="#1a1a2e" d="M26 38c0 2 1.5 4 4 4s4-2 4-4c0-1-1-2-4-2s-4 1-4 2z"/></svg>';
            document.body.appendChild(ghost);
            setTimeout(() => ghost.remove(), 1900);
        }

        function clearHpFeedbackSnapshot() {
            previousHpByPlayerId = {};
        }

        function showHpDeltaFeedback(playerId, delta) {
            if (!delta) return;
            const card = playersPanel.querySelector(`.player-card[data-player="${playerId}"]`);
            if (!card) return;
            const isUp = delta > 0;
            card.classList.remove('hp-change-up', 'hp-change-down');
            void card.offsetWidth;
            card.classList.add(isUp ? 'hp-change-up' : 'hp-change-down');
            setTimeout(() => card.classList.remove('hp-change-up', 'hp-change-down'), 600);

            const bubble = document.createElement('div');
            bubble.className = `hp-delta-float ${isUp ? 'up' : 'down'}`;
            bubble.textContent = `${isUp ? '+' : ''}${delta} HP`;
            card.appendChild(bubble);
            setTimeout(() => bubble.remove(), 900);
        }

        function updatePlayersPanel() {
            const currentPlayer = getCurrentPlayer();
            playersPanel.innerHTML = state.players.map(p => `
                <div class="player-card ${p.id === currentPlayer.id ? 'current' : ''} ${p.eliminated ? 'eliminated' : ''} ${p.buffActive ? 'buffed' : ''} ${p.nerfActive ? 'nerfed' : ''} ${(p.shieldActive || (p.shieldTurns || 0) > 0) ? 'shielded' : ''} ${p.focusActive ? 'focused' : ''} ${p.rageActive ? 'enraged' : ''} ${((p.regenTurns || 0) > 0 && (p.regenRemaining || 0) > 0) ? 'regening' : ''} ${((p.poisonTurns || 0) > 0 && (p.poisonRemaining || 0) > 0) ? 'poisoned' : ''} ${(p.freeDropsActive || (p.freeDropsCount || 0) > 0) ? 'free-drops' : ''} ${(p.aimActive && p.aimCalledZone !== null) ? 'aiming' : ''}"
                     data-player="${p.id}">
                    <button type="button" class="player-card-stats-btn" data-player="${p.id}" aria-label="Stats and drops">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    </button>
                    ${getPlayerAvatarHtml(p)}
                    <div class="player-name">${p.name}</div>
                    <div class="player-hp">${p.hp} HP</div>
                    <div class="hp-bar">
                        <div class="hp-fill" style="width: ${(p.hp / p.maxHp) * 100}%; background: ${p.color.hex};"></div>
                    </div>
                    <div class="player-turn-order">Turn Order: #${state.players.indexOf(p) + 1}</div>
                    ${p.isBot ? '<div class="player-card-bot-skill" data-player="'+p.id+'">Bot: ' + capitalizeBotSkill(p.botSkill) + '</div>' : ''}
                    ${getPlayerStatusEffectsForItemModal(p).map(s => '<div class="player-card-status ' + s.kind + '">' + s.label + '</div>').join('')}
                    ${state.itemsEnabled ? '<div class="player-card-inventory" data-player="'+p.id+'">' + [0,1,2].map(i => { const inv = p.inventory || [null,null,null]; const lock = p.inventoryLocked || [false,false,false]; const itemId = inv[i]; const ITEM = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null; return '<div class="player-card-inventory-slot ' + (ITEM ? 'has-item' : '') + (ITEM && lock[i] ? ' locked-item' : '') + '" data-player="'+p.id+'" data-slot="'+i+'" title="' + (ITEM ? (lock[i] ? ITEM.name + ': usable next turn' : ITEM.name + ': ' + ITEM.effect) : 'Empty') + '">' + (ITEM ? ITEM.svg : '') + '</div>'; }).join('') + '</div>' : ''}
                </div>
            `).join('');
            state.players.forEach(p => {
                const prevHp = previousHpByPlayerId[p.id];
                if (typeof prevHp === 'number' && prevHp !== p.hp) {
                    showHpDeltaFeedback(p.id, p.hp - prevHp);
                }
                previousHpByPlayerId[p.id] = p.hp;
            });
        }

        function capitalizeBotSkill(s) {
            return s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
        }

        function updateCurrentPlayerDisplay() {
            const current = getCurrentPlayer();
            currentPlayerNameEl.textContent = current.name;
            currentPlayerNameEl.style.color = current.color.hex;
        }

        rollDiceBtn.addEventListener('click', async () => {
            if (state.hasRolled) return;

            rollDiceBtn.disabled = true;
            const dice = [
                document.getElementById('die1'),
                document.getElementById('die2'),
                document.getElementById('die3')
            ];

            dice.forEach(die => {
                die.classList.add('rolling');
                die.classList.remove('odd', 'even');
            });

            for (let i = 0; i < 15; i++) {
                dice.forEach(die => {
                    die.textContent = rollD20();
                });
                await sleep(50);
            }

            state.currentRoll = [rollD20(), rollD20(), rollD20()];
            state.hits = [];
            state.totalDamage = 0;
            state.damageClaimedPhase = false;

            dice.forEach((die, idx) => {
                die.classList.remove('rolling');
                const value = state.currentRoll[idx];
                die.textContent = value;
                die.classList.add(value % 2 === 0 ? 'even' : 'odd');
            });

            highlightTargets(state.currentRoll);
            displayRollResults();

            state.hasRolled = true;
            const current = getCurrentPlayer();
            addLogEntry(`${current.name} throws: ${state.currentRoll.join(', ')}.`, 'info');
            current.totalRolled = (current.totalRolled || 0) + state.currentRoll.reduce((s, v) => s + v, 0);
            current.totalThrows = (current.totalThrows || 0) + 3;
            showHitRecorder();
            droppedKnifeBtn.classList.remove('hidden');
        });

        function highlightTargets(rolls) {
            clearHighlights();
            rolls.forEach(roll => {
                const zone = document.querySelector(`.highlight-zone[data-number="${roll}"]`);
                if (zone) {
                    zone.classList.add('active');
                }
            });
            const aimZone = syncAimHighlights();
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'roll', rolls: state.currentRoll, aim: aimZone });
            } catch (e) {}
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                zone.classList.remove('active');
                zone.classList.remove('aimed');
            });
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'clear' });
            } catch (e) {}
        }

        function getCurrentAimZone() {
            const current = getCurrentPlayer();
            if (!current || !current.aimActive || current.aimCalledZone === null) return null;
            return current.aimCalledZone;
        }

        function syncAimHighlights() {
            const aimZone = getCurrentAimZone();
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                const num = parseInt(zone.getAttribute('data-number'), 10);
                zone.classList.toggle('aimed', aimZone !== null && num === aimZone);
            });
            return aimZone;
        }

        document.addEventListener('click', (e) => {
            const zone = e.target.closest('.highlight-zone');
            if (!zone) return;
            const overlay = zone.closest('.target-overlay');
            if (!overlay || !overlay.classList.contains('clickable')) return;
            const number = parseInt(zone.getAttribute('data-number'));
            if (!state.currentRoll.includes(number)) return;

            const rollIndices = state.currentRoll.map((r, i) => r === number ? i : -1).filter(i => i >= 0);
            const hitIndicesForNumber = new Set(state.hits.filter(h => h.roll === number).map(h => h.idx));
            const firstUnclaimed = rollIndices.find(idx => !hitIndicesForNumber.has(idx));
            if (firstUnclaimed !== undefined) {
                const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                if (state.hits.length >= slotsLeft) return;
                state.hits.push({ roll: number, idx: firstUnclaimed });
            } else {
                const toRemove = state.hits.find(h => h.roll === number);
                if (toRemove) state.hits = state.hits.filter(h => h !== toRemove);
            }
            syncHitRecorderUI();
        });

        function displayRollResults() {
            diceResults.innerHTML = `
                <p>Rolled: <strong>${state.currentRoll.join(', ')}</strong></p>
                <p>Odd targets: <span style="color: #ff6b6b;">${state.currentRoll.filter(r => r % 2 === 1).join(', ') || 'None'}</span></p>
                <p>Even targets: <span style="color: #48dbfb;">${state.currentRoll.filter(r => r % 2 === 0).join(', ') || 'None'}</span></p>
            `;
        }

        const MAX_SCORES_PER_TURN = 3;

        function syncHitRecorderUI() {
            const hitIdxSet = new Set(state.hits.map(h => h.idx));
            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                const idx = parseInt(btn.dataset.idx);
                if (hitIdxSet.has(idx)) {
                    btn.classList.add('hit');
                    btn.style.background = '#2ecc71';
                } else {
                    btn.classList.remove('hit');
                    btn.style.background = '';
                }
            });
            const totalDamageEl = document.getElementById('total-damage-display');
            if (totalDamageEl) totalDamageEl.textContent = getHitsTotalDamage(state.hits);
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                const num = parseInt(zone.getAttribute('data-number'));
                const claimedForNumber = state.hits.some(h => h.roll === num);
                zone.classList.toggle('claimed', claimedForNumber);
            });
            const aimZone = syncAimHighlights();
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'update', rolls: state.currentRoll, claimed: (state.hits || []).map(h => h.roll), aim: aimZone });
            } catch (e) {}
        }

        function showHitRecorder(initialHits) {
            const currentPlayer = getCurrentPlayer();
            droppedKnifeBtn.classList.remove('hidden');

            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice() : [];

            const maxDiceScores = Math.max(0, MAX_SCORES_PER_TURN - state.dropsThisTurn);
            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice(0, maxDiceScores) : [];

            attackPrompt.classList.remove('hidden');
            attackPrompt.innerHTML = `<strong>Step 1:</strong> Throw your knives! Tap the target numbers you HIT, or use the buttons below (max 3 scores per turn).`;

            const hitIdxSet = new Set(state.hits.map(h => h.idx));

            hitInfo.innerHTML = `
                <div style="width: 100%; text-align: center; margin-bottom: 15px;">
                    <p style="font-size: 1.1rem;">Tap the <strong>highlighted targets</strong> or buttons below to claim hits (max 3 per turn):</p>
                </div>
                <div style="margin-bottom: 12px; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                    <div class="scores-counter" style="font-size: 0.9rem; opacity: 0.9;">Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}</div>
                    <p style="font-size: 1.3rem; margin: 0;">Damage Claimed: <strong id="total-damage-display" style="color: #feca57; font-size: 1.5rem;">${getHitsTotalDamage(state.hits)}</strong></p>
                </div>
                <div class="hit-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    ${state.currentRoll.map((roll, idx) => `
                        <button class="btn hit-toggle ${hitIdxSet.has(idx) ? 'hit' : ''}" data-roll="${roll}" data-idx="${idx}" style="min-width: 70px; font-size: 1.3rem; ${hitIdxSet.has(idx) ? 'background: #2ecc71;' : ''}">
                            ${roll}
                        </button>
                    `).join('')}
                </div>
                <div style="margin-top: 12px;">
                    <button class="btn btn-primary" id="confirm-hits-btn">Confirm</button>
                </div>
            `;

            document.getElementById('odd-overlay').classList.add('clickable');
            document.getElementById('even-overlay').classList.add('clickable');
            syncHitRecorderUI();

            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    const roll = parseInt(btn.dataset.roll);
                    const idx = parseInt(btn.dataset.idx);

                    if (btn.classList.contains('hit')) {
                        state.hits = state.hits.filter(h => h.idx !== idx);
                    } else {
                        const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                        if (state.hits.length >= slotsLeft) return;
                        state.hits.push({ roll, idx });
                    }
                    syncHitRecorderUI();
                });
            });

            document.getElementById('confirm-hits-btn').addEventListener('click', () => {
                state.totalDamage = getHitsTotalDamage(state.hits);
                showDamageConfirmModal(`Total damage: ${state.totalDamage}`, () => {
                    document.getElementById('odd-overlay').classList.remove('clickable');
                    document.getElementById('even-overlay').classList.remove('clickable');

                    if (state.totalDamage > 0) {
                        const aimResult = consumeAimForCurrentPlayer(currentPlayer);
                        if (aimResult.applied) {
                            addLogEntry(`${currentPlayer.name} called ${aimResult.zone} — Aim success! (+${aimResult.bonus} DP)`, 'info');
                        } else if (aimResult.hadAim) {
                            addLogEntry(`${currentPlayer.name} called ${aimResult.zone} — Aim missed.`, 'info');
                        }
                        syncHitRecorderUI();
                        state.totalDamage = getHitsTotalDamage(state.hits);
                        const isCritical = state.hits.length === MAX_SCORES_PER_TURN;
                        let acquiredItem = null;
                        let d12Roll = null;
                        if (isCritical) {
                            currentPlayer.criticals = (currentPlayer.criticals || 0) + 1;
                            if (state.modBuffOnCritical) currentPlayer.buffActive = true;
                            if (state.itemsEnabled && typeof DAGGERDIE_GET_ITEM_BY_D12 === 'function') {
                                const slotIdx = (currentPlayer.inventory || [null,null,null]).findIndex(s => s === null);
                                if (slotIdx >= 0) {
                                    d12Roll = Math.floor(Math.random() * 12) + 1;
                                    const item = DAGGERDIE_GET_ITEM_BY_D12(d12Roll);
                                    if (item) {
                                        if (!currentPlayer.inventory) currentPlayer.inventory = [null, null, null];
                                    if (!currentPlayer.inventoryLocked) currentPlayer.inventoryLocked = [false, false, false];
                                        currentPlayer.inventory[slotIdx] = item.id;
                                    currentPlayer.inventoryLocked[slotIdx] = true;
                                        trackItemAcquired(currentPlayer, item.id);
                                        acquiredItem = item;
                                        addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical! Found ${item.name}!`, 'info');
                                    } else {
                                        addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical!`, 'info');
                                    }
                                } else {
                                    addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical! (inventory full)`, 'info');
                                }
                            } else {
                                addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')}) — Critical!`, 'info');
                            }
                            showCriticalReaction(currentPlayer.name);
                        } else {
                            addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => getHitEffectiveRoll(h)).join(', ')})`, 'info');
                        }
                        // Reflect critical rewards/buffs in UI immediately after confirm.
                        updatePlayersPanel();
                        const proceedAfterCritical = () => {
                            showTargetSelection();
                        };
                        if (acquiredItem && d12Roll !== null && !currentPlayer.isBot && !state.autoDealDamage) {
                            showCriticalItemModal(d12Roll, acquiredItem, proceedAfterCritical);
                        } else {
                            proceedAfterCritical();
                        }
                    } else {
                        const aimResult = consumeAimForCurrentPlayer(currentPlayer);
                        if (aimResult.hadAim) addLogEntry(`${currentPlayer.name} called ${aimResult.zone} — Aim missed.`, 'info');
                        showMissModal(currentPlayer);
                    }
                });
            });
        }

        const criticalItemModal = document.getElementById('critical-item-modal');
        const criticalItemDisplay = document.getElementById('critical-item-display');
        const criticalItemDismissBtn = document.getElementById('critical-item-dismiss-btn');
        let criticalItemProceedCallback = null;

        function showCriticalItemModal(d12Roll, item, onDismiss) {
            criticalItemProceedCallback = onDismiss;
            criticalItemDisplay.innerHTML = `
                <div class="critical-item-roll">D12 Roll: ${d12Roll}</div>
                <div class="item-use-icon-wrap" style="--accent:${item.accent}">${item.svg}</div>
                <div class="critical-item-name" style="color: var(--accent,${item.accent});">${item.name}</div>
                <div class="critical-item-effect">${item.effect}</div>
                <div class="critical-item-type">${item.type}</div>
            `;
            criticalItemModal.classList.add('open');
        }

        function closeCriticalItemModal() {
            criticalItemModal.classList.remove('open');
            if (criticalItemProceedCallback) {
                const cb = criticalItemProceedCallback;
                criticalItemProceedCallback = null;
                cb();
            }
        }

        criticalItemDismissBtn.addEventListener('click', closeCriticalItemModal);
        criticalItemModal.addEventListener('click', (e) => { if (e.target === criticalItemModal) closeCriticalItemModal(); });

        const damageConfirmModal = document.getElementById('damage-confirm-modal');
        const damageConfirmRolls = document.getElementById('damage-confirm-rolls');
        const damageConfirmDetail = document.getElementById('damage-confirm-detail');
        const damageConfirmYesBtn = document.getElementById('damage-confirm-yes-btn');
        const damageConfirmEditBtn = document.getElementById('damage-confirm-edit-btn');
        let damageConfirmCallback = null;

        function showDamageConfirmModal(detailText, onYes) {
            damageConfirmDetail.textContent = detailText || 'Continue?';
            if (damageConfirmRolls) {
                const rolls = (state.hits || []).map(h => h.roll);
                damageConfirmRolls.innerHTML = rolls.length > 0
                    ? rolls.map(v => `<span class="confirm-roll-pill">${v}</span>`).join('')
                    : '<span class="confirm-roll-pill">No hits</span>';
            }
            damageConfirmCallback = onYes;
            damageConfirmModal.classList.add('open');
        }

        function closeDamageConfirmModal() {
            damageConfirmModal.classList.remove('open');
            damageConfirmCallback = null;
        }

        damageConfirmYesBtn.addEventListener('click', () => {
            const cb = damageConfirmCallback;
            closeDamageConfirmModal();
            if (cb) cb();
        });
        damageConfirmEditBtn.addEventListener('click', closeDamageConfirmModal);
        damageConfirmModal.addEventListener('click', (e) => { if (e.target === damageConfirmModal) closeDamageConfirmModal(); });

        function showItemUsePhase() {
            state.itemUsePhase = true;
            attackPrompt.innerHTML = `<strong>Step 2:</strong> Use items (optional) — Open your player card to use items, then assign hits.`;
            hitInfo.innerHTML = `
                <div style="background: rgba(254,202,87,0.15); padding: 12px; border-radius: 10px; border: 2px solid #feca57; margin-bottom: 12px;">
                    <p style="margin-bottom: 8px;">Hits to assign: <strong>${state.hits.map(h => h.roll).join(', ')}</strong></p>
                    <p style="margin: 0; opacity: 0.9;">Open your player card to use items, then click an opponent to assign each hit.</p>
                </div>
            `;
        }

        function showTargetSelection() {
            droppedKnifeBtn.classList.add('hidden');
            state.itemUsePhase = false;
            state.damageClaimedPhase = true;
            state.currentHitIndex = 0;
            state.remainingHitIndices = state.hits.map((_, idx) => idx);
            state.selectedHitIdx = state.remainingHitIndices.length > 0 ? state.remainingHitIndices[0] : null;
            state.attackLog = [];
            state.attackAssignments = [];

            if (getCurrentPlayer().isBot || state.autoDealDamage) {
                autoDealDamageAndFinish();
                return;
            }
            showNextHitToAssign();
        }

        function getEffectiveDamage(roll, targetPlayer, attacker, hitRoll) {
            let damage = roll;
            let modNote = '';
            let modLabel = '';
            if (targetPlayer.shieldActive || (targetPlayer.shieldTurns || 0) > 0) {
                damage = 0;
                modNote = ' (shield: blocked!)';
                modLabel = ', shield';
            } else if (state.modBuffOnCritical && targetPlayer.buffActive) {
                damage = Math.ceil(roll / 2);
                modNote = ' (buff: half)';
                modLabel = ', buff';
            } else if (state.modNerfOnMiss && targetPlayer.nerfActive) {
                damage = Math.ceil(roll * 1.25);
                modNote = ' (nerf: 125%)';
                modLabel = ', nerf';
            }
            if (damage > 0 && attacker) {
                if (attacker.focusActive) {
                    damage += (attacker.focusBonus || 5);
                    attacker.focusActive = false;
                    modNote += ' (focus +5)';
                    modLabel += ', focus';
                }
                if (attacker.rageActive && state.hits && hitRoll === Math.max(...state.hits.map(h => getHitEffectiveRoll(h)))) {
                    damage += (attacker.rageBonus || 5);
                    modNote += ' (rage +5)';
                    modLabel += ', rage';
                }
            }
            return { damage, modNote, modLabel };
        }

        function autoDealDamageAndFinish() {
            const currentPlayer = getCurrentPlayer();
            state.damageDealtThisTurn = true;
            for (let i = 0; i < state.hits.length; i++) {
                const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
                if (aliveOpponents.length === 0) break;
                const currentHit = state.hits[i];
                const currentHitValue = getHitEffectiveRoll(currentHit);
                const targetPlayer = aliveOpponents[Math.floor(Math.random() * aliveOpponents.length)];
                const { damage, modNote, modLabel } = getEffectiveDamage(currentHitValue, targetPlayer, currentPlayer, currentHitValue);
                state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHitValue, damage });
                targetPlayer.hp = Math.max(0, targetPlayer.hp - damage);
                state.hasScoreBeenEntered = true;
                currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHitValue;
                addLogEntry(`${currentPlayer.name} dealt ${damage} damage to ${targetPlayer.name}!${modNote}`, 'damage');
                state.attackLog.push(damage !== currentHitValue ? `${currentHitValue} → ${targetPlayer.name} (${damage}${modLabel})` : `${currentHitValue} → ${targetPlayer.name}`);
                if (targetPlayer.hp <= 0) {
                    const card = document.querySelector(`.player-card[data-player="${targetPlayer.id}"]`);
                    const rect = card ? card.getBoundingClientRect() : null;
                    targetPlayer.eliminated = true;
                    addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
                    updatePlayersPanel();
                    spawnDeathGhost(rect);
                } else {
                    updatePlayersPanel();
                }
                checkWinCondition();
            }
            finishAttackPhase();
        }

        function showNextHitToAssign() {
            const currentPlayer = getCurrentPlayer();

            if (!state.remainingHitIndices || state.remainingHitIndices.length === 0) {
                finishAttackPhase();
                return;
            }

            const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
            if (aliveOpponents.length === 0) {
                finishAttackPhase();
                return;
            }

            if (!state.remainingHitIndices.includes(state.selectedHitIdx)) {
                state.selectedHitIdx = state.remainingHitIndices[0];
            }
            const currentHit = state.hits[state.selectedHitIdx];
            const currentHitValue = getHitEffectiveRoll(currentHit);
            const remainingHits = state.remainingHitIndices.map(hitIdx => ({
                ...state.hits[hitIdx],
                hitIdx
            }));
            state.currentHitIndex = state.hits.length - state.remainingHitIndices.length;

            attackPrompt.innerHTML = `<strong>Step 2:</strong> Assign hit <span style="color: #feca57; font-size: 1.3rem;">${currentHitValue}</span> damage - Click an opponent to attack!`;

            hitInfo.innerHTML = `
                <div class="editable-hits-box" id="editable-hits-box" style="background: rgba(46, 204, 113, 0.2); padding: 10px; border-radius: 10px; border: 2px solid #2ecc71; margin-bottom: 10px; transition: background 0.2s, border-color 0.2s;">
                    <p style="margin-bottom: 5px; font-size: 0.9rem;">Hits to assign <span style="font-size: 0.8rem; opacity: 0.8;">(tap value to select)</span>:</p>
                    <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        ${remainingHits.map((h) => `
                            <button type="button" class="assignable-hit" data-hit-idx="${h.hitIdx}" style="
                                padding: 8px 15px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 1.2rem;
                                border: none;
                                cursor: pointer;
                                background: ${h.hitIdx === state.selectedHitIdx ? '#feca57' : 'rgba(255,255,255,0.2)'};
                                color: ${h.hitIdx === state.selectedHitIdx ? '#1a1a2e' : '#fff'};
                                ${h.hitIdx === state.selectedHitIdx ? 'box-shadow: 0 0 10px rgba(254,202,87,0.5);' : ''}
                            ">${getHitEffectiveRoll(h)}</button>
                        `).join('')}
                    </div>
                </div>
                ${state.attackLog.length > 0 ? `
                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 5px;">
                        ${state.attackLog.join('<br>')}
                    </div>
                ` : ''}
            `;

            hitInfo.querySelectorAll('.assignable-hit').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const selectedHitIdx = parseInt(btn.dataset.hitIdx, 10);
                    if (isNaN(selectedHitIdx) || selectedHitIdx === state.selectedHitIdx) return;
                    if (!state.remainingHitIndices.includes(selectedHitIdx)) return;
                    state.selectedHitIdx = selectedHitIdx;
                    showNextHitToAssign();
                });
            });

            enableTargetSelection();
        }

        function enableTargetSelection() {
            const current = getCurrentPlayer();
            const cards = document.querySelectorAll('.player-card');

            cards.forEach(card => {
                const playerId = parseInt(card.dataset.player);
                const player = state.players.find(p => p.id === playerId);

                if (!player.eliminated && player.id !== current.id) {
                    card.classList.add('targetable');
                    card.addEventListener('click', handleAttack);
                }
            });
        }

        function disableTargetSelection() {
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('targetable');
                card.removeEventListener('click', handleAttack);
            });
        }

        function handleAttack(e) {
            const card = e.currentTarget;
            const playerId = parseInt(card.dataset.player);
            const targetPlayer = state.players.find(p => p.id === playerId);
            const currentPlayer = getCurrentPlayer();
            const selectedHitIdx = state.selectedHitIdx;
            if (selectedHitIdx === null || !state.remainingHitIndices.includes(selectedHitIdx)) return;
            const currentHit = state.hits[selectedHitIdx];
            const currentHitValue = getHitEffectiveRoll(currentHit);
            state.damageDealtThisTurn = true;
            const { damage, modNote, modLabel } = getEffectiveDamage(currentHitValue, targetPlayer, currentPlayer, currentHitValue);

            disableTargetSelection();

            state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHitValue, damage });
            targetPlayer.hp = Math.max(0, targetPlayer.hp - damage);
            state.hasScoreBeenEntered = true;
            currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHitValue;
            addLogEntry(`${currentPlayer.name} dealt ${damage} damage to ${targetPlayer.name}!${modNote}`, 'damage');
            state.attackLog.push(damage !== currentHitValue ? `${currentHitValue} → ${targetPlayer.name} (${damage}${modLabel})` : `${currentHitValue} → ${targetPlayer.name}`);

            if (targetPlayer.hp <= 0) {
                const card = document.querySelector(`.player-card[data-player="${targetPlayer.id}"]`);
                const rect = card ? card.getBoundingClientRect() : null;
                targetPlayer.eliminated = true;
                addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
                updatePlayersPanel();
                spawnDeathGhost(rect);
            } else {
                updatePlayersPanel();
            }
            checkWinCondition();

            state.remainingHitIndices = state.remainingHitIndices.filter(idx => idx !== selectedHitIdx);
            state.selectedHitIdx = state.remainingHitIndices.length > 0 ? state.remainingHitIndices[0] : null;
            state.currentHitIndex = state.hits.length - state.remainingHitIndices.length;

            if (state.phase === 'playing') {
                showNextHitToAssign();
            }
        }

        function finishAttackPhase() {
            const totalDealt = getHitsTotalDamage(state.hits);

            hitInfo.innerHTML = `
                <div style="background: rgba(255, 107, 107, 0.2); padding: 15px; border-radius: 10px; border: 2px solid #ff6b6b;">
                    <p style="font-size: 1.1rem; margin-bottom: 8px;">Attacks Complete!</p>
                    <div style="font-size: 0.9rem;">
                        ${state.attackLog.map(log => `<div>${log}</div>`).join('')}
                    </div>
                    <p style="margin-top: 8px;">Total Damage: <strong style="color: #ff6b6b;">${totalDealt}</strong></p>
                </div>
            `;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
            if (getCurrentPlayer().isBot) {
                if (botEndTurnTimerId) clearTimeout(botEndTurnTimerId);
                botEndTurnTimerId = setTimeout(() => {
                    botEndTurnTimerId = null;
                    if (getCurrentPlayer().isBot) endTurnBtn.click();
                }, 2200);
            }
        }

        function finishTurnNoAttack() {
            droppedKnifeBtn.classList.add('hidden');
            state.damageDealtThisTurn = true;
            hitInfo.innerHTML = `<span class="hit-badge miss">No damage this turn</span>`;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        droppedKnifeBtn.addEventListener('click', () => {
            const MAX_SCORES_PER_TURN = 3;
            if (state.hits.length + state.dropsThisTurn >= MAX_SCORES_PER_TURN) {
                return;
            }
            const current = getCurrentPlayer();
            const freeDrop = state.itemsEnabled && ((current.freeDropsCount || 0) > 0);
            if (!freeDrop) {
                current.hp = Math.max(0, current.hp - 1);
            } else {
                current.freeDropsCount = Math.max(0, (current.freeDropsCount || 0) - 1);
                if (current.freeDropsCount === 0) current.freeDropsActive = false;
            }
            state.hasScoreBeenEntered = true;
            state.dropsThisTurn++;
            addLogEntry(`${current.name} dropped a knife!` + (freeDrop ? ' (free)' : ' (-1 HP)'), 'damage');
            state.lastDroppedKnifeLogIndex = state.gameLog.length - 1;
            if (!state.damageDealtThisTurn) state.dropsThisTurnLogIndices.push(state.gameLog.length - 1);
            updatePlayersPanel();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;

            requestAnimationFrame(() => {
                const card = document.querySelector(`.player-card[data-player="${current.id}"]`);
                if (card) {
                    card.classList.add('player-card-dropped');
                    setTimeout(() => card.classList.remove('player-card-dropped'), 600);
                }
            });

            if (current.hp <= 0) {
                const card = document.querySelector(`.player-card[data-player="${current.id}"]`);
                const rect = card ? card.getBoundingClientRect() : null;
                current.eliminated = true;
                addLogEntry(`${current.name} has been eliminated!`, 'info');
                updatePlayersPanel();
                spawnDeathGhost(rect);
                checkWinCondition();
                if (state.phase === 'playing') {
                    nextTurn();
                }
            }
        });

        const playerStatsModal = document.getElementById('player-stats-modal');
        const playerStatsTitle = document.getElementById('player-stats-title');
        const playerStatsAvatar = document.getElementById('player-stats-avatar');
        const playerStatsHp = document.getElementById('player-stats-hp');
        const playerStatsTurnOrder = document.getElementById('player-stats-turn-order');
        const playerStatsStatus = document.getElementById('player-stats-status');
        const playerStatsHitDrop = document.getElementById('player-stats-hit-drop');
        const playerStatsRolledClaimed = document.getElementById('player-stats-rolled-claimed');
        const playerStatsCritical = document.getElementById('player-stats-critical');
        const playerStatsDropsHint = document.getElementById('player-stats-drops-hint');
        const playerStatsUndoDropBtn = document.getElementById('player-stats-undo-drop-btn');
        const playerStatsCloseBtn = document.getElementById('player-stats-close-btn');

        let playerStatsModalPlayerId = null;

        function openPlayerStatsModal(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (!player) return;
            playerStatsModalPlayerId = playerId;
            playerStatsTitle.textContent = player.name;
            playerStatsAvatar.innerHTML = getPlayerAvatarHtml(player, { size: 64, className: '' });
            playerStatsHp.textContent = `${player.hp} / ${player.maxHp} HP`;
            playerStatsTurnOrder.textContent = `Turn order: #${state.players.indexOf(player) + 1}`;
            const statuses = getPlayerStatusEffectsForItemModal(player).map(s => s.label);
            if (statuses.length > 0) {
                playerStatsStatus.textContent = `Status: ${statuses.join(', ')}`;
                if (statuses.includes('Eliminated') || statuses.some(s => s.startsWith('Poison') || s === 'Nerf')) {
                    playerStatsStatus.style.color = '#e74c3c';
                } else if (statuses.some(s => s === 'Buff' || s.startsWith('Regen'))) {
                    playerStatsStatus.style.color = '#2ecc71';
                } else {
                    playerStatsStatus.style.color = '#48dbfb';
                }
            } else {
                playerStatsStatus.textContent = 'Status: In Battle';
                playerStatsStatus.style.color = '#48dbfb';
            }

            const hitCount = state.gameLog.filter(e =>
                e.type === 'damage' &&
                e.message.startsWith(`${player.name} dealt `) &&
                e.message.includes(' damage to ')
            ).length;
            const throws = player.totalThrows || 0;
            if (throws > 0) {
                const hitPct = (hitCount / throws * 100).toFixed(1);
                playerStatsHitDrop.textContent = `Efficiency: ${hitCount}/${throws} (${hitPct}%)`;
            } else {
                playerStatsHitDrop.textContent = 'Efficiency: —';
            }

            const rolled = player.totalRolled || 0;
            const claimed = player.totalClaimed || 0;
            if (rolled > 0) {
                const pct = (claimed / rolled * 100).toFixed(1);
                playerStatsRolledClaimed.textContent = `Points: ${claimed}/${rolled} (${pct}%)`;
            } else {
                playerStatsRolledClaimed.textContent = 'Points: —';
            }

            playerStatsCritical.textContent = `Criticals: ${player.criticals || 0}`;

            const current = getCurrentPlayer();
            const undoableCount = !state.damageDealtThisTurn && current.id === player.id ? state.dropsThisTurnLogIndices.length : 0;
            const canUndoDrop = undoableCount > 0;

            const dropCount = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(player.name)).length;
            playerStatsDropsHint.textContent = dropCount === 0 ? 'No drops this game.' : `${dropCount} drop(s) this game.`;
            playerStatsUndoDropBtn.style.display = canUndoDrop ? 'block' : 'none';
            playerStatsUndoDropBtn.textContent = undoableCount === 1 ? 'Undo last drop' : `Undo last drop (${undoableCount} undoable)`;

            const invSection = document.getElementById('player-stats-inventory-section');
            const invContainer = document.getElementById('player-stats-inventory');
            const invHint = document.getElementById('player-stats-inventory-hint');
            if (invSection && invContainer && state.itemsEnabled) {
                invSection.style.display = 'block';
                const inv = player.inventory || [null, null, null];
                const canUseItems = canPlayerUseItemsNow(player.id);
                invContainer.innerHTML = [0,1,2].map(i => {
                    const itemId = inv[i];
                    const locked = isItemLocked(player, i);
                    const ITEM = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null;
                    return '<div class="inv-slot ' + (ITEM ? 'has-item' : '') + (ITEM && locked ? ' locked-item' : '') + '" data-player="'+playerId+'" data-slot="' + i + '" title="' + (ITEM ? (locked ? ITEM.name + ': usable next turn' : ITEM.name + ': ' + ITEM.effect) : 'Empty') + '" ' + (ITEM && !locked ? 'style="cursor:pointer"' : '') + '>' + (ITEM ? ITEM.svg : '') + '</div>';
                }).join('');
                invHint.textContent = canUseItems ? 'Tap an item to use it (max 1 per turn). Newly found items unlock next turn.' : 'Items can be used once per turn on your turn before score confirmation.';
            } else if (invSection) {
                invSection.style.display = 'none';
            }
            playerStatsModal.classList.add('open');
        }

        function closePlayerStatsModal() {
            playerStatsModal.classList.remove('open');
            playerStatsModalPlayerId = null;
        }

        playerStatsCloseBtn.addEventListener('click', closePlayerStatsModal);
        playerStatsModal.addEventListener('click', (e) => { if (e.target === playerStatsModal) closePlayerStatsModal(); });

        function canPlayerUseItemsNow(playerId) {
            if (!state.itemsEnabled || state.autoDealDamage) return false;
            const current = getCurrentPlayer();
            if (!current || current.id !== playerId || current.isBot || current.eliminated) return false;
            // Items are usable only before score confirmation, max 1 use per turn.
            return !state.damageClaimedPhase && !state.damageDealtThisTurn && state.itemUsesThisTurn < 1;
        }

        const invContainer = document.getElementById('player-stats-inventory');
        if (invContainer) {
            invContainer.addEventListener('click', (e) => {
                const slot = e.target.closest('.inv-slot.has-item');
                if (!slot) return;
                const pid = playerStatsModalPlayerId;
                if (pid === null) return;
                if (!canPlayerUseItemsNow(pid)) return;
                e.stopPropagation();
                const slotIdx = parseInt(slot.dataset.slot, 10);
                const playerId = parseInt(slot.dataset.player, 10);
                if (!isNaN(slotIdx) && !isNaN(playerId)) openItemUseModal(playerId, slotIdx);
            });
        }

        const itemUseModal = document.getElementById('item-use-modal');
        const itemUseTitle = document.getElementById('item-use-title');
        const itemUseDetail = document.getElementById('item-use-detail');
        const itemUseTargets = document.getElementById('item-use-targets');
        const itemUseCancelBtn = document.getElementById('item-use-cancel-btn');
        let itemUseContext = null; // { playerId, slotIdx, itemId }

        function getPlayerStatusEffectsForItemModal(player) {
            const statuses = [];
            if (player.eliminated) statuses.push({ label: 'Eliminated', kind: 'eliminated' });
            if (player.buffActive) statuses.push({ label: 'Buff', kind: 'buff' });
            if (player.nerfActive) statuses.push({ label: 'Nerf', kind: 'nerf' });
            if (player.shieldActive) statuses.push({ label: 'Shield', kind: 'shield' });
            if (player.focusActive) statuses.push({ label: 'Focus', kind: 'focus' });
            if (player.rageActive) statuses.push({ label: 'Rage', kind: 'rage' });
            if ((player.regenTurns || 0) > 0 && (player.regenRemaining || 0) > 0) statuses.push({ label: `Regen ${player.regenRemaining}`, kind: 'regen' });
            if ((player.poisonTurns || 0) > 0 && (player.poisonRemaining || 0) > 0) statuses.push({ label: `Poison ${player.poisonRemaining}`, kind: 'poison' });
            if (player.aimActive && player.aimCalledZone !== null) statuses.push({ label: `Aim ${player.aimCalledZone} +${player.aimBonus || 3}`, kind: 'focus' });
            if (player.freeDropsActive) statuses.push({ label: `Free Drops x${player.freeDropsCount || 0}`, kind: 'free' });
            else if ((player.freeDropsCount || 0) > 0) statuses.push({ label: `Free x${player.freeDropsCount}`, kind: 'free' });
            return statuses;
        }

        function makeItemTargetCardButton(user, item, target, opts = {}) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'item-target-card-btn' + (target.id === user.id ? ' self-target' : '');
            btn.style.borderLeftColor = target.color ? target.color.hex : 'rgba(255,255,255,0.4)';
            const statuses = getPlayerStatusEffectsForItemModal(target);
            const labelPrefix = opts.labelPrefix ? `${opts.labelPrefix} ` : '';
            const nameLabel = target.id === user.id ? `${target.name} (self)` : target.name;
            const statusHtml = statuses.length > 0
                ? `<div class="item-target-status-row">${statuses.map(s => `<span class="item-target-status-chip ${s.kind}">${s.label}</span>`).join('')}</div>`
                : `<div class="item-target-status-row"><span class="item-target-status-chip">No status</span></div>`;
            const hpPct = Math.max(0, Math.min(100, (target.hp / Math.max(1, target.maxHp)) * 100));
            btn.innerHTML = `
                <div class="item-target-card-inner">
                    ${getPlayerAvatarHtml(target, { size: 28, className: '' })}
                    <div class="item-target-card-meta">
                        <div class="item-target-card-name">${labelPrefix}${nameLabel}</div>
                        <div class="item-target-card-hp">${target.hp} / ${target.maxHp} HP</div>
                        <div class="item-target-hp-bar"><div class="item-target-hp-fill" style="width:${hpPct}%; background:${target.color ? target.color.hex : '#48dbfb'};"></div></div>
                        ${statusHtml}
                    </div>
                </div>
            `;
            btn.addEventListener('click', () => { applyItemEffect(user, item, target); });
            return btn;
        }

        function countDropDamageForPlayer(playerName) {
            return state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(playerName) && e.message.includes('(-1 HP)')).length;
        }

        function useItemFromInventory(user, slotIdx, target, opts = {}) {
            if (!user || !user.inventory) return false;
            if (isItemLocked(user, slotIdx)) return false;
            if (state.itemUsesThisTurn >= 1) return false;
            const itemId = user.inventory[slotIdx];
            const item = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null;
            if (!item || !target) return false;

            if (item.id === 'scroll') {
                target.hp = Math.min(target.maxHp, target.hp + 15);
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Healed +15 HP!`, 'info');
            } else if (item.id === 'feather') {
                const immediateRegen = Math.min(5, Math.max(0, target.maxHp - target.hp));
                target.hp = Math.min(target.maxHp, target.hp + immediateRegen);
                target.regenRemaining = 10;
                target.regenTurns = 2;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — +${immediateRegen} HP now, Regen +10 HP over 2 turns!`, 'info');
            } else if (item.id === 'orb') {
                target.eliminated = false;
                target.hp = 20;
                addLogEntry(`${user.name} used ${item.name} — ${target.name} resurrected with 20 HP!`, 'info');
            } else if (item.id === 'metal-fragment') {
                target.shieldActive = true;
                target.shieldTurns = 1;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Shield (immune for 1 full turn cycle)!`, 'info');
            } else if (item.id === 'tigers-eye') {
                target.focusActive = true;
                target.focusBonus = 5;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Focus +5 DP next attack!`, 'info');
            } else if (item.id === 'toy-rocket') {
                const aimZone = typeof opts.aimZone === 'number' ? opts.aimZone : null;
                const current = getCurrentPlayer();
                if (!current || current.id !== target.id || !state.hasRolled || aimZone === null || !(state.currentRoll || []).includes(aimZone)) {
                    return false;
                }
                target.aimActive = true;
                target.aimCalledZone = aimZone;
                target.aimBonus = 3;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Called zone ${aimZone} (+3 DP if hit).`, 'info');
            } else if (item.id === 'monkey-paw') {
                target.hp = 0;
                target.eliminated = true;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Instakill!`, 'info');
            } else if (item.id === 'flame') {
                target.rageActive = true;
                target.rageBonus = 5;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Rage +5 DP to highest hit!`, 'info');
            } else if (item.id === 'potion') {
                const immediatePoison = Math.min(5, Math.max(0, target.hp));
                target.hp = Math.max(0, target.hp - immediatePoison);
                target.poisonRemaining = 10;
                target.poisonTurns = 2;
                if (target.hp <= 0) target.eliminated = true;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — -${immediatePoison} HP now, Poison -10 HP over 2 turns!`, 'info');
            } else if (item.id === 'ticket') {
                target.freeDropsActive = true;
                target.freeDropsCount = 3;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Next 3 drops this turn are free!`, 'info');
            } else if (item.id === 'red-rose') {
                const dropCount = countDropDamageForPlayer(target.name);
                target.hp = Math.min(target.maxHp, target.hp + dropCount);
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Recovered ${dropCount} HP from drops!`, 'info');
            } else if (item.id === 'medkit') {
                target.buffActive = false;
                target.nerfActive = false;
                target.shieldActive = false;
                target.shieldTurns = 0;
                target.focusActive = false;
                target.focusBonus = 0;
                target.rageActive = false;
                target.rageBonus = 0;
                target.freeDropsActive = false;
                target.freeDropsCount = 0;
                target.aimActive = false;
                target.aimCalledZone = null;
                target.aimBonus = 0;
                target.regenRemaining = 0;
                target.regenTurns = 0;
                target.poisonRemaining = 0;
                target.poisonTurns = 0;
                addLogEntry(`${user.name} used ${item.name} on ${target.name} — Status cleared!`, 'info');
            } else {
                return false;
            }

            user.inventory[slotIdx] = null;
            if (!user.inventoryLocked) user.inventoryLocked = [false, false, false];
            user.inventoryLocked[slotIdx] = false;
            trackItemUsed(user, item.id);
            state.itemUsesThisTurn++;
            updatePlayersPanel();
            checkWinCondition();
            if (item.id === 'toy-rocket') syncHitRecorderUI();
            if (opts.closeModals) {
                closeItemUseModal();
                closePlayerStatsModal();
            }
            return true;
        }

        function getValidTargetsForItem(user, item) {
            if (item.targetType === 'eliminated') return state.players.filter(p => p.eliminated);
            if (item.targetType === 'opponent') return state.players.filter(p => !p.eliminated && p.id !== user.id);
            return state.players.filter(p => !p.eliminated);
        }

        function pickBotItemTarget(user, item, profile) {
            const alive = state.players.filter(p => !p.eliminated);
            const opponents = alive.filter(p => p.id !== user.id);
            const eliminated = state.players.filter(p => p.eliminated);
            const byLowestHp = (arr) => arr.slice().sort((a, b) => a.hp - b.hp)[0] || null;
            const byHighestHp = (arr) => arr.slice().sort((a, b) => b.hp - a.hp)[0] || null;

            // Free-for-all bots avoid resurrecting opponents.
            if (item.id === 'orb') return null;
            if (item.id === 'monkey-paw') return byLowestHp(opponents);
            if (item.id === 'potion') return byHighestHp(opponents.filter(p => (p.poisonTurns || 0) === 0)) || byHighestHp(opponents);

            if (item.id === 'metal-fragment') return (user.shieldActive || (user.shieldTurns || 0) > 0) ? null : user;
            if (item.id === 'tigers-eye') return user.focusActive ? null : user;
            if (item.id === 'flame') return user.rageActive ? null : user;
            if (item.id === 'ticket') return (user.freeDropsActive || (user.freeDropsCount || 0) > 0) ? null : user;
            if (item.id === 'toy-rocket') return (state.hasRolled && !user.aimActive && state.hits && state.hits.length > 0) ? user : null;

            if (item.id === 'scroll') return user.hp < user.maxHp ? user : null;
            if (item.id === 'feather') return (user.hp < user.maxHp && (user.regenTurns || 0) === 0) ? user : null;
            if (item.id === 'red-rose') {
                return countDropDamageForPlayer(user.name) > 0 ? user : null;
            }
            if (item.id === 'medkit') {
                return (user.nerfActive || (user.poisonRemaining || 0) > 0) ? user : null;
            }

            if (item.targetType === 'opponent') return byLowestHp(opponents);
            if (item.targetType === 'eliminated') return byHighestHp(eliminated);
            if (profile && profile.smartChoiceChance < 0.7) {
                const valid = getValidTargetsForItem(user, item);
                if (valid.length > 0 && Math.random() < 0.35) {
                    return valid[Math.floor(Math.random() * valid.length)];
                }
            }
            return user;
        }

        function scoreBotItemMove(user, item, target) {
            if (!item || !target) return -999;
            const missingHp = Math.max(0, target.maxHp - target.hp);
            const userMissingHp = Math.max(0, user.maxHp - user.hp);
            const userCriticalHp = user.hp <= Math.ceil(user.maxHp * 0.35);

            let score = 0;
            if (item.id === 'monkey-paw') score = 95 + Math.min(30, target.maxHp - target.hp);
            else if (item.id === 'potion') score = 72 + Math.min(25, target.hp);
            else if (item.id === 'metal-fragment') score = (user.shieldActive || (user.shieldTurns || 0) > 0) ? -50 : (userCriticalHp ? 78 : 52);
            else if (item.id === 'tigers-eye') score = user.focusActive ? -30 : 54;
            else if (item.id === 'flame') score = user.rageActive ? -30 : 56;
            else if (item.id === 'scroll') score = missingHp > 0 ? (35 + missingHp + (userCriticalHp ? 20 : 0)) : -20;
            else if (item.id === 'feather') score = missingHp > 0 ? (30 + missingHp + (userCriticalHp ? 15 : 0)) : -20;
            else if (item.id === 'medkit') score = (target.nerfActive || (target.poisonRemaining || 0) > 0) ? 66 : -15;
            else if (item.id === 'red-rose') score = 28 + countDropDamageForPlayer(target.name) * 4;
            else if (item.id === 'ticket') score = (user.freeDropsActive || (user.freeDropsCount || 0) > 0) ? -20 : 44;
            else if (item.id === 'toy-rocket') score = (!state.hasRolled || user.aimActive || !state.hits || state.hits.length === 0) ? -30 : 48;
            else if (item.id === 'orb') score = -40;
            else score = item.targetType === 'opponent' ? 50 : 35;

            if (target.id !== user.id && item.targetType !== 'opponent') score -= 10;
            if (userMissingHp >= 12 && (item.id === 'scroll' || item.id === 'feather') && target.id === user.id) score += 18;
            if (item.id === 'monkey-paw' && target.hp <= 12) score += 15;
            if (item.id === 'potion' && (target.poisonTurns || 0) > 0) score -= 14;

            return score;
        }

        function botTryUseOneItem(botPlayer) {
            if (!botPlayer || !botPlayer.inventory || !state.itemsEnabled) return false;
            const profile = BOT_ITEM_AI[botPlayer.botSkill] || BOT_ITEM_AI.novice;
            if (Math.random() > profile.useChance) return false;

            const moves = [];
            for (let i = 0; i < botPlayer.inventory.length; i++) {
                if (isItemLocked(botPlayer, i)) continue;
                const itemId = botPlayer.inventory[i];
                const item = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null;
                if (!item) continue;
                const target = pickBotItemTarget(botPlayer, item, profile);
                if (!target) continue;
                moves.push({ slotIdx: i, item, target, score: scoreBotItemMove(botPlayer, item, target) });
            }
            if (moves.length === 0) return false;

            let selectedMove;
            if (Math.random() <= profile.smartChoiceChance) {
                selectedMove = moves.slice().sort((a, b) => b.score - a.score)[0];
            } else {
                selectedMove = moves[Math.floor(Math.random() * moves.length)];
            }
            if (!selectedMove || selectedMove.score < 0) return false;

            const useOpts = { closeModals: false };
            if (selectedMove.item && selectedMove.item.id === 'toy-rocket') {
                const called = (state.hits || []).reduce((max, h) => Math.max(max, h.roll), -Infinity);
                if (!Number.isFinite(called)) return false;
                useOpts.aimZone = called;
            }
            if (useItemFromInventory(botPlayer, selectedMove.slotIdx, selectedMove.target, useOpts)) {
                return true;
            }
            return false;
        }

        function openItemUseModal(playerId, slotIdx) {
            const player = state.players.find(p => p.id === playerId);
            if (!player || !player.inventory) return;
            if (isItemLocked(player, slotIdx)) return;
            const itemId = player.inventory[slotIdx];
            const item = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null;
            if (!item) return;
            itemUseContext = { playerId, slotIdx, itemId };
            itemUseTitle.textContent = item.name;
            itemUseDetail.innerHTML = '<div class="item-use-icon-wrap" style="--accent:' + item.accent + '">' + item.svg + '</div><div style="color: #48dbfb; font-size: 0.9rem;">' + item.effect + '</div><div style="font-size: 0.75rem; opacity: 0.7;">' + item.type + '</div>';
            const targetsDiv = itemUseTargets;
            targetsDiv.innerHTML = '';
            if (item.id === 'toy-rocket') {
                const current = getCurrentPlayer();
                if (!current || current.id !== player.id || !state.hasRolled || !state.currentRoll || state.currentRoll.length === 0) {
                    targetsDiv.innerHTML = '<p style="color: #888;">Use this after rolling, before confirming score.</p>';
                    itemUseModal.classList.add('open');
                    return;
                }
                const uniqueRolls = [...new Set(state.currentRoll)];
                const help = document.createElement('p');
                help.style.color = '#8feaff';
                help.style.fontSize = '0.9rem';
                help.style.margin = '0 0 6px 0';
                help.textContent = 'Call one rolled zone. If you hit it, gain +3 DP.';
                targetsDiv.appendChild(help);
                uniqueRolls.forEach(roll => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'btn btn-primary';
                    btn.textContent = `Call ${roll}`;
                    btn.addEventListener('click', () => {
                        useItemFromInventory(player, slotIdx, player, { closeModals: true, aimZone: roll });
                    });
                    targetsDiv.appendChild(btn);
                });
                itemUseModal.classList.add('open');
                return;
            }
            if (item.targetType === 'eliminated') {
                const eliminated = state.players.filter(p => p.eliminated);
                if (eliminated.length === 0) {
                    targetsDiv.innerHTML = '<p style="color: #888;">No eliminated players to resurrect.</p>';
                } else {
                    eliminated.forEach(t => {
                        targetsDiv.appendChild(makeItemTargetCardButton(player, item, t, { labelPrefix: 'Resurrect' }));
                    });
                }
            } else {
                const canTargetAnyAlive = item.targetType === 'self';
                const alive = state.players.filter(p => !p.eliminated && (canTargetAnyAlive || p.id !== player.id));
                if (alive.length === 0) {
                    targetsDiv.innerHTML = '<p style="color: #888;">No valid players to target.</p>';
                } else {
                    alive.forEach(t => {
                        targetsDiv.appendChild(makeItemTargetCardButton(player, item, t));
                    });
                }
            }
            itemUseModal.classList.add('open');
        }

        function closeItemUseModal() {
            itemUseModal.classList.remove('open');
            itemUseContext = null;
        }

        function applyItemEffect(user, item, target) {
            if (!itemUseContext) return;
            const { playerId, slotIdx } = itemUseContext;
            const player = state.players.find(p => p.id === playerId);
            if (!player || player.inventory[slotIdx] !== item.id) return;
            useItemFromInventory(player, slotIdx, target, { closeModals: true });
        }

        itemUseCancelBtn.addEventListener('click', closeItemUseModal);
        itemUseModal.addEventListener('click', (e) => { if (e.target === itemUseModal) closeItemUseModal(); });

        playerStatsUndoDropBtn.addEventListener('click', () => {
            if (playerStatsModalPlayerId === null) return;
            const current = getCurrentPlayer();
            if (current.id !== playerStatsModalPlayerId) return;
            if (state.damageDealtThisTurn || state.dropsThisTurnLogIndices.length === 0) return;
            const logIndex = state.dropsThisTurnLogIndices.pop();
            const logEntry = state.gameLog[logIndex];
            if (!logEntry || logEntry.type !== 'damage' || !logEntry.message.includes('dropped a knife') || !logEntry.message.includes(current.name)) {
                state.dropsThisTurnLogIndices.push(logIndex);
                return;
            }
            const domIndex = state.gameLog.length - 1 - logIndex;
            if (gameLogEntries.children[domIndex]) gameLogEntries.children[domIndex].remove();
            state.gameLog.splice(logIndex, 1);
            for (let i = 0; i < state.dropsThisTurnLogIndices.length; i++) {
                if (state.dropsThisTurnLogIndices[i] > logIndex) state.dropsThisTurnLogIndices[i]--;
            }
            current.hp = Math.min(current.maxHp, current.hp + 1);
            if (current.hp > 0) current.eliminated = false;
            state.dropsThisTurn = Math.max(0, state.dropsThisTurn - 1);
            state.lastDroppedKnifeLogIndex = state.dropsThisTurnLogIndices.length > 0 ? state.dropsThisTurnLogIndices[state.dropsThisTurnLogIndices.length - 1] : undefined;
            updatePlayersPanel();
            checkWinCondition();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / 3`;
            openPlayerStatsModal(playerStatsModalPlayerId);
        });

        playersPanel.addEventListener('click', (e) => {
            const btn = e.target.closest('.player-card-stats-btn');
            if (btn) {
                e.stopPropagation();
                const playerId = parseInt(btn.dataset.player, 10);
                openPlayerStatsModal(playerId);
                return;
            }
            const invSlot = e.target.closest('.player-card-inventory-slot.has-item');
            if (invSlot && state.itemsEnabled) {
                const playerId = parseInt(invSlot.dataset.player, 10);
                const slotIdx = parseInt(invSlot.dataset.slot, 10);
                if (canPlayerUseItemsNow(playerId)) {
                    e.stopPropagation();
                    openItemUseModal(playerId, slotIdx);
                }
            }
        });

        endTurnBtn.addEventListener('click', () => {
            nextTurn();
        });

        function nextTurn() {
            if (botEndTurnTimerId) { clearTimeout(botEndTurnTimerId); botEndTurnTimerId = null; }
            disableTargetSelection();
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            let nextIdx = state.currentPlayerIndex;
            const alivePlayers = getAlivePlayers();

            if (alivePlayers.length <= 1) {
                checkWinCondition();
                return;
            }

            do {
                nextIdx = (nextIdx + 1) % state.players.length;
            } while (state.players[nextIdx].eliminated);

            // Clear buff/nerf/rage for the player whose turn just ended
            const prevPlayer = state.players[state.currentPlayerIndex];
            if (prevPlayer) {
                prevPlayer.rageActive = false;
                prevPlayer.freeDropsActive = false;
                prevPlayer.freeDropsCount = 0;
                prevPlayer.aimActive = false;
                prevPlayer.aimCalledZone = null;
                prevPlayer.aimBonus = 0;
                if (prevPlayer.inventoryLocked) prevPlayer.inventoryLocked = prevPlayer.inventoryLocked.map(() => false);
            }
            // Clear buff/nerf for the player whose turn is starting (their "1 turn" of effect has ended)
            const nextPlayer = state.players[nextIdx];
            if (nextPlayer) {
                nextPlayer.buffActive = false;
                nextPlayer.nerfActive = false;
                if ((nextPlayer.shieldTurns || 0) > 0) {
                    nextPlayer.shieldTurns--;
                    if (nextPlayer.shieldTurns <= 0) nextPlayer.shieldActive = false;
                }
                if (nextPlayer.regenRemaining > 0 && nextPlayer.regenTurns > 0) {
                    const heal = Math.min(5, nextPlayer.regenRemaining);
                    nextPlayer.hp = Math.min(nextPlayer.maxHp, nextPlayer.hp + heal);
                    nextPlayer.regenRemaining -= heal;
                    nextPlayer.regenTurns--;
                    if (heal > 0) addLogEntry(`${nextPlayer.name} regens +${heal} HP!`, 'info');
                }
                if (nextPlayer.poisonRemaining > 0 && nextPlayer.poisonTurns > 0) {
                    const dmg = Math.min(5, nextPlayer.poisonRemaining);
                    nextPlayer.hp = Math.max(0, nextPlayer.hp - dmg);
                    nextPlayer.poisonRemaining -= dmg;
                    nextPlayer.poisonTurns--;
                    addLogEntry(`${nextPlayer.name} takes ${dmg} poison damage!`, 'damage');
                    if (nextPlayer.hp <= 0) {
                        nextPlayer.eliminated = true;
                        addLogEntry(`${nextPlayer.name} has been eliminated!`, 'info');
                    }
                }
            }

            state.currentPlayerIndex = nextIdx;
            addLogEntry(`${getCurrentPlayer().name}'s turn begins.`, 'info');
            updateGameUI();
        }

        function checkWinCondition() {
            const alivePlayers = getAlivePlayers();
            if (alivePlayers.length === 1) {
                state.phase = 'finished';
                showWinner(alivePlayers[0]);
            } else if (alivePlayers.length === 0) {
                state.phase = 'finished';
                showWinner(null);
            }
        }

        function showWinner(winner) {
            state.players.forEach(p => {
                p.inventory = [null, null, null];
            });
            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'block';

            if (winner) {
                document.getElementById('winner-name').innerHTML = `
                    <div style="margin: 0 auto 20px; display: flex; justify-content: center;">${getPlayerAvatarHtml(winner, { size: 80, className: '' })}</div>
                    <span style="color: ${winner.color.hex};">${winner.name}</span> Wins!
                `;
            } else {
                document.getElementById('winner-name').textContent = "It's a Draw!";
            }
        }

        function formatItemStatsMapForReport(statsMap) {
            const entries = Object.entries(statsMap || {}).filter(([, count]) => count > 0);
            if (!entries.length) return '—';
            entries.sort((a, b) => b[1] - a[1]);
            return entries.map(([itemId, count]) => {
                const item = typeof DAGGERDIE_ITEM_BY_ID !== 'undefined' ? DAGGERDIE_ITEM_BY_ID[itemId] : null;
                const label = item && item.name ? item.name : itemId;
                return `${label} x${count}`;
            }).join(', ');
        }

        function generateGameReportHTML(winner) {
            const now = new Date();
            const dateStr = now.toLocaleDateString(undefined, { dateStyle: 'long' });
            const timeStr = now.toLocaleTimeString(undefined, { timeStyle: 'short' });
            const winnerText = winner ? winner.name : "Draw (no winner)";
            const turnOrderList = state.players.map((p, i) => `${i + 1}. ${p.name}`).join(', ');

            const playerRows = state.players.map(p => {
                let status = p.eliminated ? 'Eliminated' : (winner && p.id === winner.id ? 'Winner' : 'Survived');
                return `
                <tr>
                    <td><span class="report-color-dot" style="background:${p.color.hex}"></span> ${escapeHtml(p.name)}</td>
                    <td>${p.hp} / ${p.maxHp}</td>
                    <td><span class="report-status report-status-${status.toLowerCase().replace(/\s/g,'')}">${status}</span></td>
                </tr>`;
            }).join('');

            // Per-player stats for breakdown
            const playerStatsBreakdown = state.players.map(p => {
                const status = p.eliminated ? 'Eliminated' : (winner && p.id === winner.id ? 'Winner' : 'Survived');
                const hitCount = state.gameLog.filter(e =>
                    e.type === 'damage' &&
                    e.message.startsWith(`${p.name} dealt `) &&
                    e.message.includes(' damage to ')
                ).length;
                const dropCount = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(p.name)).length;
                const throws = p.totalThrows || 0;
                const efficiency = throws > 0 ? (hitCount / throws * 100).toFixed(1) : '—';
                const rolled = p.totalRolled || 0;
                const claimed = p.totalClaimed || 0;
                const pointsPct = rolled > 0 ? (claimed / rolled * 100).toFixed(1) : '—';
                const pointsStr = rolled > 0 ? `${claimed} / ${rolled} (${pointsPct}%)` : '—';
                ensurePlayerItemStats(p);
                const itemRows = state.itemsEnabled ? `
                        <tr><td>Items acquired</td><td>${p.itemStats.acquired || 0}</td></tr>
                        <tr><td>Items used</td><td>${p.itemStats.used || 0}</td></tr>
                        <tr><td>Acquired breakdown</td><td>${escapeHtml(formatItemStatsMapForReport(p.itemStats.acquiredById))}</td></tr>
                        <tr><td>Used breakdown</td><td>${escapeHtml(formatItemStatsMapForReport(p.itemStats.usedById))}</td></tr>` : '';
                return `
                <div class="report-player-card" style="border-left-color: ${p.color.hex}">
                    <h3 class="report-player-name">${getPlayerAvatarHtml(p, { size: 24, className: 'report-avatar' })} ${escapeHtml(p.name)}</h3>
                    <table class="report-stats-table">
                        <tr><td>Status</td><td><span class="report-status report-status-${status.toLowerCase().replace(/\s/g,'')}">${status}</span></td></tr>
                        <tr><td>Final HP</td><td>${p.hp} / ${p.maxHp}</td></tr>
                        <tr><td>Hits dealt</td><td>${hitCount}</td></tr>
                        <tr><td>Drops (self-damage)</td><td>${dropCount}</td></tr>
                        <tr><td>Criticals</td><td>${p.criticals || 0}</td></tr>
                        <tr><td>Efficiency (hits/throws)</td><td>${throws > 0 ? `${hitCount}/${throws} (${efficiency}%)` : '—'}</td></tr>
                        <tr><td>Points (claimed / rolled)</td><td>${pointsStr}</td></tr>
${itemRows}
                    </table>
                </div>`;
            }).join('');

            const logEntries = state.gameLog.map((e, i) => {
                const cls = e.type === 'damage' ? 'report-log-damage' : e.type === 'heal' ? 'report-log-heal' : 'report-log-info';
                return `<li class="report-log-entry ${cls}"><span class="report-log-num">${i + 1}.</span> ${escapeHtml(e.message)}</li>`;
            }).join('');
            const totalActions = state.gameLog.length;

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger &amp; Die - Game Report</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 40px 20px;
            line-height: 1.5;
        }
        .report-container { max-width: 720px; margin: 0 auto; }
        .report-header {
            text-align: center;
            margin-bottom: 36px;
            padding-bottom: 24px;
            border-bottom: 2px solid rgba(255,255,255,0.15);
        }
        .report-title {
            font-size: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }
        .report-meta { color: rgba(255,255,255,0.6); font-size: 0.95rem; }
        .report-winner-box {
            background: rgba(254, 202, 87, 0.15);
            border: 2px solid rgba(254, 202, 87, 0.5);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 28px;
            text-align: center;
        }
        .report-winner-label { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.7); margin-bottom: 4px; }
        .report-winner-name { font-size: 1.5rem; font-weight: bold; color: #feca57; }
        .report-section {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 24px;
        }
        .report-section h2 {
            font-size: 1.1rem;
            color: #48dbfb;
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .report-table { width: 100%; border-collapse: collapse; }
        .report-table th, .report-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .report-table th { color: rgba(255,255,255,0.7); font-weight: 600; font-size: 0.85rem; }
        .report-color-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; margin-right: 6px; }
        .report-avatar { display: inline-block; vertical-align: middle; margin-right: 8px; }
        .report-status { font-size: 0.85rem; padding: 2px 8px; border-radius: 6px; }
        .report-status-winner { background: rgba(46, 204, 113, 0.3); color: #2ecc71; }
        .report-status-eliminated { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }
        .report-status-survived { background: rgba(72, 219, 251, 0.2); color: #48dbfb; }
        .report-turn-order { color: rgba(255,255,255,0.85); font-size: 0.95rem; }
        .report-log { list-style: none; }
        .report-log-entry { padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 0.9rem; display: flex; gap: 8px; }
        .report-log-entry:last-child { border-bottom: none; }
        .report-log-num { color: rgba(255,255,255,0.4); min-width: 28px; }
        .report-log-damage { color: #ff6b6b; }
        .report-log-heal { color: #2ecc71; }
        .report-log-info { color: #48dbfb; }
        .report-player-card {
            background: rgba(255,255,255,0.04);
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 16px;
            border-left: 4px solid #48dbfb;
        }
        .report-player-card:last-child { margin-bottom: 0; }
        .report-player-name { font-size: 1rem; color: #e8e8e8; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .report-stats-table { width: 100%; font-size: 0.9rem; }
        .report-stats-table td { padding: 4px 0; border: none; }
        .report-stats-table td:first-child { color: rgba(255,255,255,0.6); width: 55%; }
        .report-stats-table td:last-child { color: #e8e8e8; }
    </style>
</head>
<body>
    <div class="report-container">
        <header class="report-header">
            <h1 class="report-title">Dagger &amp; Die</h1>
            <p class="report-meta">Game Report &middot; ${escapeHtml(dateStr)} at ${escapeHtml(timeStr)}</p>
        </header>
        <div class="report-winner-box">
            <div class="report-winner-label">Winner</div>
            <div class="report-winner-name">${escapeHtml(winnerText)}</div>
        </div>
        <section class="report-section">
            <h2>Players (final)</h2>
            <table class="report-table">
                <thead><tr><th>Player</th><th>HP</th><th>Status</th></tr></thead>
                <tbody>${playerRows}</tbody>
            </table>
        </section>
        <section class="report-section">
            <h2>Turn order</h2>
            <p class="report-turn-order">${escapeHtml(turnOrderList)}</p>
        </section>
        <section class="report-section">
            <h2>Player stats breakdown</h2>
            <div class="report-player-cards">${playerStatsBreakdown}</div>
        </section>
        <section class="report-section">
            <h2>Game ledger (${totalActions} entries)</h2>
            <ul class="report-log">${logEntries || '<li class="report-log-info">No actions recorded.</li>'}</ul>
        </section>
    </div>
</body>
</html>`;
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function exportGameReport() {
            const winner = getAlivePlayers().length === 1 ? getAlivePlayers()[0] : null;
            const html = generateGameReportHTML(winner);
            const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank', 'noopener');
            const a = document.createElement('a');
            a.href = url;
            a.download = `dagger-die-report-${new Date().toISOString().slice(0,10)}.html`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }

        document.getElementById('export-report-btn').addEventListener('click', exportGameReport);

        function resetDice() {
            ['die1', 'die2', 'die3'].forEach(id => {
                const die = document.getElementById(id);
                die.textContent = '-';
                die.classList.remove('odd', 'even', 'rolling');
            });
        }

        function addLogEntry(message, type = 'info') {
            state.gameLog.push({ message, type });
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            gameLogEntries.insertBefore(entry, gameLogEntries.firstChild);
        }

        function showCriticalReaction(playerName) {
            const el = document.getElementById('critical-reaction');
            if (!el) return;
            const inner = el.querySelector('.critical-reaction-inner');
            if (inner) inner.textContent = 'Critical!';
            el.classList.remove('hide');
            el.classList.add('show');
            setTimeout(() => {
                el.classList.remove('show');
                el.classList.add('hide');
                setTimeout(() => el.classList.remove('hide'), 300);
            }, 1000);
        }

        const missModal = document.getElementById('miss-modal');
        const missModalPlayerName = document.getElementById('miss-modal-player-name');
        const missModalYes = document.getElementById('miss-modal-yes');
        const missModalNo = document.getElementById('miss-modal-no');

        function showMissModal(currentPlayer) {
            missModalPlayerName.textContent = currentPlayer.name;
            missModal.classList.add('open');
        }

        function closeMissModal() {
            missModal.classList.remove('open');
        }

        function showMissReaction() {
            const el = document.getElementById('miss-reaction');
            if (!el) return;
            const inner = el.querySelector('.miss-reaction-inner');
            if (inner) inner.textContent = 'Miss!';
            el.classList.remove('hide');
            el.classList.add('show');
            setTimeout(() => {
                el.classList.remove('show');
                el.classList.add('hide');
                setTimeout(() => el.classList.remove('hide'), 300);
            }, 1000);
        }

        missModalYes.addEventListener('click', () => {
            const currentPlayer = getCurrentPlayer();
            closeMissModal();
            if (state.modNerfOnMiss) currentPlayer.nerfActive = true;
            addLogEntry(`${currentPlayer.name} missed all targets!`, 'info');
            showMissReaction();
            finishTurnNoAttack();
        });

        missModalNo.addEventListener('click', () => {
            closeMissModal();
        });

        missModal.addEventListener('click', (e) => {
            if (e.target === missModal) closeMissModal();
        });

        document.getElementById('new-game-btn').addEventListener('click', resetGame);
                function playAgain() {
            if (botEndTurnTimerId) { clearTimeout(botEndTurnTimerId); botEndTurnTimerId = null; }
            applySettingsForNewGame();
            const defaultHp = getDefaultHp(state.players.length);
            state.players.forEach(p => {
                p.hp = defaultHp;
                p.maxHp = defaultHp;
                p.eliminated = false;
                p.turnOrderRoll = 0;
                p.totalRolled = 0;
                p.totalClaimed = 0;
                p.totalThrows = 0;
                p.criticals = 0;
                p.buffActive = false;
                p.nerfActive = false;
                p.aimActive = false;
                p.aimCalledZone = null;
                p.aimBonus = 0;
                p.inventory = [null, null, null];
                p.inventoryLocked = [false, false, false];
                p.itemStats = { acquired: 0, used: 0, acquiredById: {}, usedById: {} };
            });
            state.currentPlayerIndex = 0;
            state.phase = 'turnOrder';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.remainingHitIndices = [];
            state.selectedHitIdx = null;
            state.attackLog = [];
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.itemUsesThisTurn = 0;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            winnerScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            rollBtn.classList.remove('hidden');
            rollBtn.disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${getPlayerAvatarHtml(p, { size: 30, className: '' })}
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');

            const tieMsg = document.getElementById('tie-reroll-message');
            if (tieMsg) tieMsg.style.display = 'none';

            gameLogEntries.innerHTML = '';
        }

        document.getElementById('play-again-btn').addEventListener('click', playAgain);
        document.getElementById('finished-btn').addEventListener('click', () => { window.location.href = 'startgame.html'; });

        function resetGame() {
            window.location.href = 'charselect.html';
        }
    </script>
</body>
</html>
