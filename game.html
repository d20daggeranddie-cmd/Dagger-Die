<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger & Die - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Setup Screen */
        #setup-screen {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            margin: 0 auto;
        }

        .setup-title {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
        }

        .player-count-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .player-count-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .player-count-btn:hover, .player-count-btn.selected {
            background: #48dbfb;
            transform: scale(1.1);
        }

        .player-setup {
            display: none;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-setup.visible {
            display: flex;
        }

        .player-input {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .player-input input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1rem;
        }

        .player-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .player-input.error input,
        .player-input.error-duplicate input {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.4);
        }

        .setup-error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 20px;
            color: #ff6b6b;
            font-size: 0.95rem;
        }

        .color-picker {
            display: flex;
            align-items: center;
        }

        .color-picker-wrap {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .color-picker-wrap:hover {
            transform: scale(1.12);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.8);
        }

        .color-swatch {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        .player-color-input {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }

        /* Custom circular color picker modal */
        .color-picker-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .color-picker-modal-overlay.open {
            display: flex;
        }

        .color-picker-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .color-picker-modal h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: rgba(255,255,255,0.9);
        }

        .color-wheel-container {
            position: relative;
            width: 260px;
            height: 260px;
            margin: 0 auto 20px;
            touch-action: none;
        }

        .color-wheel-hue {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #ff0000, #ff8800, #ffff00, #88ff00, #00ff00, #00ff88, #00ffff, #0088ff, #0000ff, #8800ff, #ff00ff, #ff0088, #ff0000);
            padding: 12px;
        }

        .color-wheel-inner {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: #1e2a3a;
        }

        .color-wheel-sat {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--picker-gray, #808080) 0%, var(--picker-hue-color, #f00) 100%);
            cursor: crosshair;
        }

        .color-wheel-hue-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .color-wheel-sat-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .color-picker-lightness {
            margin-bottom: 20px;
        }

        .color-picker-lightness label {
            display: block;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 8px;
        }

        .color-picker-lightness input[type="range"] {
            width: 100%;
            height: 28px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-top: -7px;
            cursor: pointer;
        }

        .color-picker-lightness input[type="range"]::-moz-range-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
        }

        .color-picker-done {
            display: block;
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(45deg, #48dbfb, #0abde3);
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-picker-done:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,171,227,0.4);
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(238, 90, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            color: #fff;
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        /* Game Screen */
        #game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .turn-indicator {
            font-size: 1.5rem;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .current-player-name {
            font-weight: bold;
        }

        /* Players Panel */
        .players-panel {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
            justify-content: center;
        }

        .player-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.current {
            border-color: #feca57;
            box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
            transform: scale(1.05);
        }

        .player-card.eliminated {
            opacity: 0.4;
            filter: grayscale(1);
        }

        .player-card.targetable {
            cursor: pointer;
        }

        .player-card.targetable:hover {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-hp {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #2ecc71);
            transition: width 0.5s;
        }

        .player-turn-order {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        /* Game Area */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        /* Dice Section */
        .dice-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .section-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .die {
            width: 65px;
            height: 65px;
            background: linear-gradient(145deg, #2d3436, #1e272e);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .die.rolling {
            animation: roll 0.1s infinite;
        }

        .die.odd {
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .die.even {
            color: #48dbfb;
            border-color: #48dbfb;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
        }

        .roll-btn {
            display: block;
            margin: 0 auto 20px;
            padding: 15px 50px;
        }

        .dice-results {
            text-align: center;
            margin-top: 15px;
        }

        .total-damage {
            font-size: 1.5rem;
            color: #feca57;
        }

        /* Target Section */
        .targets-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .targets-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .target-wrapper {
            position: relative;
            width: 180px;
        }

        .target-label {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.85rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .target-image-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 50%;
            overflow: hidden;
            /* Wood base color */
            background:
                repeating-linear-gradient(
                    85deg,
                    transparent 0px,
                    transparent 2px,
                    rgba(101, 67, 33, 0.08) 3px,
                    rgba(101, 67, 33, 0.08) 4px,
                    transparent 5px,
                    transparent 12px
                ),
                radial-gradient(
                    circle at 45% 45%,
                    #d4a574 0%,
                    #c4956a 20%,
                    #b8895e 40%,
                    #a67c52 60%,
                    #8b6914 80%,
                    #6b4423 100%
                );
            border: 8px solid #3d2914;
            box-shadow:
                inset 0 0 20px rgba(0,0,0,0.3),
                inset 0 0 40px rgba(0,0,0,0.1),
                0 5px 15px rgba(0,0,0,0.5),
                0 2px 6px rgba(0,0,0,0.3);
        }

        .target-image-container::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: -8px;
            bottom: -8px;
            border-radius: 50%;
            border: 8px solid transparent;
            background:
                repeating-conic-gradient(
                    from 0deg,
                    #2d1f0f 0deg,
                    #4a3520 2deg,
                    #3d2914 4deg,
                    #2d1f0f 6deg
                );
            background-clip: padding-box;
            -webkit-mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 5;
        }

        .target-image {
            width: 90%;
            height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            z-index: 2;
        }

        .target-overlay {
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            pointer-events: none;
            z-index: 3;
        }

        .highlight-zone {
            fill: transparent;
            stroke: transparent;
            stroke-width: 3;
            transition: all 0.3s;
        }

        .highlight-zone.active {
            fill: rgba(255, 215, 0, 0.4);
            stroke: #ffd700;
            stroke-width: 4;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Actions Section */
        .actions-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .attack-prompt {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #feca57;
        }

        .editable-hits-box:hover {
            background: rgba(46, 204, 113, 0.35) !important;
            border-color: #27ae60 !important;
        }

        .hit-info {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .hit-badge {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .hit-badge.hit {
            background: #2ecc71;
        }

        .hit-badge.miss {
            background: #e74c3c;
        }

        /* Turn Order Screen */
        #turn-order-screen {
            display: none;
            text-align: center;
        }

        .turn-order-rolls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 30px auto;
        }

        .turn-order-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
        }

        .turn-order-player .roll-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #feca57;
        }

        /* Winner Screen */
        #winner-screen {
            display: none;
            text-align: center;
            padding: 60px 20px;
        }

        .winner-title {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #feca57; }
            50% { text-shadow: 0 0 40px #feca57, 0 0 60px #ff6b6b; }
        }

        .winner-name {
            font-size: 2rem;
            margin-bottom: 40px;
        }

        /* Game Log */
        .game-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #2ecc71;
        }

        .log-info {
            color: #48dbfb;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            .game-header {
                margin-bottom: 10px;
            }

            .turn-indicator {
                font-size: 1rem;
                padding: 8px 12px;
            }

            .players-panel {
                gap: 8px;
                margin-bottom: 15px;
            }

            .player-card {
                padding: 10px;
                min-width: 100px;
            }

            .player-avatar {
                width: 40px;
                height: 40px;
            }

            .player-hp {
                font-size: 1.1rem;
            }

            .player-turn-order {
                font-size: 0.7rem;
            }

            .game-area {
                gap: 15px;
            }

            .dice-section, .targets-section, .actions-section {
                padding: 15px;
                border-radius: 15px;
            }

            .section-title {
                font-size: 1rem;
                margin-bottom: 10px;
            }

            .die {
                width: 55px;
                height: 55px;
                font-size: 1.3rem;
            }

            .dice-container {
                gap: 10px;
                margin-bottom: 10px;
            }

            .roll-btn {
                padding: 10px 30px;
                font-size: 1rem;
            }

            .target-wrapper {
                width: 140px;
            }

            .target-label {
                font-size: 0.75rem;
                margin-bottom: 3px;
            }

            .target-image-container {
                border-width: 6px;
            }

            .target-image-container::before {
                top: -6px;
                left: -6px;
                right: -6px;
                bottom: -6px;
                border-width: 6px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .attack-prompt {
                font-size: 1rem;
            }

            .game-log {
                max-height: 100px;
                padding: 10px;
            }

            .log-entry {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 400px) {
            .target-wrapper {
                width: 120px;
            }

            .target-image-container {
                border-width: 5px;
            }

            .target-image-container::before {
                top: -5px;
                left: -5px;
                right: -5px;
                bottom: -5px;
                border-width: 5px;
            }

            .die {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }

            .player-card {
                min-width: 80px;
                padding: 8px;
            }

            .player-avatar {
                width: 30px;
                height: 30px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-hp {
                font-size: 0.95rem;
            }
        }

        /* Back to Home link */
        .back-link {
            display: inline-block;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #48dbfb;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Home</a>
        <h1>Dagger & Die</h1>

        <!-- Setup Screen -->
        <div id="setup-screen">
            <h2 class="setup-title">Select Number of Players</h2>
            <div class="player-count-selector">
                <button class="player-count-btn" data-count="2">2</button>
                <button class="player-count-btn" data-count="3">3</button>
                <button class="player-count-btn" data-count="4">4</button>
                <button class="player-count-btn" data-count="5">5</button>
                <button class="player-count-btn" data-count="6">6</button>
            </div>
            <div class="player-setup" id="player-setup"></div>
            <div class="setup-error hidden" id="setup-error" role="alert"></div>
            <button class="btn btn-primary btn-center" id="start-game-btn" style="display:none;">Start Game</button>
        </div>

        <!-- Turn Order Screen -->
        <div id="turn-order-screen">
            <h2 class="setup-title">Rolling for Turn Order</h2>
            <p>Each player rolls a D20 to determine turn order. Highest goes first!</p>
            <div class="turn-order-rolls" id="turn-order-rolls"></div>
            <button class="btn btn-primary" id="roll-turn-order-btn">Roll for Turn Order</button>
            <button class="btn btn-primary hidden" id="begin-game-btn">Begin Game!</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="game-header">
                <div class="turn-indicator">
                    Turn: <span class="current-player-name" id="current-player-name">-</span>
                </div>
                <button class="btn btn-secondary" id="new-game-btn">New Game</button>
            </div>

            <div class="players-panel" id="players-panel"></div>

            <div class="game-area">
                <div class="dice-section">
                    <h3 class="section-title">Your Dice</h3>
                    <div class="dice-container">
                        <div class="die" id="die1">-</div>
                        <div class="die" id="die2">-</div>
                        <div class="die" id="die3">-</div>
                    </div>
                    <button class="btn btn-primary roll-btn" id="roll-dice-btn">Roll Dice</button>
                    <div class="dice-results" id="dice-results"></div>
                </div>

                <div class="targets-section">
                    <h3 class="section-title">Target Boards</h3>
                    <div class="targets-container">
                        <div class="target-wrapper">
                            <div class="target-label">Odd Numbers (1-19)</div>
                            <div class="target-image-container">
                                <img src="assets/ODD.svg" alt="Odd Target" class="target-image">
                                <svg class="target-overlay" id="odd-overlay" viewBox="0 0 100 100" preserveAspectRatio="none">
                                    <polygon class="highlight-zone" data-number="1" points="50,30 35,55 65,55"/>
                                    <polygon class="highlight-zone" data-number="17" points="19,16 50,10 35,30"/>
                                    <polygon class="highlight-zone" data-number="3" points="50,10 81,16 65,30"/>
                                    <polygon class="highlight-zone" data-number="7" points="19,16 35,30 20,50"/>
                                    <polygon class="highlight-zone" data-number="19" points="65,30 81,16 80,50"/>
                                    <polygon class="highlight-zone" data-number="15" points="8,35 19,16 20,50"/>
                                    <polygon class="highlight-zone" data-number="9" points="92,35 80,50 81,16"/>
                                    <polygon class="highlight-zone" data-number="5" points="20,50 35,55 25,75"/>
                                    <polygon class="highlight-zone" data-number="11" points="65,55 80,50 75,75"/>
                                    <polygon class="highlight-zone" data-number="13" points="35,55 65,55 50,85"/>
                                </svg>
                            </div>
                        </div>
                        <div class="target-wrapper">
                            <div class="target-label">Even Numbers (2-20)</div>
                            <div class="target-image-container">
                                <img src="assets/EVEN.svg" alt="Even Target" class="target-image">
                                <svg class="target-overlay" id="even-overlay" viewBox="0 0 100 100" preserveAspectRatio="none">
                                    <polygon class="highlight-zone" data-number="20" points="50,30 35,55 65,55"/>
                                    <polygon class="highlight-zone" data-number="18" points="19,16 50,10 35,30"/>
                                    <polygon class="highlight-zone" data-number="4" points="50,10 81,16 65,30"/>
                                    <polygon class="highlight-zone" data-number="2" points="19,16 35,30 20,50"/>
                                    <polygon class="highlight-zone" data-number="14" points="65,30 81,16 80,50"/>
                                    <polygon class="highlight-zone" data-number="12" points="8,35 19,16 20,50"/>
                                    <polygon class="highlight-zone" data-number="6" points="92,35 80,50 81,16"/>
                                    <polygon class="highlight-zone" data-number="10" points="20,50 35,55 25,75"/>
                                    <polygon class="highlight-zone" data-number="16" points="65,55 80,50 75,75"/>
                                    <polygon class="highlight-zone" data-number="8" points="35,55 65,55 50,85"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="actions-section" id="actions-section">
                <h3 class="section-title">Actions</h3>
                <div class="hit-info" id="hit-info"></div>
                <div class="attack-prompt hidden" id="attack-prompt">Select a player to attack!</div>
                <div class="action-buttons">
                    <button class="btn btn-danger" id="dropped-knife-btn">Dropped Knife (-1 HP)</button>
                    <button class="btn btn-primary hidden" id="end-turn-btn">End Turn</button>
                </div>
            </div>

            <div class="game-log">
                <h4>Game Log</h4>
                <div id="game-log-entries"></div>
            </div>
        </div>

        <!-- Winner Screen -->
        <div id="winner-screen">
            <h2 class="winner-title">Victory!</h2>
            <div class="winner-name" id="winner-name"></div>
            <button class="btn btn-primary" id="play-again-btn">Play Again</button>
        </div>
    </div>

    <!-- Custom circular color picker modal (must be in DOM before script runs) -->
    <div class="color-picker-modal-overlay" id="color-picker-modal" role="dialog" aria-label="Pick color">
        <div class="color-picker-modal">
            <h3>Pick your color</h3>
            <div class="color-wheel-container" id="color-wheel-container">
                <div class="color-wheel-hue" id="color-wheel-hue"></div>
                <div class="color-wheel-inner"></div>
                <div class="color-wheel-sat" id="color-wheel-sat"></div>
                <div class="color-wheel-hue-handle" id="color-hue-handle"></div>
                <div class="color-wheel-sat-handle" id="color-sat-handle"></div>
            </div>
            <div class="color-picker-lightness">
                <label for="color-lightness-input">Brightness</label>
                <input type="range" id="color-lightness-input" min="0" max="100" value="50">
            </div>
            <button type="button" class="color-picker-done" id="color-picker-done">Done</button>
        </div>
    </div>

    <script>
        // Game State
        const state = {
            players: [],
            currentPlayerIndex: 0,
            phase: 'setup',
            currentRoll: [],
            hits: [],
            totalDamage: 0,
            hasRolled: false,
            hasAttacked: false,
            damageClaimedPhase: false,
            currentHitIndex: 0,
            attackLog: []
        };

        const COLORS = [
            { name: 'Red', hex: '#e74c3c' },
            { name: 'Blue', hex: '#3498db' },
            { name: 'Green', hex: '#2ecc71' },
            { name: 'Purple', hex: '#9b59b6' },
            { name: 'Orange', hex: '#e67e22' },
            { name: 'Pink', hex: '#fd79a8' },
            { name: 'Cyan', hex: '#00cec9' },
            { name: 'Yellow', hex: '#f1c40f' }
        ];

        function hexToHSL(hex) {
            const n = parseInt(hex.slice(1), 16);
            const r = (n >> 16) / 255, g = ((n >> 8) & 0xff) / 255, b = (n & 0xff) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                else if (max === g) h = ((b - r) / d + 2) / 6;
                else h = ((r - g) / d + 4) / 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            s /= 100; l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / 30) % 12;
                return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
            };
            const r = Math.round(f(0) * 255), g = Math.round(f(8) * 255), b = Math.round(f(4) * 255);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const turnOrderScreen = document.getElementById('turn-order-screen');
        const gameScreen = document.getElementById('game-screen');
        const winnerScreen = document.getElementById('winner-screen');
        const playerSetup = document.getElementById('player-setup');
        const startGameBtn = document.getElementById('start-game-btn');
        const playersPanel = document.getElementById('players-panel');
        const currentPlayerNameEl = document.getElementById('current-player-name');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const diceResults = document.getElementById('dice-results');
        const hitInfo = document.getElementById('hit-info');
        const attackPrompt = document.getElementById('attack-prompt');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const droppedKnifeBtn = document.getElementById('dropped-knife-btn');
        const gameLogEntries = document.getElementById('game-log-entries');

        // Custom circular color picker
        const colorPickerModal = document.getElementById('color-picker-modal');
        const colorWheelContainer = document.getElementById('color-wheel-container');
        const colorWheelSat = document.getElementById('color-wheel-sat');
        const colorHueHandle = document.getElementById('color-hue-handle');
        const colorSatHandle = document.getElementById('color-sat-handle');
        const colorLightnessInput = document.getElementById('color-lightness-input');
        const colorPickerDone = document.getElementById('color-picker-done');

        let colorPickerState = { wrap: null, input: null, swatch: null, h: 0, s: 100, l: 50 };
        const WHEEL_SIZE = 260;
        const WHEEL_PADDING = 12;
        const WHEEL_INNER_R = (WHEEL_SIZE / 2) - WHEEL_PADDING;

        function openColorPicker(wrap) {
            const input = wrap.querySelector('.player-color-input');
            const swatch = wrap.querySelector('.color-swatch');
            const hex = input.value || '#e74c3c';
            const hsl = hexToHSL(hex);
            colorPickerState = { wrap, input, swatch, h: hsl.h, s: hsl.s, l: hsl.l };
            colorLightnessInput.value = Math.round(hsl.l);
            colorPickerModal.classList.add('open');
            updatePickerGradient();
            updatePickerHandles();
        }

        function updatePickerGradient() {
            const { h } = colorPickerState;
            const gray = hslToHex(h, 0, 50);
            const hueColor = hslToHex(h, 100, 50);
            colorWheelSat.style.setProperty('--picker-gray', gray);
            colorWheelSat.style.setProperty('--picker-hue-color', hueColor);
        }

        function updatePickerHandles() {
            const { h, s } = colorPickerState;
            const rad = (h - 90) * Math.PI / 180;
            const hueR = 48;
            colorHueHandle.style.left = (50 + hueR * Math.cos(rad)) + '%';
            colorHueHandle.style.top = (50 + hueR * Math.sin(rad)) + '%';
            const satR = (s / 100) * 42;
            colorSatHandle.style.left = (50 + satR) + '%';
            colorSatHandle.style.top = '50%';
        }

        function commitPickerColor() {
            const { input, swatch, h, s, l } = colorPickerState;
            const hex = hslToHex(h, s, l);
            if (input) input.value = hex;
            if (swatch) swatch.style.background = hex;
        }

        function getWheelXY(e) {
            const rect = colorWheelContainer.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const x = (e.clientX ?? e.touches?.[0]?.clientX) - cx;
            const y = (e.clientY ?? e.touches?.[0]?.clientY) - cy;
            const dist = Math.sqrt(x * x + y * y);
            const angle = Math.atan2(y, x);
            return { x, y, dist, angle };
        }

        function onWheelPointerDown(e) {
            e.preventDefault();
            const { dist, angle } = getWheelXY(e);
            const isHue = dist > WHEEL_INNER_R;
            let move = (e2) => {
                const xy = getWheelXY(e2);
                if (isHue) {
                    colorPickerState.h = ((xy.angle * 180 / Math.PI + 90) + 360) % 360;
                    updatePickerGradient();
                } else {
                    colorPickerState.s = Math.min(100, Math.max(0, (xy.dist / WHEEL_INNER_R) * 100));
                    updatePickerHandles();
                }
                updatePickerHandles();
                commitPickerColor();
            };
            const up = () => {
                document.removeEventListener('pointermove', move);
                document.removeEventListener('pointerup', up);
                document.removeEventListener('touchmove', move, { passive: false });
                document.removeEventListener('touchend', up);
            };
            if (isHue) {
                colorPickerState.h = ((angle * 180 / Math.PI + 90) + 360) % 360;
                updatePickerGradient();
            } else {
                colorPickerState.s = Math.min(100, Math.max(0, (dist / WHEEL_INNER_R) * 100));
            }
            updatePickerHandles();
            commitPickerColor();
            document.addEventListener('pointermove', move);
            document.addEventListener('pointerup', up);
            document.addEventListener('touchmove', move, { passive: false });
            document.addEventListener('touchend', up);
        }

        document.addEventListener('click', (e) => {
            const wrap = e.target.closest('.color-picker-wrap');
            if (wrap) {
                e.preventDefault();
                openColorPicker(wrap);
            }
        });

        colorWheelContainer.addEventListener('pointerdown', onWheelPointerDown);
        colorWheelContainer.addEventListener('touchstart', onWheelPointerDown, { passive: false });

        colorLightnessInput.addEventListener('input', () => {
            colorPickerState.l = parseInt(colorLightnessInput.value, 10);
            commitPickerColor();
        });

        colorPickerDone.addEventListener('click', () => {
            colorPickerModal.classList.remove('open');
        });

        colorPickerModal.addEventListener('click', (e) => {
            if (e.target === colorPickerModal) colorPickerModal.classList.remove('open');
        });

        // Setup: Player count selection
        document.querySelectorAll('.player-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const count = parseInt(btn.dataset.count);
                setupPlayerInputs(count);
            });
        });

        function setupPlayerInputs(count) {
            playerSetup.innerHTML = '';
            playerSetup.classList.add('visible');
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }

            const usedColors = new Set();

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                const defaultHex = COLORS[i % COLORS.length].hex;
                div.innerHTML = `
                    <span>P${i + 1}</span>
                    <input type="text" placeholder="Player ${i + 1} Name" data-player="${i}" maxlength="30">
                    <div class="color-picker" data-player="${i}">
                        <div class="color-picker-wrap" data-player="${i}" title="Pick your color">
                            <span class="color-swatch" style="background: ${defaultHex};"></span>
                            <input type="color" class="player-color-input" data-player="${i}" value="${defaultHex}" aria-hidden="true">
                        </div>
                    </div>
                `;
                playerSetup.appendChild(div);
            }

            playerSetup.querySelectorAll('input[type="text"]').forEach(input => {
                input.addEventListener('input', checkDuplicateNames);
            });

            startGameBtn.style.display = 'block';
        }

        function checkDuplicateNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error-duplicate'));

            const names = [];
            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const nameCount = {};
            names.forEach(n => {
                const key = n.toLowerCase();
                nameCount[key] = (nameCount[key] || 0) + 1;
            });

            const duplicates = new Set(Object.entries(nameCount).filter(([, c]) => c > 1).map(([k]) => k));

            if (duplicates.size > 0) {
                inputs.forEach((input, idx) => {
                    if (duplicates.has(names[idx].toLowerCase())) {
                        input.closest('.player-input').classList.add('error-duplicate');
                    }
                });
                errorEl.textContent = `Names must be unique: ${[...duplicates].join(', ')} appears more than once.`;
                errorEl.classList.remove('hidden');
            } else {
                errorEl.classList.add('hidden');
                errorEl.textContent = '';
            }
        }

        function getDefaultHp(playerCount) {
            if (playerCount <= 2) return 50;
            if (playerCount <= 4) return 40;
            return 60; // 5-6 players
        }

        const NAME_MIN_LEN = 2;
        const NAME_MAX_LEN = 30;

        function validatePlayerNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');
            const names = [];
            let firstInvalidInput = null;

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error', 'error-duplicate'));

            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const duplicateNames = new Set(
                names.filter((n, i) => names.findIndex(x => x.toLowerCase() === n.toLowerCase()) !== i)
                    .map(n => n.toLowerCase())
            );

            for (let idx = 0; idx < inputs.length; idx++) {
                const input = inputs[idx];
                const raw = input.value.trim();
                const name = raw || `Player ${idx + 1}`;
                const playerInputEl = input.closest('.player-input');

                if (raw) {
                    if (raw.length < NAME_MIN_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    } else if (raw.length > NAME_MAX_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    }
                }

                if (duplicateNames.has(name.toLowerCase())) {
                    if (!firstInvalidInput) firstInvalidInput = input;
                    playerInputEl.classList.add('error', 'error-duplicate');
                }
            }

            const errors = [];
            inputs.forEach((input, idx) => {
                const el = input.closest('.player-input');
                if (!el.classList.contains('error')) return;
                const raw = input.value.trim();
                if (raw && raw.length < NAME_MIN_LEN) {
                    errors.push(`"${raw || input.value}" is too short (min ${NAME_MIN_LEN} characters).`);
                } else if (raw && raw.length > NAME_MAX_LEN) {
                    errors.push(`"${input.value}" is too long (max ${NAME_MAX_LEN} characters).`);
                }
            });
            if (duplicateNames.size > 0) {
                errors.push(`Names must be unique: ${[...duplicateNames].join(', ')} appears more than once.`);
            }

            if (errors.length > 0) {
                errorEl.textContent = errors.join(' ');
                errorEl.classList.remove('hidden');
                if (firstInvalidInput) firstInvalidInput.focus();
                return false;
            }
            errorEl.classList.add('hidden');
            errorEl.textContent = '';
            return true;
        }

        startGameBtn.addEventListener('click', () => {
            if (!validatePlayerNames()) return;

            const nameInputs = playerSetup.querySelectorAll('input[type="text"]');
            state.players = [];
            const defaultHp = getDefaultHp(nameInputs.length);

            nameInputs.forEach((input, idx) => {
                const colorPicker = playerSetup.querySelector(`.color-picker[data-player="${idx}"]`);
                const colorInput = colorPicker.querySelector('input[type="color"]');
                const hex = colorInput ? colorInput.value : COLORS[idx % COLORS.length].hex;
                const name = input.value.trim() || `Player ${idx + 1}`;

                state.players.push({
                    id: idx,
                    name,
                    color: { name: 'Custom', hex },
                    hp: defaultHp,
                    maxHp: defaultHp,
                    turnOrderRoll: 0,
                    eliminated: false
                });
            });

            showTurnOrderScreen();

            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                setTimeout(() => {
                    document.getElementById('roll-turn-order-btn')?.click();
                }, 400);
            }
        });

        function showTurnOrderScreen() {
            setupScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                rollBtn.classList.add('hidden');
            }

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');
        }

        document.getElementById('roll-turn-order-btn').addEventListener('click', async () => {
            const btn = document.getElementById('roll-turn-order-btn');
            btn.disabled = true;

            for (let player of state.players) {
                const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                const rollValue = playerDiv.querySelector('.roll-value');

                for (let i = 0; i < 10; i++) {
                    rollValue.textContent = rollD20();
                    await sleep(50);
                }

                player.turnOrderRoll = rollD20();
                rollValue.textContent = player.turnOrderRoll;
                await sleep(300);
            }

            state.players.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

            const rollsDiv = document.getElementById('turn-order-rolls');
            const tieMessage = document.createElement('p');
            tieMessage.id = 'tie-reroll-message';
            tieMessage.style.cssText = 'color: #feca57; margin: 15px 0; font-weight: bold;';
            tieMessage.style.display = 'none';
            if (!document.getElementById('tie-reroll-message')) {
                rollsDiv.parentNode.insertBefore(tieMessage, rollsDiv.nextSibling);
            }

            function updateTurnOrderDisplay() {
                rollsDiv.innerHTML = state.players.map((p, idx) => `
                    <div class="turn-order-player" data-player="${p.id}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                            <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                            <span>${p.name}</span>
                        </div>
                        <span class="roll-value">${p.turnOrderRoll}</span>
                    </div>
                `).join('');
            }

            // Find tie groups (consecutive players with same roll) - each resolves independently
            const tieGroupsWithIndex = [];
            for (let i = 0; i < state.players.length; i++) {
                const startIdx = i;
                const group = [state.players[i]];
                while (i + 1 < state.players.length && state.players[i + 1].turnOrderRoll === state.players[i].turnOrderRoll) {
                    group.push(state.players[++i]);
                }
                if (group.length > 1) {
                    tieGroupsWithIndex.push({ startIdx, players: group });
                }
            }

            // Resolve each tie group in isolation - only the tied players reroll for their slots
            for (const { startIdx, players: tiedPlayers } of tieGroupsWithIndex) {
                let hasTieInGroup;
                do {
                    hasTieInGroup = false;
                    tieMessage.textContent = `Tie between ${tiedPlayers.map(p => p.name).join(', ')}! Rerolling for slot...`;
                    tieMessage.style.display = 'block';
                    await sleep(500);

                    for (let player of tiedPlayers) {
                        const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (playerDiv) {
                            const rollValue = playerDiv.querySelector('.roll-value');
                            for (let i = 0; i < 8; i++) {
                                rollValue.textContent = rollD20();
                                await sleep(40);
                            }
                        }
                        player.turnOrderRoll = rollD20();
                        const div = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (div) div.querySelector('.roll-value').textContent = player.turnOrderRoll;
                        await sleep(200);
                    }

                    tiedPlayers.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

                    for (let j = 0; j < tiedPlayers.length - 1; j++) {
                        if (tiedPlayers[j].turnOrderRoll === tiedPlayers[j + 1].turnOrderRoll) {
                            hasTieInGroup = true;
                            break;
                        }
                    }

                    for (let j = 0; j < tiedPlayers.length; j++) {
                        state.players[startIdx + j] = tiedPlayers[j];
                    }
                    updateTurnOrderDisplay();
                    tieMessage.style.display = 'none';
                    await sleep(300);
                } while (hasTieInGroup);
            }

            tieMessage.style.display = 'none';
            await sleep(500);
            rollsDiv.innerHTML = state.players.map((p, idx) => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">${p.turnOrderRoll}</span>
                </div>
            `).join('');

            btn.classList.add('hidden');
            const beginBtn = document.getElementById('begin-game-btn');
            beginBtn.classList.remove('hidden');
            if (localStorage.getItem('daggerdie_autoBeginGame') === 'true') {
                beginBtn.classList.add('hidden');
                setTimeout(() => beginBtn.click(), 500);
            }
        });

        document.getElementById('begin-game-btn').addEventListener('click', () => {
            turnOrderScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            state.phase = 'playing';
            state.currentPlayerIndex = 0;
            updateGameUI();
        });

        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCurrentPlayer() {
            return state.players[state.currentPlayerIndex];
        }

        function getAlivePlayers() {
            return state.players.filter(p => !p.eliminated);
        }

        function updateGameUI() {
            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            clearHighlights();
            resetDice();
            diceResults.innerHTML = '';
            hitInfo.innerHTML = '';
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.add('hidden');
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.hits = [];
            state.totalDamage = 0;
            state.currentHitIndex = 0;
            state.attackLog = [];
            rollDiceBtn.disabled = false;
            disableTargetSelection();

            if (localStorage.getItem('daggerdie_autoRollDice') === 'true') {
                rollDiceBtn.classList.add('hidden');
                setTimeout(() => rollDiceBtn.click(), 300);
            } else {
                rollDiceBtn.classList.remove('hidden');
            }
        }

        function updatePlayersPanel() {
            const currentPlayer = getCurrentPlayer();
            playersPanel.innerHTML = state.players.map(p => `
                <div class="player-card ${p.id === currentPlayer.id ? 'current' : ''} ${p.eliminated ? 'eliminated' : ''}"
                     data-player="${p.id}">
                    <div class="player-avatar" style="background: ${p.color.hex};"></div>
                    <div class="player-name">${p.name}</div>
                    <div class="player-hp">${p.hp} HP</div>
                    <div class="hp-bar">
                        <div class="hp-fill" style="width: ${(p.hp / p.maxHp) * 100}%; background: ${p.color.hex};"></div>
                    </div>
                    <div class="player-turn-order">Turn Order: #${state.players.indexOf(p) + 1}</div>
                </div>
            `).join('');
        }

        function updateCurrentPlayerDisplay() {
            const current = getCurrentPlayer();
            currentPlayerNameEl.textContent = current.name;
            currentPlayerNameEl.style.color = current.color.hex;
        }

        rollDiceBtn.addEventListener('click', async () => {
            if (state.hasRolled) return;

            rollDiceBtn.disabled = true;
            const dice = [
                document.getElementById('die1'),
                document.getElementById('die2'),
                document.getElementById('die3')
            ];

            dice.forEach(die => {
                die.classList.add('rolling');
                die.classList.remove('odd', 'even');
            });

            for (let i = 0; i < 15; i++) {
                dice.forEach(die => {
                    die.textContent = rollD20();
                });
                await sleep(50);
            }

            state.currentRoll = [rollD20(), rollD20(), rollD20()];
            state.hits = [];
            state.totalDamage = 0;
            state.damageClaimedPhase = false;

            dice.forEach((die, idx) => {
                die.classList.remove('rolling');
                const value = state.currentRoll[idx];
                die.textContent = value;
                die.classList.add(value % 2 === 0 ? 'even' : 'odd');
            });

            highlightTargets(state.currentRoll);
            displayRollResults();

            state.hasRolled = true;
            showHitRecorder();
        });

        function highlightTargets(rolls) {
            clearHighlights();
            rolls.forEach(roll => {
                const zone = document.querySelector(`.highlight-zone[data-number="${roll}"]`);
                if (zone) {
                    zone.classList.add('active');
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                zone.classList.remove('active');
            });
        }

        function displayRollResults() {
            diceResults.innerHTML = `
                <p>Rolled: <strong>${state.currentRoll.join(', ')}</strong></p>
                <p>Odd targets: <span style="color: #ff6b6b;">${state.currentRoll.filter(r => r % 2 === 1).join(', ') || 'None'}</span></p>
                <p>Even targets: <span style="color: #48dbfb;">${state.currentRoll.filter(r => r % 2 === 0).join(', ') || 'None'}</span></p>
            `;
        }

        function showHitRecorder(initialHits) {
            const currentPlayer = getCurrentPlayer();

            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice() : [];

            attackPrompt.classList.remove('hidden');
            attackPrompt.innerHTML = `<strong>Step 1:</strong> Throw your knives! Click each number you HIT on the target to claim damage points.`;

            const hitIdxSet = new Set(state.hits.map(h => h.idx));

            hitInfo.innerHTML = `
                <div style="width: 100%; text-align: center; margin-bottom: 15px;">
                    <p style="font-size: 1.1rem;">Click the numbers you <strong>HIT</strong> on the target:</p>
                </div>
                <div class="hit-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    ${state.currentRoll.map((roll, idx) => `
                        <button class="btn hit-toggle ${hitIdxSet.has(idx) ? 'hit' : ''}" data-roll="${roll}" data-idx="${idx}" style="min-width: 70px; font-size: 1.3rem; ${hitIdxSet.has(idx) ? 'background: #2ecc71;' : ''}">
                            ${roll}
                        </button>
                    `).join('')}
                </div>
                <div style="margin-top: 20px;">
                    <p style="font-size: 1.3rem;">Damage Claimed: <strong id="total-damage-display" style="color: #feca57; font-size: 1.5rem;">${state.hits.reduce((sum, h) => sum + h.roll, 0)}</strong></p>
                    <button class="btn btn-primary" id="confirm-hits-btn" style="margin-top: 15px;">Confirm</button>
                </div>
            `;

            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    const roll = parseInt(btn.dataset.roll);
                    const idx = parseInt(btn.dataset.idx);

                    if (btn.classList.contains('hit')) {
                        btn.classList.remove('hit');
                        btn.style.background = '';
                        state.hits = state.hits.filter(h => h.idx !== idx);
                    } else {
                        btn.classList.add('hit');
                        btn.style.background = '#2ecc71';
                        state.hits.push({ roll, idx });
                    }

                    state.totalDamage = state.hits.reduce((sum, h) => sum + h.roll, 0);
                    document.getElementById('total-damage-display').textContent = state.totalDamage;
                });
            });

            document.getElementById('confirm-hits-btn').addEventListener('click', () => {
                state.totalDamage = state.hits.reduce((sum, h) => sum + h.roll, 0);

                if (state.totalDamage > 0) {
                    addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => h.roll).join(', ')})`, 'info');
                    showTargetSelection();
                } else {
                    if (confirm('No hits recorded. Did you miss all targets?')) {
                        addLogEntry(`${currentPlayer.name} missed all targets!`, 'info');
                        finishTurnNoAttack();
                    }
                }
            });
        }

        function showTargetSelection() {
            state.damageClaimedPhase = true;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.attackAssignments = [];

            showNextHitToAssign();
        }

        function showNextHitToAssign() {
            const currentPlayer = getCurrentPlayer();

            if (state.currentHitIndex >= state.hits.length) {
                finishAttackPhase();
                return;
            }

            const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
            if (aliveOpponents.length === 0) {
                finishAttackPhase();
                return;
            }

            const currentHit = state.hits[state.currentHitIndex];
            const remainingHits = state.hits.slice(state.currentHitIndex);

            attackPrompt.innerHTML = `<strong>Step 2:</strong> Assign hit <span style="color: #feca57; font-size: 1.3rem;">${currentHit.roll}</span> damage - Click an opponent to attack!`;

            hitInfo.innerHTML = `
                <div class="editable-hits-box" id="editable-hits-box" style="background: rgba(46, 204, 113, 0.2); padding: 10px; border-radius: 10px; border: 2px solid #2ecc71; margin-bottom: 10px; cursor: pointer; transition: background 0.2s, border-color 0.2s;" title="Tap to edit hits">
                    <p style="margin-bottom: 5px; font-size: 0.9rem;">Hits to assign <span style="font-size: 0.8rem; opacity: 0.8;">(tap to edit)</span>:</p>
                    <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        ${remainingHits.map((h, idx) => `
                            <span style="
                                padding: 8px 15px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 1.2rem;
                                background: ${idx === 0 ? '#feca57' : 'rgba(255,255,255,0.2)'};
                                color: ${idx === 0 ? '#1a1a2e' : '#fff'};
                                ${idx === 0 ? 'box-shadow: 0 0 10px rgba(254,202,87,0.5);' : ''}
                            ">${h.roll}</span>
                        `).join('')}
                    </div>
                </div>
                ${state.attackLog.length > 0 ? `
                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 5px;">
                        ${state.attackLog.join('<br>')}
                    </div>
                ` : ''}
            `;

            document.getElementById('editable-hits-box').addEventListener('click', () => {
                if (!confirm('Edit hits? You\'ll change which rolls counted as hits and confirm again. Any damage already assigned will be undone.')) return;
                state.attackAssignments.forEach(({ playerId, roll }) => {
                    const p = state.players.find(pl => pl.id === playerId);
                    if (p) {
                        p.hp += roll;
                        if (p.hp > 0) p.eliminated = false;
                    }
                });
                state.damageClaimedPhase = false;
                state.currentHitIndex = 0;
                state.attackLog = [];
                state.attackAssignments = [];
                updatePlayersPanel();
                checkWinCondition();
                showHitRecorder(state.hits);
            });

            enableTargetSelection();
        }

        function enableTargetSelection() {
            const current = getCurrentPlayer();
            const cards = document.querySelectorAll('.player-card');

            cards.forEach(card => {
                const playerId = parseInt(card.dataset.player);
                const player = state.players.find(p => p.id === playerId);

                if (!player.eliminated && player.id !== current.id) {
                    card.classList.add('targetable');
                    card.addEventListener('click', handleAttack);
                }
            });
        }

        function disableTargetSelection() {
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('targetable');
                card.removeEventListener('click', handleAttack);
            });
        }

        function handleAttack(e) {
            const card = e.currentTarget;
            const playerId = parseInt(card.dataset.player);
            const targetPlayer = state.players.find(p => p.id === playerId);
            const currentPlayer = getCurrentPlayer();
            const currentHit = state.hits[state.currentHitIndex];

            disableTargetSelection();

            state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHit.roll });
            targetPlayer.hp = Math.max(0, targetPlayer.hp - currentHit.roll);
            addLogEntry(`${currentPlayer.name} dealt ${currentHit.roll} damage to ${targetPlayer.name}!`, 'damage');
            state.attackLog.push(`${currentHit.roll} ‚Üí ${targetPlayer.name}`);

            if (targetPlayer.hp <= 0) {
                targetPlayer.eliminated = true;
                addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
            }

            updatePlayersPanel();
            checkWinCondition();

            state.currentHitIndex++;

            if (state.phase === 'playing') {
                showNextHitToAssign();
            }
        }

        function finishAttackPhase() {
            const totalDealt = state.hits.reduce((sum, h) => sum + h.roll, 0);

            hitInfo.innerHTML = `
                <div style="background: rgba(255, 107, 107, 0.2); padding: 15px; border-radius: 10px; border: 2px solid #ff6b6b;">
                    <p style="font-size: 1.1rem; margin-bottom: 8px;">Attacks Complete!</p>
                    <div style="font-size: 0.9rem;">
                        ${state.attackLog.map(log => `<div>${log}</div>`).join('')}
                    </div>
                    <p style="margin-top: 8px;">Total Damage: <strong style="color: #ff6b6b;">${totalDealt}</strong></p>
                </div>
            `;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        function finishTurnNoAttack() {
            hitInfo.innerHTML = `<span class="hit-badge miss">No damage this turn</span>`;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        droppedKnifeBtn.addEventListener('click', () => {
            const current = getCurrentPlayer();
            current.hp = Math.max(0, current.hp - 1);
            addLogEntry(`${current.name} dropped a knife! (-1 HP)`, 'damage');
            updatePlayersPanel();

            if (current.hp <= 0) {
                current.eliminated = true;
                addLogEntry(`${current.name} has been eliminated!`, 'info');
                checkWinCondition();
                if (state.phase === 'playing') {
                    nextTurn();
                }
            }
        });

        endTurnBtn.addEventListener('click', () => {
            nextTurn();
        });

        function nextTurn() {
            disableTargetSelection();

            let nextIdx = state.currentPlayerIndex;
            const alivePlayers = getAlivePlayers();

            if (alivePlayers.length <= 1) {
                checkWinCondition();
                return;
            }

            do {
                nextIdx = (nextIdx + 1) % state.players.length;
            } while (state.players[nextIdx].eliminated);

            state.currentPlayerIndex = nextIdx;
            addLogEntry(`${getCurrentPlayer().name}'s turn begins.`, 'info');
            updateGameUI();
        }

        function checkWinCondition() {
            const alivePlayers = getAlivePlayers();
            if (alivePlayers.length === 1) {
                state.phase = 'finished';
                showWinner(alivePlayers[0]);
            } else if (alivePlayers.length === 0) {
                state.phase = 'finished';
                showWinner(null);
            }
        }

        function showWinner(winner) {
            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'block';

            if (winner) {
                document.getElementById('winner-name').innerHTML = `
                    <div style="width: 80px; height: 80px; border-radius: 50%; background: ${winner.color.hex}; margin: 0 auto 20px;"></div>
                    <span style="color: ${winner.color.hex};">${winner.name}</span> Wins!
                `;
            } else {
                document.getElementById('winner-name').textContent = "It's a Draw!";
            }
        }

        function resetDice() {
            ['die1', 'die2', 'die3'].forEach(id => {
                const die = document.getElementById(id);
                die.textContent = '-';
                die.classList.remove('odd', 'even', 'rolling');
            });
        }

        function addLogEntry(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            gameLogEntries.insertBefore(entry, gameLogEntries.firstChild);
        }

        document.getElementById('new-game-btn').addEventListener('click', resetGame);
        document.getElementById('play-again-btn').addEventListener('click', resetGame);

        function resetGame() {
            state.players = [];
            state.currentPlayerIndex = 0;
            state.phase = 'setup';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.attackLog = [];

            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'none';
            turnOrderScreen.style.display = 'none';
            setupScreen.style.display = 'block';

            document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
            playerSetup.innerHTML = '';
            playerSetup.classList.remove('visible');
            startGameBtn.style.display = 'none';
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }
            gameLogEntries.innerHTML = '';

            document.getElementById('roll-turn-order-btn').classList.remove('hidden');
            document.getElementById('roll-turn-order-btn').disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');
        }
    </script>
</body>
</html>
