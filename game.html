<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger & Die - Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&display=swap" rel="stylesheet">
    <!-- Google Analytics (GA4) - Replace G-XXXXXXXXXX with your Measurement ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0c18;
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* ── RPG background layers (from playersbkgnd.html) ── */
        .game-bg-base {
            position: fixed; inset: 0; z-index: 0;
            background:
                radial-gradient(ellipse 120% 80% at 50% 110%, #1a1040 0%, transparent 60%),
                radial-gradient(ellipse 80% 60% at 20% 80%, #0d1a3a 0%, transparent 50%),
                radial-gradient(ellipse 80% 60% at 80% 80%, #1a0d2e 0%, transparent 50%),
                radial-gradient(ellipse 100% 50% at 50% 0%, #0f1628 0%, transparent 60%),
                linear-gradient(180deg, #080b16 0%, #0e1225 40%, #141833 70%, #1a1040 100%);
        }
        .game-bg-texture {
            position: fixed; inset: 0; z-index: 1;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='60' height='60' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
            background-size: 200px 200px;
        }
        .game-bg-vignette {
            position: fixed; inset: 0; z-index: 2;
            background: radial-gradient(ellipse 70% 60% at 50% 50%, transparent 30%, rgba(5,5,15,0.7) 100%);
            pointer-events: none;
        }
        .game-bg-grid {
            position: fixed; inset: 0; z-index: 2;
            pointer-events: none;
            opacity: 0.02;
            background-image:
                linear-gradient(rgba(150,160,200,0.3) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150,160,200,0.3) 1px, transparent 1px);
            background-size: 60px 60px;
        }
        .game-bg-fog {
            position: fixed; inset: 0; z-index: 3; pointer-events: none;
            overflow: hidden;
        }
        .game-bg-fog-layer {
            position: absolute; width: 200%; height: 100%;
            top: 0; left: -50%;
            background:
                radial-gradient(ellipse 300px 80px at 20% 70%, rgba(100,120,180,0.06) 0%, transparent 70%),
                radial-gradient(ellipse 400px 100px at 60% 80%, rgba(80,60,140,0.05) 0%, transparent 70%),
                radial-gradient(ellipse 250px 60px at 80% 60%, rgba(60,80,160,0.04) 0%, transparent 70%);
            animation: gameFogDrift 40s ease-in-out infinite alternate;
        }
        .game-bg-fog-layer:nth-child(2) {
            background:
                radial-gradient(ellipse 350px 90px at 30% 85%, rgba(70,50,120,0.05) 0%, transparent 70%),
                radial-gradient(ellipse 280px 70px at 70% 75%, rgba(90,100,170,0.04) 0%, transparent 70%);
            animation: gameFogDrift2 55s ease-in-out infinite alternate;
            opacity: 0.8;
        }
        @keyframes gameFogDrift {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(5%) translateY(-2%); }
        }
        @keyframes gameFogDrift2 {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(-4%) translateY(1%); }
        }
        .game-bg-particles { position: fixed; inset: 0; z-index: 4; pointer-events: none; overflow: hidden; }
        .game-bg-particle {
            position: absolute; border-radius: 50%; opacity: 0;
            animation: gameFloatUp linear infinite;
        }
        @keyframes gameFloatUp {
            0% { opacity: 0; transform: translateY(0) translateX(0) scale(1); }
            10% { opacity: 1; }
            90% { opacity: 0.6; }
            100% { opacity: 0; transform: translateY(-100vh) translateX(40px) scale(0.3); }
        }
        .game-bg-runes { position: fixed; inset: 0; z-index: 5; pointer-events: none; overflow: hidden; }
        .game-bg-rune {
            position: absolute; font-family: serif; opacity: 0;
            animation: gameRuneFloat 12s ease-in-out infinite;
            filter: blur(0.5px);
            text-shadow: 0 0 8px currentColor, 0 0 20px currentColor;
        }
        @keyframes gameRuneFloat {
            0% { opacity: 0; transform: translateY(20px) rotate(0deg) scale(0.8); }
            15% { opacity: 0.15; }
            50% { opacity: 0.25; transform: translateY(-10px) rotate(5deg) scale(1); }
            85% { opacity: 0.12; }
            100% { opacity: 0; transform: translateY(-30px) rotate(-3deg) scale(0.9); }
        }
        .game-bg-corner { position: fixed; z-index: 6; width: 120px; height: 120px; pointer-events: none; opacity: 0.12; }
        .game-bg-corner svg { width: 100%; height: 100%; }
        .game-bg-corner-tl { top: 12px; left: 12px; }
        .game-bg-corner-tr { top: 12px; right: 12px; transform: scaleX(-1); }
        .game-bg-corner-bl { bottom: 12px; left: 12px; transform: scaleY(-1); }
        .game-bg-corner-br { bottom: 12px; right: 12px; transform: scale(-1, -1); }
        .game-bg-ambient {
            position: fixed; z-index: 3; pointer-events: none;
            width: 500px; height: 500px; border-radius: 50%;
            background: radial-gradient(circle, rgba(180,140,60,0.03) 0%, transparent 70%);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            animation: gameAmbientPulse 8s ease-in-out infinite;
        }
        @keyframes gameAmbientPulse {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
        }
        .game-bg-torch {
            position: fixed; z-index: 3; pointer-events: none;
            width: 300px; height: 400px; border-radius: 50%;
            animation: gameTorchFlicker 3s ease-in-out infinite alternate;
        }
        .game-bg-torch-left { left: -100px; top: 30%; background: radial-gradient(ellipse, rgba(200,120,40,0.04) 0%, transparent 70%); animation-duration: 2.8s; }
        .game-bg-torch-right { right: -100px; top: 25%; background: radial-gradient(ellipse, rgba(200,120,40,0.035) 0%, transparent 70%); animation-duration: 3.2s; animation-delay: 0.5s; }
        @keyframes gameTorchFlicker {
            0% { opacity: 0.6; transform: scale(1); }
            25% { opacity: 1; transform: scale(1.05); }
            50% { opacity: 0.7; transform: scale(0.98); }
            75% { opacity: 0.9; transform: scale(1.02); }
            100% { opacity: 0.65; transform: scale(1); }
        }
        #gameParticleCanvas { position: fixed; inset: 0; z-index: 4; pointer-events: none; }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            text-align: center;
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 30px;
            color: #d4a84b;
            text-shadow: 3px 3px 0 #5c3d1e, 5px 5px 0 rgba(0,0,0,0.4), 0 0 30px rgba(212, 168, 75, 0.4), 0 0 60px rgba(212, 168, 75, 0.2);
            letter-spacing: 6px;
        }

        /* Setup Screen */
        #setup-screen {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            margin: 0 auto;
        }

        .setup-title {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5rem;
            color: #d4a84b;
            text-shadow: 2px 2px 0 #5c3d1e, 0 0 15px rgba(212, 168, 75, 0.3);
        }

        .player-count-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .player-count-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .player-count-btn:hover, .player-count-btn.selected {
            background: #48dbfb;
            transform: scale(1.1);
        }

        .player-setup {
            display: none;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-setup.visible {
            display: flex;
        }

        .player-input {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .player-input input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1rem;
        }

        .player-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .player-input.error input,
        .player-input.error-duplicate input {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.4);
        }

        .setup-error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 20px;
            color: #ff6b6b;
            font-size: 0.95rem;
        }

        .color-picker {
            display: flex;
            align-items: center;
        }

        .color-picker-wrap {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .color-picker-wrap:hover {
            transform: scale(1.12);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.8);
        }

        .color-swatch {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
        }

        .player-color-input {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }

        /* Custom circular color picker modal */
        .color-picker-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .color-picker-modal-overlay.open {
            display: flex;
        }

        .color-picker-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 100%;
        }

        .color-picker-modal h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: rgba(255,255,255,0.9);
        }

        .color-wheel-container {
            position: relative;
            width: 260px;
            height: 260px;
            margin: 0 auto 20px;
            touch-action: none;
        }

        .color-wheel-hue {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #ff0000, #ff8800, #ffff00, #88ff00, #00ff00, #00ff88, #00ffff, #0088ff, #0000ff, #8800ff, #ff00ff, #ff0088, #ff0000);
            padding: 12px;
        }

        .color-wheel-inner {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: #1e2a3a;
        }

        .color-wheel-sat {
            position: absolute;
            inset: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--picker-gray, #808080) 0%, var(--picker-hue-color, #f00) 100%);
            cursor: crosshair;
        }

        .color-wheel-hue-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .color-wheel-sat-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0,0,0,0.5);
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .color-picker-lightness {
            margin-bottom: 20px;
        }

        .color-picker-lightness label {
            display: block;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 8px;
        }

        .color-picker-lightness input[type="range"] {
            width: 100%;
            height: 28px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-top: -7px;
            cursor: pointer;
        }

        .color-picker-lightness input[type="range"]::-moz-range-track {
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, #000, #fff);
        }

        .color-picker-lightness input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            cursor: pointer;
        }

        .color-picker-done {
            display: block;
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(45deg, #48dbfb, #0abde3);
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-picker-done:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,171,227,0.4);
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(238, 90, 36, 0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .btn-danger {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            color: #fff;
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        /* Game Screen */
        #game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-gear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-gear-btn:hover {
            background: rgba(72, 219, 251, 0.3);
            color: #48dbfb;
        }

        .settings-gear-btn svg {
            width: 22px;
            height: 22px;
        }

        .settings-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .settings-modal-overlay.open {
            display: flex;
        }

        .settings-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .settings-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
        }

        .settings-modal label {
            display: block;
            margin-bottom: 8px;
            color: rgba(255,255,255,0.9);
            font-size: 0.95rem;
        }

        .settings-modal input[type="number"] {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .settings-modal input[type="number"]:focus {
            outline: none;
            border-color: #48dbfb;
        }

        .settings-modal .setting-hint {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 20px;
        }

        .settings-modal .setting-readonly-hint {
            color: #feca57;
            margin-bottom: 16px;
        }

        .settings-modal .option-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .settings-modal .option-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #48dbfb;
        }

        .settings-modal .option-row label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .settings-modal .custom-hp-row {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        .settings-modal input[type="number"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-modal .btn {
            width: 100%;
            margin-top: 8px;
        }

        /* Player stats modal */
        .player-stats-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .player-stats-modal-overlay.open {
            display: flex;
        }

        .player-stats-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 380px;
            width: 100%;
        }

        .player-stats-modal h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
            color: #feca57;
            text-align: center;
        }

        .player-stats-modal h4 {
            font-size: 1rem;
            color: #48dbfb;
            margin-bottom: 10px;
        }

        .player-stats-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
        }

        .player-stats-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .player-stats-meta {
            flex: 1;
        }

        .player-stats-row {
            margin-bottom: 6px;
            color: rgba(255,255,255,0.95);
            font-size: 1rem;
        }

        .player-stats-section {
            margin-bottom: 24px;
        }

        .player-stats-section .setting-hint {
            margin-bottom: 12px;
        }

        .player-stats-modal .btn {
            width: 100%;
        }

        /* Critical hit onscreen reaction */
        .critical-reaction {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .critical-reaction.show {
            opacity: 1;
            animation: critical-pulse 0.3s ease-out;
        }
        .critical-reaction.hide {
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }
        @keyframes critical-pulse {
            0% { transform: scale(0.85); }
            50% { transform: scale(1.06); }
            100% { transform: scale(1); }
        }
        .critical-reaction-inner {
            background: linear-gradient(135deg, rgba(254, 202, 87, 0.95) 0%, rgba(255, 107, 107, 0.9) 100%);
            color: #1a1a2e;
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            letter-spacing: 0.15em;
            padding: 24px 48px;
            border-radius: 16px;
            box-shadow: 0 0 60px rgba(254, 202, 87, 0.6), 0 0 120px rgba(255, 107, 107, 0.3);
            text-transform: uppercase;
        }

        .turn-indicator {
            font-size: 1.5rem;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .current-player-name {
            font-weight: bold;
        }

        /* Players Panel */
        .players-panel {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
            justify-content: center;
        }

        .player-card {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
            border: 3px solid transparent;
        }

        .player-card.current {
            border-color: #feca57;
            box-shadow: 0 0 20px rgba(254, 202, 87, 0.4);
            transform: scale(1.05);
        }

        .player-card.eliminated {
            opacity: 0.4;
            filter: grayscale(1);
        }

        .player-card.targetable {
            cursor: pointer;
        }

        .player-card.targetable:hover {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.4);
        }

        .player-card-stats-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s;
        }

        .player-card-stats-btn:hover {
            background: rgba(72, 219, 251, 0.4);
            color: #48dbfb;
        }

        .player-card-stats-btn svg {
            width: 16px;
            height: 16px;
        }

        .player-card-dropped {
            animation: dropped-flash 0.6s ease-out;
        }

        .player-card.buffed {
            border-color: #2ecc71;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }

        .player-card.buffed.current {
            border-color: #2ecc71;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.5), 0 0 15px rgba(254, 202, 87, 0.3);
        }

        .player-card.nerfed {
            border-color: #e74c3c;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
        }

        .player-card.nerfed.current {
            border-color: #e74c3c;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5), 0 0 15px rgba(254, 202, 87, 0.3);
        }

        .player-card-status {
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 6px;
            padding: 3px 8px;
            border-radius: 6px;
        }

        .player-card-status.buff {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
        }

        .player-card-status.nerf {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        /* Death ghost animation */
        .death-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            width: 60px;
            height: 70px;
            animation: ghost-float 1.8s ease-out forwards;
        }
        .death-ghost svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.5));
        }
        @keyframes ghost-float {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            30% { opacity: 1; transform: translateY(-20px) scale(1.05) translateX(0); }
            60% { opacity: 0.9; transform: translateY(-60px) scale(1) translateX(8px); }
            100% { opacity: 0; transform: translateY(-120px) scale(0.8) translateX(-5px); }
        }

        /* Miss confirmation modal */
        .miss-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1100;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .miss-modal-overlay.open {
            display: flex;
        }

        .miss-modal {
            background: linear-gradient(180deg, #1e2a3a 0%, #16213e 100%);
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 360px;
            width: 100%;
            border: 2px solid rgba(231, 76, 60, 0.4);
        }

        .miss-modal-player {
            font-family: 'Cinzel Decorative', 'Times New Roman', serif;
            font-size: 1.5rem;
            color: #d4a84b;
            text-align: center;
            margin-bottom: 8px;
        }

        .miss-modal-question {
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
            text-align: center;
            margin-bottom: 24px;
        }

        .miss-modal-buttons {
            display: flex;
            gap: 12px;
        }

        .miss-modal-buttons .btn {
            flex: 1;
        }

        /* Miss onscreen reaction */
        .miss-reaction {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        .miss-reaction.show {
            opacity: 1;
            animation: miss-pulse 0.3s ease-out;
        }
        .miss-reaction.hide {
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }
        @keyframes miss-pulse {
            0% { transform: scale(0.85); }
            50% { transform: scale(1.06); }
            100% { transform: scale(1); }
        }
        .miss-reaction-inner {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.95) 0%, rgba(139, 69, 69, 0.9) 100%);
            color: #fff;
            font-size: clamp(1.8rem, 6vw, 3rem);
            font-weight: 900;
            letter-spacing: 0.15em;
            padding: 20px 40px;
            border-radius: 16px;
            box-shadow: 0 0 60px rgba(231, 76, 60, 0.5);
            text-transform: uppercase;
        }

        @keyframes dropped-flash {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.8); transform: scale(1.05); }
            30% { box-shadow: 0 0 25px 8px rgba(255, 107, 107, 0.5); border-color: #ff6b6b; }
            100% { box-shadow: none; border-color: transparent; transform: scale(1); }
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-hp {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .hp-bar {
            width: 100%;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #2ecc71);
            transition: width 0.5s;
        }

        .player-turn-order {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        /* Game Area */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        /* Dice Section */
        .dice-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .section-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .die {
            width: 65px;
            height: 65px;
            background: linear-gradient(145deg, #2d3436, #1e272e);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .die.rolling {
            animation: roll 0.1s infinite;
        }

        .die.odd {
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .die.even {
            color: #48dbfb;
            border-color: #48dbfb;
        }

        @keyframes roll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.1); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.1); }
        }

        .roll-btn {
            display: block;
            margin: 0 auto 20px;
            padding: 15px 50px;
        }

        .dice-results {
            text-align: center;
            margin-top: 15px;
        }

        .total-damage {
            font-size: 1.5rem;
            color: #feca57;
        }

        /* Target Section */
        .targets-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
        }

        .targets-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .target-wrapper {
            position: relative;
            width: 180px;
        }

        .target-label {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.85rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .target-image-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border-radius: 20px;
            overflow: hidden;
            /* Card style matching setup screen / player cards */
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .target-image {
            width: 90%;
            height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            object-fit: contain;
            object-position: center;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            z-index: 2;
        }

        .target-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .target-board-inline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .target-overlay.clickable {
            pointer-events: auto;
        }

        .target-overlay.clickable .highlight-zone.active {
            cursor: pointer;
        }

        .target-overlay.clickable .highlight-zone:not(.active) {
            cursor: default;
        }

        .highlight-zone {
            cursor: pointer;
            pointer-events: all;
            transition: all 0.3s;
        }

        .highlight-zone polygon.face-shape {
            fill: rgba(45, 30, 55, 0.85);
            stroke: rgba(180, 160, 140, 0.5);
            stroke-width: 1.2;
            stroke-linejoin: round;
            transition: all 0.3s ease;
        }

        .highlight-zone.active polygon.face-shape {
            fill: rgba(251, 191, 36, 0.35);
            stroke: #fbbf24;
            stroke-width: 2.5;
            filter: url(#glow-odd);
            animation: pulse 1.5s infinite;
        }

        #even-overlay .highlight-zone.active polygon.face-shape {
            filter: url(#glow-even);
        }

        .highlight-zone.claimed polygon.face-shape {
            fill: rgba(34, 197, 94, 0.35);
            stroke: #22c55e;
            stroke-width: 2.5;
            filter: url(#glow-hit-odd);
            animation: none;
        }

        #even-overlay .highlight-zone.claimed polygon.face-shape {
            filter: url(#glow-hit-even);
        }

        .highlight-zone text {
            font-family: 'Cinzel Decorative', 'Cinzel', 'Palatino', serif;
            font-weight: bold;
            fill: rgba(200, 190, 180, 0.6);
            pointer-events: none;
            transition: fill 0.3s ease;
        }

        .highlight-zone.active text {
            fill: #fbbf24;
        }

        .highlight-zone.claimed text {
            fill: #22c55e;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Actions Section */
        .actions-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            text-align: center;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .attack-prompt {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #feca57;
        }

        .editable-hits-box:hover {
            background: rgba(46, 204, 113, 0.35) !important;
            border-color: #27ae60 !important;
        }

        .hit-info {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .hit-badge {
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .hit-badge.hit {
            background: #2ecc71;
        }

        .hit-badge.miss {
            background: #e74c3c;
        }

        /* Turn Order Screen */
        #turn-order-screen {
            display: none;
            text-align: center;
        }

        .turn-order-rolls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 30px auto;
        }

        .turn-order-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
        }

        .turn-order-player .roll-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #feca57;
        }

        /* Winner Screen */
        #winner-screen {
            display: none;
            text-align: center;
            padding: 60px 20px;
        }

        .winner-title {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px #feca57; }
            50% { text-shadow: 0 0 40px #feca57, 0 0 60px #ff6b6b; }
        }

        .winner-name {
            font-size: 2rem;
            margin-bottom: 40px;
        }

        /* Game Log */
        .game-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-damage {
            color: #ff6b6b;
        }

        .log-heal {
            color: #2ecc71;
        }

        .log-info {
            color: #48dbfb;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            .game-header {
                margin-bottom: 10px;
            }

            .turn-indicator {
                font-size: 1rem;
                padding: 8px 12px;
            }

            .players-panel {
                gap: 8px;
                margin-bottom: 15px;
            }

            .player-card {
                padding: 10px;
                min-width: 100px;
            }

            .player-avatar {
                width: 40px;
                height: 40px;
            }

            .player-hp {
                font-size: 1.1rem;
            }

            .player-turn-order {
                font-size: 0.7rem;
            }

            .game-area {
                gap: 15px;
            }

            .dice-section, .targets-section, .actions-section {
                padding: 15px;
                border-radius: 15px;
            }

            .section-title {
                font-size: 1rem;
                margin-bottom: 10px;
            }

            .die {
                width: 55px;
                height: 55px;
                font-size: 1.3rem;
            }

            .dice-container {
                gap: 10px;
                margin-bottom: 10px;
            }

            .roll-btn {
                padding: 10px 30px;
                font-size: 1rem;
            }

            .target-wrapper {
                width: 140px;
            }

            .target-label {
                font-size: 0.75rem;
                margin-bottom: 3px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .attack-prompt {
                font-size: 1rem;
            }

            .game-log {
                max-height: 100px;
                padding: 10px;
            }

            .log-entry {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 400px) {
            .target-wrapper {
                width: 120px;
            }

            .die {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }

            .player-card {
                min-width: 80px;
                padding: 8px;
            }

            .player-avatar {
                width: 30px;
                height: 30px;
            }

            .player-name {
                font-size: 0.85rem;
            }

            .player-hp {
                font-size: 0.95rem;
            }
        }

        /* Back to Home link */
        .back-link {
            display: inline-block;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 0.95rem;
            transition: color 0.3s;
        }

        .back-link:hover {
            color: #48dbfb;
        }
    </style>
</head>
<body>
    <!-- RPG background layers -->
    <div class="game-bg-base"></div>
    <div class="game-bg-texture"></div>
    <div class="game-bg-grid"></div>
    <div class="game-bg-vignette"></div>
    <div class="game-bg-fog">
        <div class="game-bg-fog-layer"></div>
        <div class="game-bg-fog-layer"></div>
    </div>
    <div class="game-bg-torch game-bg-torch-left"></div>
    <div class="game-bg-torch game-bg-torch-right"></div>
    <div class="game-bg-ambient"></div>
    <div class="game-bg-particles" id="gameCssParticles"></div>
    <div class="game-bg-runes" id="gameRuneContainer"></div>
    <canvas id="gameParticleCanvas"></canvas>
    <div class="game-bg-corner game-bg-corner-tl">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-tr">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-bl">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>
    <div class="game-bg-corner game-bg-corner-br">
        <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 5 L5 40 Q5 45 10 45 L20 45" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <path d="M5 5 L40 5 Q45 5 45 10 L45 20" stroke="#b48c3c" stroke-width="1.5" opacity="0.8"/>
            <circle cx="5" cy="5" r="3" fill="#b48c3c" opacity="0.6"/>
            <path d="M12 12 L12 30 M12 12 L30 12" stroke="#b48c3c" stroke-width="0.8" opacity="0.4"/>
            <path d="M18 5 Q18 18 5 18" stroke="#b48c3c" stroke-width="0.5" opacity="0.3" fill="none"/>
            <circle cx="20" cy="20" r="1.5" fill="#b48c3c" opacity="0.3"/>
            <path d="M30 8 L33 5 L36 8 L33 11 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
            <path d="M8 30 L5 33 L8 36 L11 33 Z" stroke="#b48c3c" stroke-width="0.6" fill="none" opacity="0.4"/>
        </svg>
    </div>

    <div class="container">
        <a href="index.html" class="back-link">← Back to Home</a>
        <h1>Dagger & Die</h1>

        <!-- Setup Screen -->
        <div id="setup-screen">
            <h2 class="setup-title">Select Number of Players</h2>
            <div class="player-count-selector">
                <button class="player-count-btn" data-count="2">2</button>
                <button class="player-count-btn" data-count="3">3</button>
                <button class="player-count-btn" data-count="4">4</button>
                <button class="player-count-btn" data-count="5">5</button>
                <button class="player-count-btn" data-count="6">6</button>
            </div>
            <div class="player-setup" id="player-setup"></div>
            <div class="setup-error hidden" id="setup-error" role="alert"></div>
            <button class="btn btn-primary btn-center" id="start-game-btn" style="display:none;">Start Game</button>
        </div>

        <!-- Turn Order Screen -->
        <div id="turn-order-screen">
            <h2 class="setup-title">Rolling for Turn Order</h2>
            <p>Each player rolls a D20 to determine turn order. Highest goes first!</p>
            <div class="turn-order-rolls" id="turn-order-rolls"></div>
            <button class="btn btn-primary" id="roll-turn-order-btn">Roll for Turn Order</button>
            <button class="btn btn-primary hidden" id="begin-game-btn">Begin Game!</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="game-header">
                <div class="turn-indicator">
                    Turn: <span class="current-player-name" id="current-player-name">-</span>
                </div>
                <div class="game-header-actions">
                    <button type="button" class="settings-gear-btn" id="settings-gear-btn" aria-label="Game settings">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary" id="new-game-btn">New Game</button>
                </div>
            </div>

            <div class="players-panel" id="players-panel"></div>

            <div class="game-area">
                <div class="dice-section">
                    <h3 class="section-title">Your Dice</h3>
                    <div class="dice-container">
                        <div class="die" id="die1">-</div>
                        <div class="die" id="die2">-</div>
                        <div class="die" id="die3">-</div>
                    </div>
                    <button class="btn btn-primary roll-btn" id="roll-dice-btn">Roll Dice</button>
                    <div class="dice-results" id="dice-results"></div>
                </div>

                <div class="targets-section">
                    <h3 class="section-title">Target Boards</h3>
                    <div class="targets-container">
                        <div class="target-wrapper">
                            <div class="target-label">Odd Numbers (1-19)</div>
                            <div class="target-image-container">
                                <svg class="target-board-inline target-overlay" id="odd-overlay" viewBox="-5 -5 210 210" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <filter id="glow-odd" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="4" result="blur"/>
                                            <feFlood flood-color="#fbbf24" flood-opacity="0.8" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <filter id="glow-hit-odd" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="5" result="blur"/>
                                            <feFlood flood-color="#22c55e" flood-opacity="0.9" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <radialGradient id="depth-odd" cx="50%" cy="40%" r="60%">
                                            <stop offset="0%" stop-color="rgba(255,255,255,0.06)"/>
                                            <stop offset="100%" stop-color="rgba(0,0,0,0.15)"/>
                                        </radialGradient>
                                    </defs>
                                    <!-- D20 decahedron faces (individually addressable triangular regions) -->
                                    <g class="highlight-zone" data-number="1">
                                        <polygon class="face-shape" points="100,50 157,148 43,148" stroke-linejoin="round"/>
                                        <polygon points="100,50 157,148 43,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="100" y="126" text-anchor="middle" font-size="32">1</text>
                                    </g>
                                    <g class="highlight-zone" data-number="3">
                                        <polygon class="face-shape" points="14,51 100,50 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,51 100,50 43,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="52" y="90" text-anchor="middle" font-size="26">3</text>
                                    </g>
                                    <g class="highlight-zone" data-number="7">
                                        <polygon class="face-shape" points="186,51 157,148 100,50" stroke-linejoin="round"/>
                                        <polygon points="186,51 157,148 100,50" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="148" y="90" text-anchor="middle" font-size="26">7</text>
                                    </g>
                                    <g class="highlight-zone" data-number="5">
                                        <polygon class="face-shape" points="100,198 43,148 157,148" stroke-linejoin="round"/>
                                        <polygon points="100,198 43,148 157,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="100" y="172" text-anchor="middle" font-size="26">5</text>
                                    </g>
                                    <g class="highlight-zone" data-number="17">
                                        <polygon class="face-shape" points="100,2 100,50 14,51" stroke-linejoin="round"/>
                                        <polygon points="100,2 100,50 14,51" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="71" y="41" text-anchor="middle" font-size="14">17</text>
                                    </g>
                                    <g class="highlight-zone" data-number="11">
                                        <polygon class="face-shape" points="100,2 186,51 100,50" stroke-linejoin="round"/>
                                        <polygon points="100,2 186,51 100,50" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="129" y="41" text-anchor="middle" font-size="14">11</text>
                                    </g>
                                    <g class="highlight-zone" data-number="15">
                                        <polygon class="face-shape" points="14,51 14,149 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,51 14,149 43,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="24" y="123" text-anchor="middle" font-size="14">15</text>
                                    </g>
                                    <g class="highlight-zone" data-number="13">
                                        <polygon class="face-shape" points="14,149 100,198 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,149 100,198 43,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="52" y="172" text-anchor="middle" font-size="14">13</text>
                                    </g>
                                    <g class="highlight-zone" data-number="19">
                                        <polygon class="face-shape" points="186,149 157,148 100,198" stroke-linejoin="round"/>
                                        <polygon points="186,149 157,148 100,198" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="148" y="172" text-anchor="middle" font-size="14">19</text>
                                    </g>
                                    <g class="highlight-zone" data-number="9">
                                        <polygon class="face-shape" points="186,51 186,149 157,148" stroke-linejoin="round"/>
                                        <polygon points="186,51 186,149 157,148" fill="url(#depth-odd)" stroke="none" pointer-events="none"/>
                                        <text x="176" y="123" text-anchor="middle" font-size="14">9</text>
                                    </g>
                                </svg>
                            </div>
                        </div>
                        <div class="target-wrapper">
                            <div class="target-label">Even Numbers (2-20)</div>
                            <div class="target-image-container">
                                <svg class="target-board-inline target-overlay" id="even-overlay" viewBox="-5 -5 210 210" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <filter id="glow-even" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="4" result="blur"/>
                                            <feFlood flood-color="#fbbf24" flood-opacity="0.8" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <filter id="glow-hit-even" x="-50%" y="-50%" width="200%" height="200%">
                                            <feGaussianBlur stdDeviation="5" result="blur"/>
                                            <feFlood flood-color="#22c55e" flood-opacity="0.9" result="color"/>
                                            <feComposite in="color" in2="blur" operator="in" result="shadow"/>
                                            <feMerge><feMergeNode in="shadow"/><feMergeNode in="shadow"/><feMergeNode in="SourceGraphic"/></feMerge>
                                        </filter>
                                        <radialGradient id="depth-even" cx="50%" cy="40%" r="60%">
                                            <stop offset="0%" stop-color="rgba(255,255,255,0.06)"/>
                                            <stop offset="100%" stop-color="rgba(0,0,0,0.15)"/>
                                        </radialGradient>
                                    </defs>
                                    <!-- D20 decahedron faces (individually addressable triangular regions) -->
                                    <g class="highlight-zone" data-number="2">
                                        <polygon class="face-shape" points="100,50 157,148 43,148" stroke-linejoin="round"/>
                                        <polygon points="100,50 157,148 43,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="100" y="126" text-anchor="middle" font-size="32">2</text>
                                    </g>
                                    <g class="highlight-zone" data-number="4">
                                        <polygon class="face-shape" points="14,51 100,50 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,51 100,50 43,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="52" y="90" text-anchor="middle" font-size="26">4</text>
                                    </g>
                                    <g class="highlight-zone" data-number="6">
                                        <polygon class="face-shape" points="186,51 157,148 100,50" stroke-linejoin="round"/>
                                        <polygon points="186,51 157,148 100,50" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="148" y="90" text-anchor="middle" font-size="26">6</text>
                                    </g>
                                    <g class="highlight-zone" data-number="8">
                                        <polygon class="face-shape" points="100,198 43,148 157,148" stroke-linejoin="round"/>
                                        <polygon points="100,198 43,148 157,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="100" y="172" text-anchor="middle" font-size="26">8</text>
                                    </g>
                                    <g class="highlight-zone" data-number="10">
                                        <polygon class="face-shape" points="100,2 100,50 14,51" stroke-linejoin="round"/>
                                        <polygon points="100,2 100,50 14,51" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="71" y="41" text-anchor="middle" font-size="14">10</text>
                                    </g>
                                    <g class="highlight-zone" data-number="20">
                                        <polygon class="face-shape" points="100,2 186,51 100,50" stroke-linejoin="round"/>
                                        <polygon points="100,2 186,51 100,50" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="129" y="41" text-anchor="middle" font-size="14">20</text>
                                    </g>
                                    <g class="highlight-zone" data-number="12">
                                        <polygon class="face-shape" points="14,51 14,149 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,51 14,149 43,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="24" y="123" text-anchor="middle" font-size="14">12</text>
                                    </g>
                                    <g class="highlight-zone" data-number="18">
                                        <polygon class="face-shape" points="14,149 100,198 43,148" stroke-linejoin="round"/>
                                        <polygon points="14,149 100,198 43,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="52" y="172" text-anchor="middle" font-size="14">18</text>
                                    </g>
                                    <g class="highlight-zone" data-number="16">
                                        <polygon class="face-shape" points="186,149 157,148 100,198" stroke-linejoin="round"/>
                                        <polygon points="186,149 157,148 100,198" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="148" y="172" text-anchor="middle" font-size="14">16</text>
                                    </g>
                                    <g class="highlight-zone" data-number="14">
                                        <polygon class="face-shape" points="186,51 186,149 157,148" stroke-linejoin="round"/>
                                        <polygon points="186,51 186,149 157,148" fill="url(#depth-even)" stroke="none" pointer-events="none"/>
                                        <text x="176" y="123" text-anchor="middle" font-size="14">14</text>
                                    </g>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="actions-section" id="actions-section">
                <h3 class="section-title">Actions</h3>
                <div class="hit-info" id="hit-info"></div>
                <div class="attack-prompt hidden" id="attack-prompt">Select a player to attack!</div>
                <div class="action-buttons">
                    <button class="btn btn-danger hidden" id="dropped-knife-btn">Dropped Knife (-1 HP)</button>
                    <button class="btn btn-primary hidden" id="end-turn-btn">End Turn</button>
                </div>
            </div>

            <div class="game-log">
                <h4>Game Log</h4>
                <div id="game-log-entries"></div>
            </div>
        </div>

        <!-- Winner Screen -->
        <div id="winner-screen">
            <h2 class="winner-title">Victory!</h2>
            <div class="winner-name" id="winner-name"></div>
            <div style="display: flex; justify-content: center; margin-bottom: 32px;">
                <button class="btn btn-secondary" id="export-report-btn">Export Game Report</button>
            </div>
            <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-primary" id="play-again-btn">Play Again</button>
                <button class="btn btn-primary" id="finished-btn">Finished</button>
            </div>
        </div>
    </div>

    <!-- Game settings modal -->
    <div class="settings-modal-overlay" id="settings-modal" role="dialog" aria-label="Game settings">
        <div class="settings-modal">
            <h3>Game Settings</h3>
            <p id="settings-readonly-hint" class="setting-hint setting-readonly-hint" style="display: none;">Settings are locked after the first damage is dealt. Start a new game to change them.</p>
            <div class="option-row">
                <input type="checkbox" id="use-custom-hp-cb" aria-describedby="custom-hp-hint">
                <label for="use-custom-hp-cb">Use custom HP</label>
            </div>
            <div class="custom-hp-row">
                <label for="custom-hp-input">Default HP per player (20–999)</label>
                <input type="number" id="custom-hp-input" min="20" max="999" placeholder="e.g. 50" disabled>
            </div>
            <p id="custom-hp-hint" class="setting-hint">When unchecked, automatic values are used (2 players: 50, 3–4: 40, 5–6: 60).</p>
            <div class="option-row" style="margin-top: 20px;">
                <input type="checkbox" id="persistent-settings-cb" aria-describedby="persistent-settings-hint">
                <label for="persistent-settings-cb">Persistent settings</label>
            </div>
            <p id="persistent-settings-hint" class="setting-hint">When unchecked (default), settings reset to defaults each new game. When checked, your selections are kept until you uncheck this.</p>
            <h4 class="settings-section-title" style="margin-top: 20px; margin-bottom: 10px; font-size: 1rem; color: #48dbfb;">Mods</h4>
            <div class="option-row">
                <input type="checkbox" id="mod-buff-on-critical-cb" aria-describedby="mod-buff-hint">
                <label for="mod-buff-on-critical-cb">Buff on Critical</label>
            </div>
            <p id="mod-buff-hint" class="setting-hint">Take 1/2 damage for 1 turn after scoring a critical.</p>
            <div class="option-row">
                <input type="checkbox" id="mod-nerf-on-miss-cb" aria-describedby="mod-nerf-hint">
                <label for="mod-nerf-on-miss-cb">Nerf on Miss</label>
            </div>
            <p id="mod-nerf-hint" class="setting-hint">Take 125% damage for 1 turn after missing all throws.</p>
            <div class="settings-modal-projector-row" style="margin-top: 20px;">
                <button type="button" class="btn btn-secondary" id="open-projector-btn">Dynamic Target</button>
            </div>
            <button type="button" class="btn btn-primary" id="settings-modal-done">Done</button>
        </div>
    </div>

    <!-- Player stats modal -->
    <div class="player-stats-modal-overlay" id="player-stats-modal" role="dialog" aria-label="Player stats">
        <div class="player-stats-modal">
            <h3 id="player-stats-title">Player</h3>
            <div class="player-stats-header">
                <div id="player-stats-avatar" class="player-stats-avatar"></div>
                <div class="player-stats-meta">
                    <div id="player-stats-hp" class="player-stats-row"></div>
                    <div id="player-stats-turn-order" class="player-stats-row"></div>
                    <div id="player-stats-status" class="player-stats-row"></div>
                    <div id="player-stats-hit-drop" class="player-stats-row"></div>
                    <div id="player-stats-rolled-claimed" class="player-stats-row"></div>
                    <div id="player-stats-critical" class="player-stats-row"></div>
                </div>
            </div>
            <div class="player-stats-section">
                <h4>Drops</h4>
                <p id="player-stats-drops-hint" class="setting-hint"></p>
                <button type="button" class="btn btn-secondary" id="player-stats-undo-drop-btn" style="display: none;">Undo last drop</button>
            </div>
            <button type="button" class="btn btn-primary" id="player-stats-close-btn">Close</button>
        </div>
    </div>

    <!-- Miss confirmation modal -->
    <div class="miss-modal-overlay" id="miss-modal" role="dialog" aria-labelledby="miss-modal-title" aria-modal="true">
        <div class="miss-modal">
            <div class="miss-modal-player" id="miss-modal-player-name"></div>
            <div class="miss-modal-question" id="miss-modal-title">Missed?</div>
            <div class="miss-modal-buttons">
                <button type="button" class="btn btn-secondary" id="miss-modal-no">No</button>
                <button type="button" class="btn btn-primary" id="miss-modal-yes">Yes</button>
            </div>
        </div>
    </div>

    <!-- Critical hit onscreen reaction -->
    <div class="critical-reaction" id="critical-reaction" aria-live="polite">
        <div class="critical-reaction-inner">Critical!</div>
    </div>

    <!-- Miss onscreen reaction -->
    <div class="miss-reaction" id="miss-reaction" aria-live="polite">
        <div class="miss-reaction-inner">Miss!</div>
    </div>

    <!-- Custom circular color picker modal (must be in DOM before script runs) -->
    <div class="color-picker-modal-overlay" id="color-picker-modal" role="dialog" aria-label="Pick color">
        <div class="color-picker-modal">
            <h3>Pick your color</h3>
            <div class="color-wheel-container" id="color-wheel-container">
                <div class="color-wheel-hue" id="color-wheel-hue"></div>
                <div class="color-wheel-inner"></div>
                <div class="color-wheel-sat" id="color-wheel-sat"></div>
                <div class="color-wheel-hue-handle" id="color-hue-handle"></div>
                <div class="color-wheel-sat-handle" id="color-sat-handle"></div>
            </div>
            <div class="color-picker-lightness">
                <label for="color-lightness-input">Brightness</label>
                <input type="range" id="color-lightness-input" min="0" max="100" value="50">
            </div>
            <button type="button" class="color-picker-done" id="color-picker-done">Done</button>
        </div>
    </div>

    <script>
    // ── RPG background: CSS ember particles & runes ──
    (function() {
        const container = document.getElementById('gameCssParticles');
        const colors = ['rgba(200, 140, 50, 0.6)', 'rgba(180, 120, 60, 0.4)', 'rgba(160, 130, 80, 0.3)', 'rgba(140, 160, 200, 0.2)', 'rgba(200, 180, 100, 0.5)'];
        if (container) {
            for (let i = 0; i < 30; i++) {
                const p = document.createElement('div');
                p.className = 'game-bg-particle';
                const size = Math.random() * 3 + 1;
                const color = colors[Math.floor(Math.random() * colors.length)];
                p.style.cssText = `width: ${size}px; height: ${size}px; background: ${color}; box-shadow: 0 0 ${size * 2}px ${color}; left: ${Math.random() * 100}%; bottom: ${Math.random() * 20 - 10}%; animation-duration: ${Math.random() * 15 + 10}s; animation-delay: ${Math.random() * 15}s;`;
                container.appendChild(p);
            }
        }
        const runeContainer = document.getElementById('gameRuneContainer');
        const glyphs = ['\u16A0','\u16A2','\u16A6','\u16A8','\u16B1','\u16B7','\u16B9','\u16BE','\u16C1','\u16C3','\u16C7','\u16C8','\u16CA','\u16CF','\u16D2','\u16D6','\u16DA','\u16DE','\u16DF','\u16E0'];
        const runeColors = ['#b48c3c', '#8a7a5a', '#6a7aa0', '#9a8a6a', '#7a6a9a'];
        if (runeContainer) {
            for (let i = 0; i < 12; i++) {
                const r = document.createElement('div');
                r.className = 'game-bg-rune';
                r.textContent = glyphs[Math.floor(Math.random() * glyphs.length)];
                r.style.cssText = `left: ${Math.random() * 90 + 5}%; top: ${Math.random() * 80 + 10}%; font-size: ${Math.random() * 18 + 14}px; color: ${runeColors[Math.floor(Math.random() * runeColors.length)]}; animation-duration: ${Math.random() * 8 + 8}s; animation-delay: ${Math.random() * 10}s;`;
                runeContainer.appendChild(r);
            }
        }
    })();
    </script>
    <script src="rpg-bg-canvas.js"></script>
    <script>
        // Game State
        const state = {
            players: [],
            currentPlayerIndex: 0,
            phase: 'setup',
            currentRoll: [],
            hits: [],
            totalDamage: 0,
            hasRolled: false,
            hasAttacked: false,
            damageClaimedPhase: false,
            currentHitIndex: 0,
            attackLog: [],
            gameLog: [],
            autoDealDamage: false,
            hasScoreBeenEntered: false,
            lastDroppedKnifeLogIndex: undefined,
            dropsThisTurn: 0,
            dropsThisTurnLogIndices: [],
            damageDealtThisTurn: false,
            modBuffOnCritical: false,
            modNerfOnMiss: false
        };

        const projectorChannel = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('daggerdie-projector') : null;

        const COLORS = [
            { name: 'Red', hex: '#e74c3c' },
            { name: 'Blue', hex: '#3498db' },
            { name: 'Green', hex: '#2ecc71' },
            { name: 'Purple', hex: '#9b59b6' },
            { name: 'Orange', hex: '#e67e22' },
            { name: 'Pink', hex: '#fd79a8' },
            { name: 'Cyan', hex: '#00cec9' },
            { name: 'Yellow', hex: '#f1c40f' }
        ];

        function hexToHSL(hex) {
            const n = parseInt(hex.slice(1), 16);
            const r = (n >> 16) / 255, g = ((n >> 8) & 0xff) / 255, b = (n & 0xff) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                else if (max === g) h = ((b - r) / d + 2) / 6;
                else h = ((r - g) / d + 4) / 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            s /= 100; l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / 30) % 12;
                return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
            };
            const r = Math.round(f(0) * 255), g = Math.round(f(8) * 255), b = Math.round(f(4) * 255);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const turnOrderScreen = document.getElementById('turn-order-screen');
        const gameScreen = document.getElementById('game-screen');
        const winnerScreen = document.getElementById('winner-screen');
        const playerSetup = document.getElementById('player-setup');
        const startGameBtn = document.getElementById('start-game-btn');
        const playersPanel = document.getElementById('players-panel');
        const currentPlayerNameEl = document.getElementById('current-player-name');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const diceResults = document.getElementById('dice-results');
        const hitInfo = document.getElementById('hit-info');
        const attackPrompt = document.getElementById('attack-prompt');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const droppedKnifeBtn = document.getElementById('dropped-knife-btn');
        const gameLogEntries = document.getElementById('game-log-entries');

        // Custom circular color picker
        const colorPickerModal = document.getElementById('color-picker-modal');
        const colorWheelContainer = document.getElementById('color-wheel-container');
        const colorWheelSat = document.getElementById('color-wheel-sat');
        const colorHueHandle = document.getElementById('color-hue-handle');
        const colorSatHandle = document.getElementById('color-sat-handle');
        const colorLightnessInput = document.getElementById('color-lightness-input');
        const colorPickerDone = document.getElementById('color-picker-done');

        const settingsModal = document.getElementById('settings-modal');
        const settingsGearBtn = document.getElementById('settings-gear-btn');
        const useCustomHpCb = document.getElementById('use-custom-hp-cb');
        const customHpInput = document.getElementById('custom-hp-input');
        const modBuffOnCriticalCb = document.getElementById('mod-buff-on-critical-cb');
        const modNerfOnMissCb = document.getElementById('mod-nerf-on-miss-cb');
        const persistentSettingsCb = document.getElementById('persistent-settings-cb');
        const settingsModalDone = document.getElementById('settings-modal-done');

        useCustomHpCb.addEventListener('change', () => {
            customHpInput.disabled = !useCustomHpCb.checked;
        });

        const settingsReadOnlyHint = document.getElementById('settings-readonly-hint');

        settingsGearBtn.addEventListener('click', () => {
            const readOnly = state.hasScoreBeenEntered;
            persistentSettingsCb.checked = isPersistentSettings();
            const usePersistent = persistentSettingsCb.checked;
            const useCustom = usePersistent && localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true';
            useCustomHpCb.checked = useCustom;
            if (useCustom) {
                const savedHp = localStorage.getItem(CUSTOM_HP_KEY);
                customHpInput.value = savedHp !== null && savedHp !== '' ? savedHp : '';
            } else {
                customHpInput.value = state.players.length > 0 ? String(getDefaultHp(state.players.length)) : '';
            }
            useCustomHpCb.disabled = readOnly;
            customHpInput.disabled = readOnly || !useCustomHpCb.checked;
            modBuffOnCriticalCb.checked = usePersistent ? (localStorage.getItem(MOD_BUFF_ON_CRITICAL_KEY) === 'true') : false;
            modNerfOnMissCb.checked = usePersistent ? (localStorage.getItem(MOD_NERF_ON_MISS_KEY) === 'true') : false;
            modBuffOnCriticalCb.disabled = readOnly;
            modNerfOnMissCb.disabled = readOnly;
            if (settingsReadOnlyHint) settingsReadOnlyHint.style.display = readOnly ? 'block' : 'none';
            settingsModalDone.textContent = readOnly ? 'Close' : 'Done';
            settingsModal.classList.add('open');
        });

        persistentSettingsCb.addEventListener('change', () => {
            // Persistent checkbox does not affect other settings; each is independent
        });

        settingsModalDone.addEventListener('click', () => {
            localStorage.setItem(PERSISTENT_SETTINGS_KEY, String(persistentSettingsCb.checked));
            if (persistentSettingsCb.checked) {
                localStorage.setItem(MOD_BUFF_ON_CRITICAL_KEY, String(modBuffOnCriticalCb.checked));
                localStorage.setItem(MOD_NERF_ON_MISS_KEY, String(modNerfOnMissCb.checked));
                localStorage.setItem(USE_CUSTOM_HP_KEY, String(useCustomHpCb.checked));
                if (useCustomHpCb.checked) {
                    const val = customHpInput.value.trim();
                    const n = val === '' ? NaN : parseInt(val, 10);
                    if (!isNaN(n) && n >= 20 && n <= 999) {
                        localStorage.setItem(CUSTOM_HP_KEY, String(n));
                    }
                } else {
                    localStorage.removeItem(CUSTOM_HP_KEY);
                }
            } else {
                localStorage.removeItem(MOD_BUFF_ON_CRITICAL_KEY);
                localStorage.removeItem(MOD_NERF_ON_MISS_KEY);
                localStorage.removeItem(USE_CUSTOM_HP_KEY);
                localStorage.removeItem(CUSTOM_HP_KEY);
            }
            if (state.hasScoreBeenEntered) {
                settingsModal.classList.remove('open');
                return;
            }
            if (useCustomHpCb.checked) {
                const val = customHpInput.value.trim();
                const n = val === '' ? NaN : parseInt(val, 10);
                if (isNaN(n) || n < 20 || n > 999) {
                    alert('Please enter a value between 20 and 999.');
                    return;
                }
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'true');
                localStorage.setItem(CUSTOM_HP_KEY, String(n));
                if (state.players.length > 0) {
                    state.players.forEach(p => {
                        p.hp = n;
                        p.maxHp = n;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            } else {
                localStorage.setItem(USE_CUSTOM_HP_KEY, 'false');
                if (state.players.length > 0) {
                    const defaultHp = getDefaultHp(state.players.length);
                    state.players.forEach(p => {
                        p.hp = defaultHp;
                        p.maxHp = defaultHp;
                    });
                    updatePlayersPanel();
                    if (state.damageClaimedPhase) enableTargetSelection();
                }
            }
            state.modBuffOnCritical = modBuffOnCriticalCb.checked;
            state.modNerfOnMiss = modNerfOnMissCb.checked;
            localStorage.setItem(PERSISTENT_SETTINGS_KEY, String(persistentSettingsCb.checked));
            if (persistentSettingsCb.checked) {
                localStorage.setItem(MOD_BUFF_ON_CRITICAL_KEY, String(state.modBuffOnCritical));
                localStorage.setItem(MOD_NERF_ON_MISS_KEY, String(state.modNerfOnMiss));
                if (useCustomHpCb.checked) {
                    localStorage.setItem(USE_CUSTOM_HP_KEY, 'true');
                    localStorage.setItem(CUSTOM_HP_KEY, String(customHpInput.value.trim()));
                } else {
                    localStorage.setItem(USE_CUSTOM_HP_KEY, 'false');
                }
            } else {
                localStorage.removeItem(MOD_BUFF_ON_CRITICAL_KEY);
                localStorage.removeItem(MOD_NERF_ON_MISS_KEY);
                localStorage.removeItem(USE_CUSTOM_HP_KEY);
                localStorage.removeItem(CUSTOM_HP_KEY);
            }
            settingsModal.classList.remove('open');
        });

        const openProjectorBtn = document.getElementById('open-projector-btn');
        if (openProjectorBtn) {
            openProjectorBtn.addEventListener('click', () => {
                const rolls = (state.currentRoll || []).join(',');
                const claimed = (state.hits || []).map(h => h.roll).join(',');
                const url = 'projector.html?rolls=' + encodeURIComponent(rolls) + '&claimed=' + encodeURIComponent(claimed);
                const features = 'width=800,height=800,menubar=no,toolbar=no,location=no,status=no';
                window.open(url, 'DaggerDieProjector', features);
            });
        }

        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) settingsModal.classList.remove('open');
        });

        let colorPickerState = { wrap: null, input: null, swatch: null, h: 0, s: 100, l: 50 };
        const WHEEL_SIZE = 260;
        const WHEEL_PADDING = 12;
        const WHEEL_INNER_R = (WHEEL_SIZE / 2) - WHEEL_PADDING;

        function openColorPicker(wrap) {
            const input = wrap.querySelector('.player-color-input');
            const swatch = wrap.querySelector('.color-swatch');
            const hex = input.value || '#e74c3c';
            const hsl = hexToHSL(hex);
            colorPickerState = { wrap, input, swatch, h: hsl.h, s: hsl.s, l: hsl.l };
            colorLightnessInput.value = Math.round(hsl.l);
            colorPickerModal.classList.add('open');
            updatePickerGradient();
            updatePickerHandles();
        }

        function updatePickerGradient() {
            const { h } = colorPickerState;
            const gray = hslToHex(h, 0, 50);
            const hueColor = hslToHex(h, 100, 50);
            colorWheelSat.style.setProperty('--picker-gray', gray);
            colorWheelSat.style.setProperty('--picker-hue-color', hueColor);
        }

        function updatePickerHandles() {
            const { h, s } = colorPickerState;
            const rad = (h - 90) * Math.PI / 180;
            const hueR = 48;
            colorHueHandle.style.left = (50 + hueR * Math.cos(rad)) + '%';
            colorHueHandle.style.top = (50 + hueR * Math.sin(rad)) + '%';
            const satR = (s / 100) * 42;
            colorSatHandle.style.left = (50 + satR) + '%';
            colorSatHandle.style.top = '50%';
        }

        function commitPickerColor() {
            const { input, swatch, h, s, l } = colorPickerState;
            const hex = hslToHex(h, s, l);
            if (input) input.value = hex;
            if (swatch) swatch.style.background = hex;
        }

        function getWheelXY(e) {
            const rect = colorWheelContainer.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const x = (e.clientX ?? e.touches?.[0]?.clientX) - cx;
            const y = (e.clientY ?? e.touches?.[0]?.clientY) - cy;
            const dist = Math.sqrt(x * x + y * y);
            const angle = Math.atan2(y, x);
            return { x, y, dist, angle };
        }

        function onWheelPointerDown(e) {
            e.preventDefault();
            const { dist, angle } = getWheelXY(e);
            const isHue = dist > WHEEL_INNER_R;
            let move = (e2) => {
                const xy = getWheelXY(e2);
                if (isHue) {
                    colorPickerState.h = ((xy.angle * 180 / Math.PI + 90) + 360) % 360;
                    updatePickerGradient();
                } else {
                    colorPickerState.s = Math.min(100, Math.max(0, (xy.dist / WHEEL_INNER_R) * 100));
                    updatePickerHandles();
                }
                updatePickerHandles();
                commitPickerColor();
            };
            const up = () => {
                document.removeEventListener('pointermove', move);
                document.removeEventListener('pointerup', up);
                document.removeEventListener('touchmove', move, { passive: false });
                document.removeEventListener('touchend', up);
            };
            if (isHue) {
                colorPickerState.h = ((angle * 180 / Math.PI + 90) + 360) % 360;
                updatePickerGradient();
            } else {
                colorPickerState.s = Math.min(100, Math.max(0, (dist / WHEEL_INNER_R) * 100));
            }
            updatePickerHandles();
            commitPickerColor();
            document.addEventListener('pointermove', move);
            document.addEventListener('pointerup', up);
            document.addEventListener('touchmove', move, { passive: false });
            document.addEventListener('touchend', up);
        }

        document.addEventListener('click', (e) => {
            const wrap = e.target.closest('.color-picker-wrap');
            if (wrap) {
                e.preventDefault();
                openColorPicker(wrap);
            }
        });

        colorWheelContainer.addEventListener('pointerdown', onWheelPointerDown);
        colorWheelContainer.addEventListener('touchstart', onWheelPointerDown, { passive: false });

        colorLightnessInput.addEventListener('input', () => {
            colorPickerState.l = parseInt(colorLightnessInput.value, 10);
            commitPickerColor();
        });

        colorPickerDone.addEventListener('click', () => {
            colorPickerModal.classList.remove('open');
        });

        colorPickerModal.addEventListener('click', (e) => {
            if (e.target === colorPickerModal) colorPickerModal.classList.remove('open');
        });

        // Setup: Player count selection
        document.querySelectorAll('.player-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const count = parseInt(btn.dataset.count);
                setupPlayerInputs(count);
            });
        });

        function setupPlayerInputs(count) {
            playerSetup.innerHTML = '';
            playerSetup.classList.add('visible');
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }

            const usedColors = new Set();

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'player-input';
                const defaultHex = COLORS[i % COLORS.length].hex;
                div.innerHTML = `
                    <span>P${i + 1}</span>
                    <input type="text" placeholder="Player ${i + 1} Name" data-player="${i}" maxlength="30">
                    <div class="color-picker" data-player="${i}">
                        <div class="color-picker-wrap" data-player="${i}" title="Pick your color">
                            <span class="color-swatch" style="background: ${defaultHex};"></span>
                            <input type="color" class="player-color-input" data-player="${i}" value="${defaultHex}" aria-hidden="true">
                        </div>
                    </div>
                `;
                playerSetup.appendChild(div);
            }

            playerSetup.querySelectorAll('input[type="text"]').forEach(input => {
                input.addEventListener('input', checkDuplicateNames);
            });

            startGameBtn.style.display = 'block';
        }

        function checkDuplicateNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error-duplicate'));

            const names = [];
            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const nameCount = {};
            names.forEach(n => {
                const key = n.toLowerCase();
                nameCount[key] = (nameCount[key] || 0) + 1;
            });

            const duplicates = new Set(Object.entries(nameCount).filter(([, c]) => c > 1).map(([k]) => k));

            if (duplicates.size > 0) {
                inputs.forEach((input, idx) => {
                    if (duplicates.has(names[idx].toLowerCase())) {
                        input.closest('.player-input').classList.add('error-duplicate');
                    }
                });
                errorEl.textContent = `Names must be unique: ${[...duplicates].join(', ')} appears more than once.`;
                errorEl.classList.remove('hidden');
            } else {
                errorEl.classList.add('hidden');
                errorEl.textContent = '';
            }
        }

        const CUSTOM_HP_KEY = 'daggerdie_customHp';
        const USE_CUSTOM_HP_KEY = 'daggerdie_useCustomHp';
        const MOD_BUFF_ON_CRITICAL_KEY = 'daggerdie_modBuffOnCritical';
        const MOD_NERF_ON_MISS_KEY = 'daggerdie_modNerfOnMiss';
        const PERSISTENT_SETTINGS_KEY = 'daggerdie_persistentSettings';

        function isPersistentSettings() {
            return localStorage.getItem(PERSISTENT_SETTINGS_KEY) === 'true';
        }

        function applySettingsForNewGame() {
            if (isPersistentSettings()) {
                state.modBuffOnCritical = localStorage.getItem(MOD_BUFF_ON_CRITICAL_KEY) === 'true';
                state.modNerfOnMiss = localStorage.getItem(MOD_NERF_ON_MISS_KEY) === 'true';
            } else {
                state.modBuffOnCritical = false;
                state.modNerfOnMiss = false;
            }
        }

        function getDefaultHp(playerCount) {
            if (isPersistentSettings() && localStorage.getItem(USE_CUSTOM_HP_KEY) === 'true') {
                const custom = localStorage.getItem(CUSTOM_HP_KEY);
                if (custom !== null && custom !== '') {
                    const n = parseInt(custom, 10);
                    if (!isNaN(n) && n >= 20 && n <= 999) return n;
                }
            }
            if (playerCount <= 2) return 50;
            if (playerCount <= 4) return 40;
            return 60; // 5-6 players
        }

        const NAME_MIN_LEN = 2;
        const NAME_MAX_LEN = 30;

        function validatePlayerNames() {
            const inputs = playerSetup.querySelectorAll('input[type="text"]');
            const errorEl = document.getElementById('setup-error');
            const names = [];
            let firstInvalidInput = null;

            document.querySelectorAll('.player-input').forEach(el => el.classList.remove('error', 'error-duplicate'));

            for (let idx = 0; idx < inputs.length; idx++) {
                const raw = inputs[idx].value.trim();
                names.push(raw || `Player ${idx + 1}`);
            }

            const duplicateNames = new Set(
                names.filter((n, i) => names.findIndex(x => x.toLowerCase() === n.toLowerCase()) !== i)
                    .map(n => n.toLowerCase())
            );

            for (let idx = 0; idx < inputs.length; idx++) {
                const input = inputs[idx];
                const raw = input.value.trim();
                const name = raw || `Player ${idx + 1}`;
                const playerInputEl = input.closest('.player-input');

                if (raw) {
                    if (raw.length < NAME_MIN_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    } else if (raw.length > NAME_MAX_LEN) {
                        if (!firstInvalidInput) firstInvalidInput = input;
                        playerInputEl.classList.add('error');
                    }
                }

                if (duplicateNames.has(name.toLowerCase())) {
                    if (!firstInvalidInput) firstInvalidInput = input;
                    playerInputEl.classList.add('error', 'error-duplicate');
                }
            }

            const errors = [];
            inputs.forEach((input, idx) => {
                const el = input.closest('.player-input');
                if (!el.classList.contains('error')) return;
                const raw = input.value.trim();
                if (raw && raw.length < NAME_MIN_LEN) {
                    errors.push(`"${raw || input.value}" is too short (min ${NAME_MIN_LEN} characters).`);
                } else if (raw && raw.length > NAME_MAX_LEN) {
                    errors.push(`"${input.value}" is too long (max ${NAME_MAX_LEN} characters).`);
                }
            });
            if (duplicateNames.size > 0) {
                errors.push(`Names must be unique: ${[...duplicateNames].join(', ')} appears more than once.`);
            }

            if (errors.length > 0) {
                errorEl.textContent = errors.join(' ');
                errorEl.classList.remove('hidden');
                if (firstInvalidInput) firstInvalidInput.focus();
                return false;
            }
            errorEl.classList.add('hidden');
            errorEl.textContent = '';
            return true;
        }

        startGameBtn.addEventListener('click', () => {
            if (!validatePlayerNames()) return;

            applySettingsForNewGame();
            const nameInputs = playerSetup.querySelectorAll('input[type="text"]');
            state.players = [];
            const defaultHp = getDefaultHp(nameInputs.length);

            nameInputs.forEach((input, idx) => {
                const colorPicker = playerSetup.querySelector(`.color-picker[data-player="${idx}"]`);
                const colorInput = colorPicker.querySelector('input[type="color"]');
                const hex = colorInput ? colorInput.value : COLORS[idx % COLORS.length].hex;
                const name = input.value.trim() || `Player ${idx + 1}`;

                state.players.push({
                    id: idx,
                    name,
                    color: { name: 'Custom', hex },
                    hp: defaultHp,
                    maxHp: defaultHp,
                    turnOrderRoll: 0,
                    eliminated: false,
                    totalRolled: 0,
                    totalClaimed: 0,
                    criticals: 0,
                    buffActive: false,
                    nerfActive: false
                });
            });

            state.autoDealDamage = localStorage.getItem('daggerdie_autoDealDamage') === 'true';

            showTurnOrderScreen();

            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                setTimeout(() => {
                    document.getElementById('roll-turn-order-btn')?.click();
                }, 400);
            }
        });

        function showTurnOrderScreen() {
            setupScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            if (localStorage.getItem('daggerdie_autoRollTurnOrder') === 'true') {
                rollBtn.classList.add('hidden');
            }

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');
        }

        document.getElementById('roll-turn-order-btn').addEventListener('click', async () => {
            const btn = document.getElementById('roll-turn-order-btn');
            btn.disabled = true;

            for (let player of state.players) {
                const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                const rollValue = playerDiv.querySelector('.roll-value');

                for (let i = 0; i < 10; i++) {
                    rollValue.textContent = rollD20();
                    await sleep(50);
                }

                player.turnOrderRoll = rollD20();
                rollValue.textContent = player.turnOrderRoll;
                await sleep(300);
            }

            state.players.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

            const rollsDiv = document.getElementById('turn-order-rolls');
            const tieMessage = document.createElement('p');
            tieMessage.id = 'tie-reroll-message';
            tieMessage.style.cssText = 'color: #feca57; margin: 15px 0; font-weight: bold;';
            tieMessage.style.display = 'none';
            if (!document.getElementById('tie-reroll-message')) {
                rollsDiv.parentNode.insertBefore(tieMessage, rollsDiv.nextSibling);
            }

            function updateTurnOrderDisplay() {
                rollsDiv.innerHTML = state.players.map((p, idx) => `
                    <div class="turn-order-player" data-player="${p.id}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                            <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                            <span>${p.name}</span>
                        </div>
                        <span class="roll-value">${p.turnOrderRoll}</span>
                    </div>
                `).join('');
            }

            // Find tie groups (consecutive players with same roll) - each resolves independently
            const tieGroupsWithIndex = [];
            for (let i = 0; i < state.players.length; i++) {
                const startIdx = i;
                const group = [state.players[i]];
                while (i + 1 < state.players.length && state.players[i + 1].turnOrderRoll === state.players[i].turnOrderRoll) {
                    group.push(state.players[++i]);
                }
                if (group.length > 1) {
                    tieGroupsWithIndex.push({ startIdx, players: group });
                }
            }

            // Resolve each tie group in isolation - only the tied players reroll for their slots
            for (const { startIdx, players: tiedPlayers } of tieGroupsWithIndex) {
                let hasTieInGroup;
                do {
                    hasTieInGroup = false;
                    tieMessage.textContent = `Tie between ${tiedPlayers.map(p => p.name).join(', ')}! Rerolling for slot...`;
                    tieMessage.style.display = 'block';
                    await sleep(500);

                    for (let player of tiedPlayers) {
                        const playerDiv = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (playerDiv) {
                            const rollValue = playerDiv.querySelector('.roll-value');
                            for (let i = 0; i < 8; i++) {
                                rollValue.textContent = rollD20();
                                await sleep(40);
                            }
                        }
                        player.turnOrderRoll = rollD20();
                        const div = document.querySelector(`.turn-order-player[data-player="${player.id}"]`);
                        if (div) div.querySelector('.roll-value').textContent = player.turnOrderRoll;
                        await sleep(200);
                    }

                    tiedPlayers.sort((a, b) => b.turnOrderRoll - a.turnOrderRoll);

                    for (let j = 0; j < tiedPlayers.length - 1; j++) {
                        if (tiedPlayers[j].turnOrderRoll === tiedPlayers[j + 1].turnOrderRoll) {
                            hasTieInGroup = true;
                            break;
                        }
                    }

                    for (let j = 0; j < tiedPlayers.length; j++) {
                        state.players[startIdx + j] = tiedPlayers[j];
                    }
                    updateTurnOrderDisplay();
                    tieMessage.style.display = 'none';
                    await sleep(300);
                } while (hasTieInGroup);
            }

            tieMessage.style.display = 'none';
            await sleep(500);
            rollsDiv.innerHTML = state.players.map((p, idx) => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: bold; width: 25px;">#${idx + 1}</span>
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">${p.turnOrderRoll}</span>
                </div>
            `).join('');

            btn.classList.add('hidden');
            const beginBtn = document.getElementById('begin-game-btn');
            beginBtn.classList.remove('hidden');
            if (localStorage.getItem('daggerdie_autoBeginGame') === 'true') {
                beginBtn.classList.add('hidden');
                setTimeout(() => beginBtn.click(), 500);
            }
        });

        document.getElementById('begin-game-btn').addEventListener('click', () => {
            turnOrderScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            state.phase = 'playing';
            state.currentPlayerIndex = 0;
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;
            updateGameUI();
        });

        function rollD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCurrentPlayer() {
            return state.players[state.currentPlayerIndex];
        }

        function getAlivePlayers() {
            return state.players.filter(p => !p.eliminated);
        }

        function updateGameUI() {
            updatePlayersPanel();
            updateCurrentPlayerDisplay();
            clearHighlights();
            resetDice();
            diceResults.innerHTML = '';
            hitInfo.innerHTML = '';
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.add('hidden');
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.hits = [];
            state.totalDamage = 0;
            state.currentHitIndex = 0;
            state.attackLog = [];
            rollDiceBtn.disabled = false;
            disableTargetSelection();
            droppedKnifeBtn.classList.add('hidden');

            if (localStorage.getItem('daggerdie_autoRollDice') === 'true') {
                rollDiceBtn.classList.add('hidden');
                setTimeout(() => rollDiceBtn.click(), 300);
            } else {
                rollDiceBtn.classList.remove('hidden');
            }
        }

        function spawnDeathGhost(cardRect) {
            if (!cardRect || cardRect.width === 0) return;
            const ghost = document.createElement('div');
            ghost.className = 'death-ghost';
            const cx = cardRect.left + cardRect.width / 2;
            const cy = cardRect.top + cardRect.height / 2;
            ghost.style.left = (cx - 30) + 'px';
            ghost.style.top = (cy - 35) + 'px';
            ghost.innerHTML = '<svg viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><path fill="rgba(255,255,255,0.9)" d="M30 5c-12 0-22 10-22 22 0 8 4 15 10 19v12l4-4 4 4v-8l4-4 4 4v8l4-4 4 4v-12c6-4 10-11 10-19 0-12-10-22-22-22z"/><circle cx="22" cy="25" r="4" fill="#1a1a2e"/><circle cx="38" cy="25" r="4" fill="#1a1a2e"/><path fill="#1a1a2e" d="M26 38c0 2 1.5 4 4 4s4-2 4-4c0-1-1-2-4-2s-4 1-4 2z"/></svg>';
            document.body.appendChild(ghost);
            setTimeout(() => ghost.remove(), 1900);
        }

        function updatePlayersPanel() {
            const currentPlayer = getCurrentPlayer();
            playersPanel.innerHTML = state.players.map(p => `
                <div class="player-card ${p.id === currentPlayer.id ? 'current' : ''} ${p.eliminated ? 'eliminated' : ''} ${p.buffActive ? 'buffed' : ''} ${p.nerfActive ? 'nerfed' : ''}"
                     data-player="${p.id}">
                    <button type="button" class="player-card-stats-btn" data-player="${p.id}" aria-label="Stats and drops">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                    </button>
                    <div class="player-avatar" style="background: ${p.color.hex};"></div>
                    <div class="player-name">${p.name}</div>
                    <div class="player-hp">${p.hp} HP</div>
                    <div class="hp-bar">
                        <div class="hp-fill" style="width: ${(p.hp / p.maxHp) * 100}%; background: ${p.color.hex};"></div>
                    </div>
                    <div class="player-turn-order">Turn Order: #${state.players.indexOf(p) + 1}</div>
                    ${p.buffActive ? '<div class="player-card-status buff">Buff</div>' : ''}
                    ${p.nerfActive ? '<div class="player-card-status nerf">Nerf</div>' : ''}
                </div>
            `).join('');
        }

        function updateCurrentPlayerDisplay() {
            const current = getCurrentPlayer();
            currentPlayerNameEl.textContent = current.name;
            currentPlayerNameEl.style.color = current.color.hex;
        }

        rollDiceBtn.addEventListener('click', async () => {
            if (state.hasRolled) return;

            rollDiceBtn.disabled = true;
            const dice = [
                document.getElementById('die1'),
                document.getElementById('die2'),
                document.getElementById('die3')
            ];

            dice.forEach(die => {
                die.classList.add('rolling');
                die.classList.remove('odd', 'even');
            });

            for (let i = 0; i < 15; i++) {
                dice.forEach(die => {
                    die.textContent = rollD20();
                });
                await sleep(50);
            }

            state.currentRoll = [rollD20(), rollD20(), rollD20()];
            state.hits = [];
            state.totalDamage = 0;
            state.damageClaimedPhase = false;

            dice.forEach((die, idx) => {
                die.classList.remove('rolling');
                const value = state.currentRoll[idx];
                die.textContent = value;
                die.classList.add(value % 2 === 0 ? 'even' : 'odd');
            });

            highlightTargets(state.currentRoll);
            displayRollResults();

            state.hasRolled = true;
            const current = getCurrentPlayer();
            current.totalRolled = (current.totalRolled || 0) + state.currentRoll.reduce((s, v) => s + v, 0);
            showHitRecorder();
            droppedKnifeBtn.classList.remove('hidden');
        });

        function highlightTargets(rolls) {
            clearHighlights();
            rolls.forEach(roll => {
                const zone = document.querySelector(`.highlight-zone[data-number="${roll}"]`);
                if (zone) {
                    zone.classList.add('active');
                }
            });
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'roll', rolls: state.currentRoll });
            } catch (e) {}
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                zone.classList.remove('active');
            });
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'clear' });
            } catch (e) {}
        }

        document.addEventListener('click', (e) => {
            const zone = e.target.closest('.highlight-zone');
            if (!zone) return;
            const overlay = zone.closest('.target-overlay');
            if (!overlay || !overlay.classList.contains('clickable')) return;
            const number = parseInt(zone.getAttribute('data-number'));
            if (!state.currentRoll.includes(number)) return;

            const rollIndices = state.currentRoll.map((r, i) => r === number ? i : -1).filter(i => i >= 0);
            const hitIndicesForNumber = new Set(state.hits.filter(h => h.roll === number).map(h => h.idx));
            const firstUnclaimed = rollIndices.find(idx => !hitIndicesForNumber.has(idx));
            if (firstUnclaimed !== undefined) {
                const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                if (state.hits.length >= slotsLeft) return;
                state.hits.push({ roll: number, idx: firstUnclaimed });
            } else {
                const toRemove = state.hits.find(h => h.roll === number);
                if (toRemove) state.hits = state.hits.filter(h => h !== toRemove);
            }
            syncHitRecorderUI();
        });

        function displayRollResults() {
            diceResults.innerHTML = `
                <p>Rolled: <strong>${state.currentRoll.join(', ')}</strong></p>
                <p>Odd targets: <span style="color: #ff6b6b;">${state.currentRoll.filter(r => r % 2 === 1).join(', ') || 'None'}</span></p>
                <p>Even targets: <span style="color: #48dbfb;">${state.currentRoll.filter(r => r % 2 === 0).join(', ') || 'None'}</span></p>
            `;
        }

        const MAX_SCORES_PER_TURN = 3;

        function syncHitRecorderUI() {
            try {
                if (projectorChannel) projectorChannel.postMessage({ type: 'update', rolls: state.currentRoll, claimed: (state.hits || []).map(h => h.roll) });
            } catch (e) {}
            const hitIdxSet = new Set(state.hits.map(h => h.idx));
            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                const idx = parseInt(btn.dataset.idx);
                if (hitIdxSet.has(idx)) {
                    btn.classList.add('hit');
                    btn.style.background = '#2ecc71';
                } else {
                    btn.classList.remove('hit');
                    btn.style.background = '';
                }
            });
            const totalDamageEl = document.getElementById('total-damage-display');
            if (totalDamageEl) totalDamageEl.textContent = state.hits.reduce((sum, h) => sum + h.roll, 0);
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;
            document.querySelectorAll('.highlight-zone').forEach(zone => {
                const num = parseInt(zone.getAttribute('data-number'));
                const claimedForNumber = state.hits.some(h => h.roll === num);
                zone.classList.toggle('claimed', claimedForNumber);
            });
        }

        function showHitRecorder(initialHits) {
            const currentPlayer = getCurrentPlayer();
            droppedKnifeBtn.classList.remove('hidden');

            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice() : [];

            const maxDiceScores = Math.max(0, MAX_SCORES_PER_TURN - state.dropsThisTurn);
            state.hits = initialHits && initialHits.length > 0 ? initialHits.slice(0, maxDiceScores) : [];

            attackPrompt.classList.remove('hidden');
            attackPrompt.innerHTML = `<strong>Step 1:</strong> Throw your knives! Tap the target numbers you HIT, or use the buttons below (max 3 scores per turn).`;

            const hitIdxSet = new Set(state.hits.map(h => h.idx));

            hitInfo.innerHTML = `
                <div style="width: 100%; text-align: center; margin-bottom: 15px;">
                    <p style="font-size: 1.1rem;">Tap the <strong>highlighted targets</strong> or buttons below to claim hits (max 3 per turn):</p>
                </div>
                <div style="margin-bottom: 12px; display: flex; flex-direction: column; align-items: center; gap: 2px;">
                    <div class="scores-counter" style="font-size: 0.9rem; opacity: 0.9;">Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}</div>
                    <p style="font-size: 1.3rem; margin: 0;">Damage Claimed: <strong id="total-damage-display" style="color: #feca57; font-size: 1.5rem;">${state.hits.reduce((sum, h) => sum + h.roll, 0)}</strong></p>
                </div>
                <div class="hit-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    ${state.currentRoll.map((roll, idx) => `
                        <button class="btn hit-toggle ${hitIdxSet.has(idx) ? 'hit' : ''}" data-roll="${roll}" data-idx="${idx}" style="min-width: 70px; font-size: 1.3rem; ${hitIdxSet.has(idx) ? 'background: #2ecc71;' : ''}">
                            ${roll}
                        </button>
                    `).join('')}
                </div>
                <div style="margin-top: 12px;">
                    <button class="btn btn-primary" id="confirm-hits-btn">Confirm</button>
                </div>
            `;

            document.getElementById('odd-overlay').classList.add('clickable');
            document.getElementById('even-overlay').classList.add('clickable');
            syncHitRecorderUI();

            hitInfo.querySelectorAll('.hit-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    const roll = parseInt(btn.dataset.roll);
                    const idx = parseInt(btn.dataset.idx);

                    if (btn.classList.contains('hit')) {
                        state.hits = state.hits.filter(h => h.idx !== idx);
                    } else {
                        const slotsLeft = MAX_SCORES_PER_TURN - state.dropsThisTurn;
                        if (state.hits.length >= slotsLeft) return;
                        state.hits.push({ roll, idx });
                    }
                    syncHitRecorderUI();
                });
            });

            document.getElementById('confirm-hits-btn').addEventListener('click', () => {
                document.getElementById('odd-overlay').classList.remove('clickable');
                document.getElementById('even-overlay').classList.remove('clickable');
                state.totalDamage = state.hits.reduce((sum, h) => sum + h.roll, 0);

                if (state.totalDamage > 0) {
                    const isCritical = state.hits.length === MAX_SCORES_PER_TURN;
                    if (isCritical) {
                        currentPlayer.criticals = (currentPlayer.criticals || 0) + 1;
                        if (state.modBuffOnCritical) currentPlayer.buffActive = true;
                        addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => h.roll).join(', ')}) — Critical!`, 'info');
                        showCriticalReaction(currentPlayer.name);
                    } else {
                        addLogEntry(`${currentPlayer.name} claimed ${state.totalDamage} damage points! (Hit: ${state.hits.map(h => h.roll).join(', ')})`, 'info');
                    }
                    showTargetSelection();
                } else {
                    showMissModal(currentPlayer);
                }
            });
        }

        function showTargetSelection() {
            droppedKnifeBtn.classList.add('hidden');
            state.damageDealtThisTurn = true;
            state.damageClaimedPhase = true;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.attackAssignments = [];

            if (state.autoDealDamage) {
                autoDealDamageAndFinish();
                return;
            }
            showNextHitToAssign();
        }

        function getEffectiveDamage(roll, targetPlayer) {
            let damage = roll;
            let modNote = '';
            let modLabel = '';
            if (state.modBuffOnCritical && targetPlayer.buffActive) {
                damage = Math.ceil(roll / 2);
                modNote = ' (buff: half)';
                modLabel = ', buff';
            } else if (state.modNerfOnMiss && targetPlayer.nerfActive) {
                damage = Math.ceil(roll * 1.25);
                modNote = ' (nerf: 125%)';
                modLabel = ', nerf';
            }
            return { damage, modNote, modLabel };
        }

        function autoDealDamageAndFinish() {
            const currentPlayer = getCurrentPlayer();
            for (let i = 0; i < state.hits.length; i++) {
                const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
                if (aliveOpponents.length === 0) break;
                const currentHit = state.hits[i];
                const targetPlayer = aliveOpponents[Math.floor(Math.random() * aliveOpponents.length)];
                const { damage, modNote, modLabel } = getEffectiveDamage(currentHit.roll, targetPlayer);
                state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHit.roll, damage });
                targetPlayer.hp = Math.max(0, targetPlayer.hp - damage);
                state.hasScoreBeenEntered = true;
                currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHit.roll;
                addLogEntry(`${currentPlayer.name} dealt ${damage} damage to ${targetPlayer.name}!${modNote}`, 'damage');
                state.attackLog.push(damage !== currentHit.roll ? `${currentHit.roll} → ${targetPlayer.name} (${damage}${modLabel})` : `${currentHit.roll} → ${targetPlayer.name}`);
                if (targetPlayer.hp <= 0) {
                    const card = document.querySelector(`.player-card[data-player="${targetPlayer.id}"]`);
                    const rect = card ? card.getBoundingClientRect() : null;
                    targetPlayer.eliminated = true;
                    addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
                    updatePlayersPanel();
                    spawnDeathGhost(rect);
                } else {
                    updatePlayersPanel();
                }
                checkWinCondition();
            }
            finishAttackPhase();
        }

        function showNextHitToAssign() {
            const currentPlayer = getCurrentPlayer();

            if (state.currentHitIndex >= state.hits.length) {
                finishAttackPhase();
                return;
            }

            const aliveOpponents = state.players.filter(p => !p.eliminated && p.id !== currentPlayer.id);
            if (aliveOpponents.length === 0) {
                finishAttackPhase();
                return;
            }

            const currentHit = state.hits[state.currentHitIndex];
            const remainingHits = state.hits.slice(state.currentHitIndex);

            attackPrompt.innerHTML = `<strong>Step 2:</strong> Assign hit <span style="color: #feca57; font-size: 1.3rem;">${currentHit.roll}</span> damage - Click an opponent to attack!`;

            hitInfo.innerHTML = `
                <div class="editable-hits-box" id="editable-hits-box" style="background: rgba(46, 204, 113, 0.2); padding: 10px; border-radius: 10px; border: 2px solid #2ecc71; margin-bottom: 10px; cursor: pointer; transition: background 0.2s, border-color 0.2s;" title="Tap to edit hits">
                    <p style="margin-bottom: 5px; font-size: 0.9rem;">Hits to assign <span style="font-size: 0.8rem; opacity: 0.8;">(tap to edit)</span>:</p>
                    <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                        ${remainingHits.map((h, idx) => `
                            <span style="
                                padding: 8px 15px;
                                border-radius: 8px;
                                font-weight: bold;
                                font-size: 1.2rem;
                                background: ${idx === 0 ? '#feca57' : 'rgba(255,255,255,0.2)'};
                                color: ${idx === 0 ? '#1a1a2e' : '#fff'};
                                ${idx === 0 ? 'box-shadow: 0 0 10px rgba(254,202,87,0.5);' : ''}
                            ">${h.roll}</span>
                        `).join('')}
                    </div>
                </div>
                ${state.attackLog.length > 0 ? `
                    <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 5px;">
                        ${state.attackLog.join('<br>')}
                    </div>
                ` : ''}
            `;

            document.getElementById('editable-hits-box').addEventListener('click', () => {
                if (!confirm('Edit hits? You\'ll change which rolls counted as hits and confirm again. Any damage already assigned will be undone.')) return;
                state.attackAssignments.forEach(({ playerId, roll, damage }) => {
                    const p = state.players.find(pl => pl.id === playerId);
                    if (p) {
                        p.hp += (damage !== undefined ? damage : roll);
                        if (p.hp > 0) p.eliminated = false;
                    }
                });
                state.damageClaimedPhase = false;
                state.currentHitIndex = 0;
                state.attackLog = [];
                state.attackAssignments = [];
                updatePlayersPanel();
                checkWinCondition();
                showHitRecorder(state.hits);
            });

            enableTargetSelection();
        }

        function enableTargetSelection() {
            const current = getCurrentPlayer();
            const cards = document.querySelectorAll('.player-card');

            cards.forEach(card => {
                const playerId = parseInt(card.dataset.player);
                const player = state.players.find(p => p.id === playerId);

                if (!player.eliminated && player.id !== current.id) {
                    card.classList.add('targetable');
                    card.addEventListener('click', handleAttack);
                }
            });
        }

        function disableTargetSelection() {
            document.querySelectorAll('.player-card').forEach(card => {
                card.classList.remove('targetable');
                card.removeEventListener('click', handleAttack);
            });
        }

        function handleAttack(e) {
            const card = e.currentTarget;
            const playerId = parseInt(card.dataset.player);
            const targetPlayer = state.players.find(p => p.id === playerId);
            const currentPlayer = getCurrentPlayer();
            const currentHit = state.hits[state.currentHitIndex];
            const { damage, modNote, modLabel } = getEffectiveDamage(currentHit.roll, targetPlayer);

            disableTargetSelection();

            state.attackAssignments.push({ playerId: targetPlayer.id, roll: currentHit.roll, damage });
            targetPlayer.hp = Math.max(0, targetPlayer.hp - damage);
            state.hasScoreBeenEntered = true;
            currentPlayer.totalClaimed = (currentPlayer.totalClaimed || 0) + currentHit.roll;
            addLogEntry(`${currentPlayer.name} dealt ${damage} damage to ${targetPlayer.name}!${modNote}`, 'damage');
            state.attackLog.push(damage !== currentHit.roll ? `${currentHit.roll} → ${targetPlayer.name} (${damage}${modLabel})` : `${currentHit.roll} → ${targetPlayer.name}`);

            if (targetPlayer.hp <= 0) {
                const card = document.querySelector(`.player-card[data-player="${targetPlayer.id}"]`);
                const rect = card ? card.getBoundingClientRect() : null;
                targetPlayer.eliminated = true;
                addLogEntry(`${targetPlayer.name} has been eliminated!`, 'info');
                updatePlayersPanel();
                spawnDeathGhost(rect);
            } else {
                updatePlayersPanel();
            }
            checkWinCondition();

            state.currentHitIndex++;

            if (state.phase === 'playing') {
                showNextHitToAssign();
            }
        }

        function finishAttackPhase() {
            const totalDealt = state.hits.reduce((sum, h) => sum + h.roll, 0);

            hitInfo.innerHTML = `
                <div style="background: rgba(255, 107, 107, 0.2); padding: 15px; border-radius: 10px; border: 2px solid #ff6b6b;">
                    <p style="font-size: 1.1rem; margin-bottom: 8px;">Attacks Complete!</p>
                    <div style="font-size: 0.9rem;">
                        ${state.attackLog.map(log => `<div>${log}</div>`).join('')}
                    </div>
                    <p style="margin-top: 8px;">Total Damage: <strong style="color: #ff6b6b;">${totalDealt}</strong></p>
                </div>
            `;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        function finishTurnNoAttack() {
            droppedKnifeBtn.classList.add('hidden');
            state.damageDealtThisTurn = true;
            hitInfo.innerHTML = `<span class="hit-badge miss">No damage this turn</span>`;
            attackPrompt.classList.add('hidden');
            endTurnBtn.classList.remove('hidden');
            state.hasAttacked = true;
        }

        droppedKnifeBtn.addEventListener('click', () => {
            const MAX_SCORES_PER_TURN = 3;
            if (state.hits.length + state.dropsThisTurn >= MAX_SCORES_PER_TURN) {
                return;
            }
            const current = getCurrentPlayer();
            current.hp = Math.max(0, current.hp - 1);
            state.hasScoreBeenEntered = true;
            state.dropsThisTurn++;
            addLogEntry(`${current.name} dropped a knife! (-1 HP)`, 'damage');
            state.lastDroppedKnifeLogIndex = state.gameLog.length - 1;
            if (!state.damageDealtThisTurn) state.dropsThisTurnLogIndices.push(state.gameLog.length - 1);
            updatePlayersPanel();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / ${MAX_SCORES_PER_TURN}`;

            requestAnimationFrame(() => {
                const card = document.querySelector(`.player-card[data-player="${current.id}"]`);
                if (card) {
                    card.classList.add('player-card-dropped');
                    setTimeout(() => card.classList.remove('player-card-dropped'), 600);
                }
            });

            if (current.hp <= 0) {
                const card = document.querySelector(`.player-card[data-player="${current.id}"]`);
                const rect = card ? card.getBoundingClientRect() : null;
                current.eliminated = true;
                addLogEntry(`${current.name} has been eliminated!`, 'info');
                updatePlayersPanel();
                spawnDeathGhost(rect);
                checkWinCondition();
                if (state.phase === 'playing') {
                    nextTurn();
                }
            }
        });

        const playerStatsModal = document.getElementById('player-stats-modal');
        const playerStatsTitle = document.getElementById('player-stats-title');
        const playerStatsAvatar = document.getElementById('player-stats-avatar');
        const playerStatsHp = document.getElementById('player-stats-hp');
        const playerStatsTurnOrder = document.getElementById('player-stats-turn-order');
        const playerStatsStatus = document.getElementById('player-stats-status');
        const playerStatsHitDrop = document.getElementById('player-stats-hit-drop');
        const playerStatsRolledClaimed = document.getElementById('player-stats-rolled-claimed');
        const playerStatsCritical = document.getElementById('player-stats-critical');
        const playerStatsDropsHint = document.getElementById('player-stats-drops-hint');
        const playerStatsUndoDropBtn = document.getElementById('player-stats-undo-drop-btn');
        const playerStatsCloseBtn = document.getElementById('player-stats-close-btn');

        let playerStatsModalPlayerId = null;

        function openPlayerStatsModal(playerId) {
            const player = state.players.find(p => p.id === playerId);
            if (!player) return;
            playerStatsModalPlayerId = playerId;
            playerStatsTitle.textContent = player.name;
            playerStatsAvatar.style.background = player.color.hex;
            playerStatsHp.textContent = `${player.hp} / ${player.maxHp} HP`;
            playerStatsTurnOrder.textContent = `Turn order: #${state.players.indexOf(player) + 1}`;
            if (player.eliminated) {
                playerStatsStatus.textContent = 'Status: Eliminated';
                playerStatsStatus.style.color = '#e74c3c';
            } else if (player.buffActive) {
                playerStatsStatus.textContent = 'Status: Buff';
                playerStatsStatus.style.color = '#2ecc71';
            } else if (player.nerfActive) {
                playerStatsStatus.textContent = 'Status: Nerf';
                playerStatsStatus.style.color = '#e74c3c';
            } else {
                playerStatsStatus.textContent = 'Status: In Battle';
                playerStatsStatus.style.color = '#48dbfb';
            }

            const hitCount = state.gameLog.filter(e => e.message.includes(player.name) && e.message.includes('dealt') && e.message.includes('damage to')).length;
            const dropCountForStat = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(player.name)).length;
            const totalScoring = hitCount + dropCountForStat;
            if (totalScoring > 0) {
                const hitPct = (hitCount / totalScoring * 100).toFixed(1);
                playerStatsHitDrop.textContent = `Efficiency: ${hitPct}%`;
            } else {
                playerStatsHitDrop.textContent = 'Efficiency: —';
            }

            const rolled = player.totalRolled || 0;
            const claimed = player.totalClaimed || 0;
            if (rolled > 0) {
                const pct = (claimed / rolled * 100).toFixed(1);
                playerStatsRolledClaimed.textContent = `Points: ${claimed}/${rolled} (${pct}%)`;
            } else {
                playerStatsRolledClaimed.textContent = 'Points: —';
            }

            playerStatsCritical.textContent = `Criticals: ${player.criticals || 0}`;

            const current = getCurrentPlayer();
            const undoableCount = !state.damageDealtThisTurn && current.id === player.id ? state.dropsThisTurnLogIndices.length : 0;
            const canUndoDrop = undoableCount > 0;

            const dropCount = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(player.name)).length;
            playerStatsDropsHint.textContent = dropCount === 0 ? 'No drops this game.' : `${dropCount} drop(s) this game.`;
            playerStatsUndoDropBtn.style.display = canUndoDrop ? 'block' : 'none';
            playerStatsUndoDropBtn.textContent = undoableCount === 1 ? 'Undo last drop' : `Undo last drop (${undoableCount} undoable)`;
            playerStatsModal.classList.add('open');
        }

        function closePlayerStatsModal() {
            playerStatsModal.classList.remove('open');
            playerStatsModalPlayerId = null;
        }

        playerStatsCloseBtn.addEventListener('click', closePlayerStatsModal);
        playerStatsModal.addEventListener('click', (e) => { if (e.target === playerStatsModal) closePlayerStatsModal(); });

        playerStatsUndoDropBtn.addEventListener('click', () => {
            if (playerStatsModalPlayerId === null) return;
            const current = getCurrentPlayer();
            if (current.id !== playerStatsModalPlayerId) return;
            if (state.damageDealtThisTurn || state.dropsThisTurnLogIndices.length === 0) return;
            const logIndex = state.dropsThisTurnLogIndices.pop();
            const logEntry = state.gameLog[logIndex];
            if (!logEntry || logEntry.type !== 'damage' || !logEntry.message.includes('dropped a knife') || !logEntry.message.includes(current.name)) {
                state.dropsThisTurnLogIndices.push(logIndex);
                return;
            }
            const domIndex = state.gameLog.length - 1 - logIndex;
            if (gameLogEntries.children[domIndex]) gameLogEntries.children[domIndex].remove();
            state.gameLog.splice(logIndex, 1);
            for (let i = 0; i < state.dropsThisTurnLogIndices.length; i++) {
                if (state.dropsThisTurnLogIndices[i] > logIndex) state.dropsThisTurnLogIndices[i]--;
            }
            current.hp = Math.min(current.maxHp, current.hp + 1);
            if (current.hp > 0) current.eliminated = false;
            state.dropsThisTurn = Math.max(0, state.dropsThisTurn - 1);
            state.lastDroppedKnifeLogIndex = state.dropsThisTurnLogIndices.length > 0 ? state.dropsThisTurnLogIndices[state.dropsThisTurnLogIndices.length - 1] : undefined;
            updatePlayersPanel();
            checkWinCondition();
            const scoreCounter = hitInfo.querySelector('.scores-counter');
            if (scoreCounter) scoreCounter.textContent = `Scores: ${state.hits.length + state.dropsThisTurn} / 3`;
            openPlayerStatsModal(playerStatsModalPlayerId);
        });

        playersPanel.addEventListener('click', (e) => {
            const btn = e.target.closest('.player-card-stats-btn');
            if (!btn) return;
            e.stopPropagation();
            const playerId = parseInt(btn.dataset.player, 10);
            openPlayerStatsModal(playerId);
        });

        endTurnBtn.addEventListener('click', () => {
            nextTurn();
        });

        function nextTurn() {
            disableTargetSelection();
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            let nextIdx = state.currentPlayerIndex;
            const alivePlayers = getAlivePlayers();

            if (alivePlayers.length <= 1) {
                checkWinCondition();
                return;
            }

            do {
                nextIdx = (nextIdx + 1) % state.players.length;
            } while (state.players[nextIdx].eliminated);

            // Clear buff/nerf for the player whose turn is starting (their "1 turn" of effect has ended)
            const nextPlayer = state.players[nextIdx];
            if (nextPlayer) {
                nextPlayer.buffActive = false;
                nextPlayer.nerfActive = false;
            }

            state.currentPlayerIndex = nextIdx;
            addLogEntry(`${getCurrentPlayer().name}'s turn begins.`, 'info');
            updateGameUI();
        }

        function checkWinCondition() {
            const alivePlayers = getAlivePlayers();
            if (alivePlayers.length === 1) {
                state.phase = 'finished';
                showWinner(alivePlayers[0]);
            } else if (alivePlayers.length === 0) {
                state.phase = 'finished';
                showWinner(null);
            }
        }

        function showWinner(winner) {
            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'block';

            if (winner) {
                document.getElementById('winner-name').innerHTML = `
                    <div style="width: 80px; height: 80px; border-radius: 50%; background: ${winner.color.hex}; margin: 0 auto 20px;"></div>
                    <span style="color: ${winner.color.hex};">${winner.name}</span> Wins!
                `;
            } else {
                document.getElementById('winner-name').textContent = "It's a Draw!";
            }
        }

        function generateGameReportHTML(winner) {
            const now = new Date();
            const dateStr = now.toLocaleDateString(undefined, { dateStyle: 'long' });
            const timeStr = now.toLocaleTimeString(undefined, { timeStyle: 'short' });
            const winnerText = winner ? winner.name : "Draw (no winner)";
            const turnOrderList = state.players.map((p, i) => `${i + 1}. ${p.name}`).join(', ');

            const playerRows = state.players.map(p => {
                let status = p.eliminated ? 'Eliminated' : (winner && p.id === winner.id ? 'Winner' : 'Survived');
                return `
                <tr>
                    <td><span class="report-color-dot" style="background:${p.color.hex}"></span> ${escapeHtml(p.name)}</td>
                    <td>${p.hp} / ${p.maxHp}</td>
                    <td><span class="report-status report-status-${status.toLowerCase().replace(/\s/g,'')}">${status}</span></td>
                </tr>`;
            }).join('');

            // Per-player stats for breakdown
            const playerStatsBreakdown = state.players.map(p => {
                const status = p.eliminated ? 'Eliminated' : (winner && p.id === winner.id ? 'Winner' : 'Survived');
                const hitCount = state.gameLog.filter(e => e.message.includes(p.name) && e.message.includes('dealt') && e.message.includes('damage to')).length;
                const dropCount = state.gameLog.filter(e => e.type === 'damage' && e.message.includes('dropped a knife') && e.message.includes(p.name)).length;
                const totalScoring = hitCount + dropCount;
                const efficiency = totalScoring > 0 ? (hitCount / totalScoring * 100).toFixed(1) : '—';
                const rolled = p.totalRolled || 0;
                const claimed = p.totalClaimed || 0;
                const pointsPct = rolled > 0 ? (claimed / rolled * 100).toFixed(1) : '—';
                const pointsStr = rolled > 0 ? `${claimed} / ${rolled} (${pointsPct}%)` : '—';
                return `
                <div class="report-player-card" style="border-left-color: ${p.color.hex}">
                    <h3 class="report-player-name"><span class="report-color-dot" style="background:${p.color.hex}"></span> ${escapeHtml(p.name)}</h3>
                    <table class="report-stats-table">
                        <tr><td>Status</td><td><span class="report-status report-status-${status.toLowerCase().replace(/\s/g,'')}">${status}</span></td></tr>
                        <tr><td>Final HP</td><td>${p.hp} / ${p.maxHp}</td></tr>
                        <tr><td>Hits dealt</td><td>${hitCount}</td></tr>
                        <tr><td>Drops (self-damage)</td><td>${dropCount}</td></tr>
                        <tr><td>Criticals</td><td>${p.criticals || 0}</td></tr>
                        <tr><td>Efficiency</td><td>${efficiency}${efficiency !== '—' ? '%' : ''}</td></tr>
                        <tr><td>Points (claimed / rolled)</td><td>${pointsStr}</td></tr>
                    </table>
                </div>`;
            }).join('');

            const logEntries = state.gameLog.map((e, i) => {
                const cls = e.type === 'damage' ? 'report-log-damage' : e.type === 'heal' ? 'report-log-heal' : 'report-log-info';
                return `<li class="report-log-entry ${cls}"><span class="report-log-num">${i + 1}.</span> ${escapeHtml(e.message)}</li>`;
            }).join('');
            const totalActions = state.gameLog.length;

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dagger &amp; Die - Game Report</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 40px 20px;
            line-height: 1.5;
        }
        .report-container { max-width: 720px; margin: 0 auto; }
        .report-header {
            text-align: center;
            margin-bottom: 36px;
            padding-bottom: 24px;
            border-bottom: 2px solid rgba(255,255,255,0.15);
        }
        .report-title {
            font-size: 2rem;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }
        .report-meta { color: rgba(255,255,255,0.6); font-size: 0.95rem; }
        .report-winner-box {
            background: rgba(254, 202, 87, 0.15);
            border: 2px solid rgba(254, 202, 87, 0.5);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 28px;
            text-align: center;
        }
        .report-winner-label { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.1em; color: rgba(255,255,255,0.7); margin-bottom: 4px; }
        .report-winner-name { font-size: 1.5rem; font-weight: bold; color: #feca57; }
        .report-section {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 24px;
        }
        .report-section h2 {
            font-size: 1.1rem;
            color: #48dbfb;
            margin-bottom: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .report-table { width: 100%; border-collapse: collapse; }
        .report-table th, .report-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .report-table th { color: rgba(255,255,255,0.7); font-weight: 600; font-size: 0.85rem; }
        .report-color-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; margin-right: 6px; }
        .report-status { font-size: 0.85rem; padding: 2px 8px; border-radius: 6px; }
        .report-status-winner { background: rgba(46, 204, 113, 0.3); color: #2ecc71; }
        .report-status-eliminated { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }
        .report-status-survived { background: rgba(72, 219, 251, 0.2); color: #48dbfb; }
        .report-turn-order { color: rgba(255,255,255,0.85); font-size: 0.95rem; }
        .report-log { list-style: none; }
        .report-log-entry { padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 0.9rem; display: flex; gap: 8px; }
        .report-log-entry:last-child { border-bottom: none; }
        .report-log-num { color: rgba(255,255,255,0.4); min-width: 28px; }
        .report-log-damage { color: #ff6b6b; }
        .report-log-heal { color: #2ecc71; }
        .report-log-info { color: #48dbfb; }
        .report-player-card {
            background: rgba(255,255,255,0.04);
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 16px;
            border-left: 4px solid #48dbfb;
        }
        .report-player-card:last-child { margin-bottom: 0; }
        .report-player-name { font-size: 1rem; color: #e8e8e8; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.08); }
        .report-stats-table { width: 100%; font-size: 0.9rem; }
        .report-stats-table td { padding: 4px 0; border: none; }
        .report-stats-table td:first-child { color: rgba(255,255,255,0.6); width: 55%; }
        .report-stats-table td:last-child { color: #e8e8e8; }
    </style>
</head>
<body>
    <div class="report-container">
        <header class="report-header">
            <h1 class="report-title">Dagger &amp; Die</h1>
            <p class="report-meta">Game Report &middot; ${escapeHtml(dateStr)} at ${escapeHtml(timeStr)}</p>
        </header>
        <div class="report-winner-box">
            <div class="report-winner-label">Winner</div>
            <div class="report-winner-name">${escapeHtml(winnerText)}</div>
        </div>
        <section class="report-section">
            <h2>Players (final)</h2>
            <table class="report-table">
                <thead><tr><th>Player</th><th>HP</th><th>Status</th></tr></thead>
                <tbody>${playerRows}</tbody>
            </table>
        </section>
        <section class="report-section">
            <h2>Turn order</h2>
            <p class="report-turn-order">${escapeHtml(turnOrderList)}</p>
        </section>
        <section class="report-section">
            <h2>Player stats breakdown</h2>
            <div class="report-player-cards">${playerStatsBreakdown}</div>
        </section>
        <section class="report-section">
            <h2>Game ledger (${totalActions} entries)</h2>
            <ul class="report-log">${logEntries || '<li class="report-log-info">No actions recorded.</li>'}</ul>
        </section>
    </div>
</body>
</html>`;
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function exportGameReport() {
            const winner = getAlivePlayers().length === 1 ? getAlivePlayers()[0] : null;
            const html = generateGameReportHTML(winner);
            const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank', 'noopener');
            const a = document.createElement('a');
            a.href = url;
            a.download = `dagger-die-report-${new Date().toISOString().slice(0,10)}.html`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 2000);
        }

        document.getElementById('export-report-btn').addEventListener('click', exportGameReport);

        function resetDice() {
            ['die1', 'die2', 'die3'].forEach(id => {
                const die = document.getElementById(id);
                die.textContent = '-';
                die.classList.remove('odd', 'even', 'rolling');
            });
        }

        function addLogEntry(message, type = 'info') {
            state.gameLog.push({ message, type });
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = message;
            gameLogEntries.insertBefore(entry, gameLogEntries.firstChild);
        }

        function showCriticalReaction(playerName) {
            const el = document.getElementById('critical-reaction');
            if (!el) return;
            const inner = el.querySelector('.critical-reaction-inner');
            if (inner) inner.textContent = 'Critical!';
            el.classList.remove('hide');
            el.classList.add('show');
            setTimeout(() => {
                el.classList.remove('show');
                el.classList.add('hide');
                setTimeout(() => el.classList.remove('hide'), 300);
            }, 1000);
        }

        const missModal = document.getElementById('miss-modal');
        const missModalPlayerName = document.getElementById('miss-modal-player-name');
        const missModalYes = document.getElementById('miss-modal-yes');
        const missModalNo = document.getElementById('miss-modal-no');

        function showMissModal(currentPlayer) {
            missModalPlayerName.textContent = currentPlayer.name;
            missModal.classList.add('open');
        }

        function closeMissModal() {
            missModal.classList.remove('open');
        }

        function showMissReaction() {
            const el = document.getElementById('miss-reaction');
            if (!el) return;
            const inner = el.querySelector('.miss-reaction-inner');
            if (inner) inner.textContent = 'Miss!';
            el.classList.remove('hide');
            el.classList.add('show');
            setTimeout(() => {
                el.classList.remove('show');
                el.classList.add('hide');
                setTimeout(() => el.classList.remove('hide'), 300);
            }, 1000);
        }

        missModalYes.addEventListener('click', () => {
            const currentPlayer = getCurrentPlayer();
            closeMissModal();
            if (state.modNerfOnMiss) currentPlayer.nerfActive = true;
            addLogEntry(`${currentPlayer.name} missed all targets!`, 'info');
            showMissReaction();
            finishTurnNoAttack();
        });

        missModalNo.addEventListener('click', () => {
            closeMissModal();
        });

        missModal.addEventListener('click', (e) => {
            if (e.target === missModal) closeMissModal();
        });

        document.getElementById('new-game-btn').addEventListener('click', resetGame);
                function playAgain() {
            applySettingsForNewGame();
            const defaultHp = getDefaultHp(state.players.length);
            state.players.forEach(p => {
                p.hp = defaultHp;
                p.maxHp = defaultHp;
                p.eliminated = false;
                p.turnOrderRoll = 0;
                p.totalRolled = 0;
                p.totalClaimed = 0;
                p.criticals = 0;
                p.buffActive = false;
                p.nerfActive = false;
            });
            state.currentPlayerIndex = 0;
            state.phase = 'turnOrder';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            winnerScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            turnOrderScreen.style.display = 'block';

            const rollBtn = document.getElementById('roll-turn-order-btn');
            rollBtn.classList.remove('hidden');
            rollBtn.disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');

            const rollsDiv = document.getElementById('turn-order-rolls');
            rollsDiv.innerHTML = state.players.map(p => `
                <div class="turn-order-player" data-player="${p.id}">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 30px; height: 30px; border-radius: 50%; background: ${p.color.hex};"></div>
                        <span>${p.name}</span>
                    </div>
                    <span class="roll-value">-</span>
                </div>
            `).join('');

            const tieMsg = document.getElementById('tie-reroll-message');
            if (tieMsg) tieMsg.style.display = 'none';

            gameLogEntries.innerHTML = '';
        }

        document.getElementById('play-again-btn').addEventListener('click', playAgain);
        document.getElementById('finished-btn').addEventListener('click', () => { window.location.href = 'index.html'; });

        function resetGame() {
            state.players = [];
            state.currentPlayerIndex = 0;
            state.phase = 'setup';
            state.currentRoll = [];
            state.hits = [];
            state.totalDamage = 0;
            state.hasRolled = false;
            state.hasAttacked = false;
            state.damageClaimedPhase = false;
            state.currentHitIndex = 0;
            state.attackLog = [];
            state.gameLog = [];
            state.hasScoreBeenEntered = false;
            state.lastDroppedKnifeLogIndex = undefined;
            state.dropsThisTurn = 0;
            state.dropsThisTurnLogIndices = [];
            state.damageDealtThisTurn = false;

            gameScreen.style.display = 'none';
            winnerScreen.style.display = 'none';
            turnOrderScreen.style.display = 'none';
            setupScreen.style.display = 'block';

            document.querySelectorAll('.player-count-btn').forEach(b => b.classList.remove('selected'));
            playerSetup.innerHTML = '';
            playerSetup.classList.remove('visible');
            startGameBtn.style.display = 'none';
            const setupError = document.getElementById('setup-error');
            if (setupError) {
                setupError.classList.add('hidden');
                setupError.textContent = '';
            }
            gameLogEntries.innerHTML = '';

            document.getElementById('roll-turn-order-btn').classList.remove('hidden');
            document.getElementById('roll-turn-order-btn').disabled = false;
            document.getElementById('begin-game-btn').classList.add('hidden');
        }
    </script>
</body>
</html>
